$<$header id=\char`\"{}title\char`\"{}$>$ \doxysection*{AWS Build Accumulator}



Litani Command-\/line reference

$<$/header$>$

AWS Build Accumulator is a suite of tools that collect build jobs from multiple sources before executing them concurrently. Users access AWS Build Accumulator through {\ttfamily litani}, the command-\/line interface. This document serves as a reference for using {\ttfamily litani} and integrating it into your project.

{\ttfamily litani} allows you to use multiple build systems in the same project, providing a backend that each build system emits jobs to. Once all jobs have been enqueued, {\ttfamily litani} executes them all as a single unified build graph. {\ttfamily litani} also provides platform-\/independent job control (timeouts and control of return codes), as well as grouping of job artifacts into stages.

\href{https://github.com/awslabs/aws-build-accumulator}{\texttt{ Source code repository}}\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md91}{}\doxysubsection{Overview}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md91}
Consider the following Makefile\+: \begin{DoxyVerb}foo.out: foo.in
    timeout 90 my_command $^ > $@; if [ $? -eq 10 ]; then exit 0; fi
\end{DoxyVerb}
 {\ttfamily foo.\+out} is built from {\ttfamily foo.\+in} using {\ttfamily my\+\_\+command}. We want to kill {\ttfamily my\+\_\+command} if it runs for more than 90 seconds, and we\textquotesingle{}re also expecting that {\ttfamily my\+\_\+command} may exit with a return code of 10; we don\textquotesingle{}t consider that to be an error, so we exit the subshell with 0 in that case.

The timeout and error escaping in this command are unportable. We can replace it with an invocation to {\ttfamily litani} as follows\+: \begin{DoxyVerb}foo.out: foo.in
    litani add-job                \
      --command "my_command $^"   \
      --inputs $^                 \
      --outputs $@                \
      --timeout 90                \
      --ok-returns 10             \
      --pipeline-name my_command  \
      --ci-stage build            \
      --stdout-file $@
\end{DoxyVerb}
 To actually run this, write the following shell script\+: \begin{DoxyVerb}#!/bin/sh

litani init --project my_project
make foo.out
litani run-build
\end{DoxyVerb}
 Running {\ttfamily make} doesn\textquotesingle{}t actually run the job; rather, it runs {\ttfamily litani}, which saves the job for later. You can run {\ttfamily litani add-\/job} as many times as you like after running {\ttfamily litani init}; all these jobs are cached and turned into a dependency graph using the arguments to {\ttfamily -\/-\/inputs} and {\ttfamily -\/-\/outputs}. Running {\ttfamily litani run-\/build} runs all cached build jobs together, in parallel if possible.

{\ttfamily litani} continuously updates a {\ttfamily run.\+json} file while the {\ttfamily run-\/build} command is running, showing progress of each job as well as recording the return codes, timeout information, and stdout/stderr of each job. This file is documented below and is designed to be easy to render into a dashboard, for example in HTML.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md92}{}\doxysubsection{Motivation}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md92}
While the platform-\/independent job-\/control features are a nice bonus, {\ttfamily litani}\textquotesingle{}s real value is in serving as a backend for executing a graph of build tasks that are added from heterogeneous sources. In a complex software project, different parts of the project can use incompatible build systems. To build the entire project, one must either run all build systems in parallel---potentially overcommitting on concurrency and introducing nondeterminism when some of the targets overlap---or run each build system serially, wasting time.

{\ttfamily litani} makes it possible for jobs that are specified in different build systems to depend on each other. It also obviates the need to force different parts of the project to use a unified build syntax, if that is unnatural for some reason. If some parts of the build tree are specified in Make, with others specified in CMake, then {\ttfamily litani} allows developers working on each part of the codebase to use the build system that makes sense to them, while {\ttfamily litani} builds the entire tree in the background.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md93}{}\doxysubsection{Subtool Reference}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md93}
{\ttfamily litani} consists of three user-\/facing commands\+:


\begin{DoxyItemize}
\item {\ttfamily litani init}---create a new run
\item {\ttfamily litani add-\/job}---add a job to the run
\item {\ttfamily litani run-\/build}---run all jobs in the run in dependency order
\end{DoxyItemize}

You use {\ttfamily litani} by invoking all three of these commands. You firstly initialize a run; add at least one job to the run; and then build the run, which invokes all the jobs in dependency order.

$<$object   type=\char`\"{}image/svg+xml\char`\"{}   data=\char`\"{}litani-\/flow.\+svg\char`\"{}   alt=\char`\"{}\+Flow of using litani\+: first litani init, then one or more invocations of litani add-\/job, and finally litani run-\/build\char`\"{}   id=\char`\"{}litani-\/flow\char`\"{}$>$ Flow of using litani\+: first litani init, then one or more invocations of litani add-\/job, and finally litani run-\/build $<$/object$>$ 

{\ttfamily litani} writes all data associated with the run to a single directory; the directory for each run is unique. {\ttfamily litani}\textquotesingle{}s data format is versioned with \href{https://semver.org/}{\texttt{ semantic versioning}}. {\ttfamily litani -\/-\/version} prints the data format version and exits. The current version is 1.\+0.\+0.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md94}{}\doxysubsubsection{$<$tt$>$litani init$<$/tt$>$}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md94}
{\ttfamily litani \mbox{[}-\/v\mbox{]} init \mbox{[}-\/h\mbox{]} -\/-\/project-\/name NAME}

Create a new run for jobs to be added to. {\ttfamily litani} output from subsequent commands, as well as job artifacts and output files, will be written to a directory associated with this run.

{\ttfamily -\/v, -\/-\/verbose} 

Verbose output. In particular, print the name of the directory to which all output files and artifacts for this run will be written to. 

{\ttfamily -\/-\/project-\/name NAME} 

Associate this run to a \char`\"{}project\char`\"{}. A project is a collection of runs. The name of the project will be included in the JSON output for the run. \hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md95}{}\doxysubsubsection{$<$tt$>$litani add-\/job$<$/tt$>$}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md95}
\begin{DoxyVerb}litani [-v] add-job --command CMD
                    [--inputs F [F ...]]
                    [--outputs F [F ...]]
                    --pipeline-name P --ci-stage S
                    [-h] [--cwd DIR] [--timeout N] [--timeout-ok]
                    [--timeout-ignore] [--ignore-returns RC [RC ...]]
                    [--ok-returns RC [RC ...]]
                    [--interleave-stdout-stderr]
                    [--stdout-file FILE] [--stderr-file FILE]
                    [--description DESC] [--tags TAG [TAG ...]]
\end{DoxyVerb}
 Describe one of the jobs to be run when {\ttfamily litani run-\/build} is invoked. A {\itshape job} is a command that depends on inputs emits outputs. The command is invoked when the jobs that emit each of this job\textquotesingle{}s inputs have successfully executed. Inputs and outputs can be files, but they don\textquotesingle{}t have to be; {\ttfamily litani} doesn\textquotesingle{}t actually check whether the files were written, just whether the job completed successfully.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md96}{}\doxyparagraph{describing the build graph\+:}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md96}
{\ttfamily -\/-\/command CMD} 

The command to run once all dependencies are satisfied. {\ttfamily CMD} is parsed as a single string and invoked using a subshell. 

{\ttfamily -\/-\/inputs F \mbox{[}F ...\mbox{]}} 

List of inputs that this job depends on. 

{\ttfamily -\/-\/outputs F \mbox{[}F ...\mbox{]}} 

List of outputs that this job generates. \hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md97}{}\doxyparagraph{job control\+:}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md97}
{\ttfamily -\/-\/pipeline-\/name P} 

Which pipeline this job is a member of. 

{\ttfamily -\/-\/ci-\/stage \texorpdfstring{$<$}{<}build$\vert$test$\vert$report\texorpdfstring{$>$}{>}} 

Which CI stage this job is a member of. 

{\ttfamily -\/-\/cwd DIR} 

Directory that the command should execute in. 

{\ttfamily -\/-\/timeout N} 

How long the job should be allowed to run for. If the timeout is reached, the command will be terminated and the job will exit unsuccessfully, blocking any dependant jobs from running, unless {\ttfamily -\/-\/timeout-\/ok} or {\ttfamily -\/-\/timeout-\/ignore} are passed. 

{\ttfamily -\/-\/timeout-\/ok} 

If the command times out, it will be terminated, but the job will be considered successful. The pipeline that this job is part of will also be considered successful. 

{\ttfamily -\/-\/timeout-\/ignore} 

If the command times out, it will be terminated, but this will not block dependent jobs from running. Nevertheless, the pipeline that this job is part of will be considered to have failed. This option is useful when you wish to run dependant jobs even after this job has timed out, but still want to indicate an overall failure. 

{\ttfamily -\/-\/ignore-\/returns RC \mbox{[}RC ...\mbox{]}} 

If the exits with one of the specified return codes, it will not block dependent jobs from running. Nevertheless, the pipeline that this job is part of will be considered to have failed. This option is useful when you wish to run dependant jobs even after the command exited with an abnormal status, but still want to indicate an overall failure. For example, you may wish to generate a report as a dependant job; the report must still be generated if this job fails. 

{\ttfamily -\/-\/ok-\/returns RC \mbox{[}RC ...\mbox{]}} 

If the command exits with one of the specified return codes, the job will still be considered successful. 

{\ttfamily -\/-\/interleave-\/stdout-\/stderr} 

Simulate {\ttfamily 2\texorpdfstring{$>$}{>}\&1 \texorpdfstring{$>$}{>}...} 

{\ttfamily -\/-\/stdout-\/file FILE} 

Write the command\textquotesingle{}s stdout to {\ttfamily FILE}. Note that even if this option is not passed, {\ttfamily litani} will not print the command\textquotesingle{}s stdout to the terminal, but will save any output to the JSON file for the run. 

{\ttfamily -\/-\/stderr-\/file FILE} 

Write the command\textquotesingle{}s stderr to {\ttfamily FILE}. Note that even if this option is not passed, {\ttfamily litani} will not print the command\textquotesingle{}s stderr to the terminal, but will save any output to the JSON file for the run. \hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md98}{}\doxyparagraph{misc\+:}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md98}
{\ttfamily -\/-\/description DESC} 

A human-\/readable string to describe the job. This will be printed to terminal when the job is run, and can also be used in reports. {\ttfamily litani} does not interpret the description, but will include it in the JSON report for the run. 

{\ttfamily -\/-\/tags TAG \mbox{[}TAG ...\mbox{]}} 

A list of tags for this job. {\ttfamily litani} does not interpret tags, but will include them all in the JSON report for the run. \hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md99}{}\doxysubsubsection{$<$tt$>$litani run-\/build$<$/tt$>$}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_litani_doc_index_autotoc_md99}
\begin{DoxyVerb}litani run-build [-h] [-n] [-j N] [-o F]
                 [--pipelines P [P ...] |
                  --ci-stage <build|test|report>]
\end{DoxyVerb}
 Create a new run for jobs to be added to. {\ttfamily litani} output from subsequent commands, as well as job artifacts and output files, will be written to a directory associated with this run.

{\ttfamily -\/j N, -\/-\/parallel N} 

Run at most {\ttfamily N} jobs in parallel. 0 means infinity, the default is based on the number of cores on your system. 

{\ttfamily -\/n, -\/-\/dry-\/run} 

Don\textquotesingle{}t actually run the commands in each job, just pretend that they succeeded. 

{\ttfamily -\/o F, -\/-\/out-\/file F} 

Periodically write a JSON file describing the run so far to {\ttfamily F}. {\ttfamily litani} already writes such a file to the run directory created by {\ttfamily litani init}; this flag specifies an additional, more easily-\/accessible file to write to. 

{\ttfamily -\/p P \mbox{[}P ...\mbox{]}, -\/-\/pipelines P \mbox{[}P ...\mbox{]}} 

Only run the jobs that are associated with the pipeline {\ttfamily P}. This allows you to run a subset of the jobs from start to finish. 

{\ttfamily -\/s \texorpdfstring{$<$}{<}build$\vert$test$\vert$report\texorpdfstring{$>$}{>}, -\/-\/ci-\/stage \texorpdfstring{$<$}{<}build$\vert$test$\vert$report\texorpdfstring{$>$}{>}} 

Only run the jobs that are part of the CI stage {\ttfamily S}. This allows you to run all jobs up to and including a particular stage. 