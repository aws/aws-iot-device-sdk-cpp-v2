{\bfseries{Table of Contents}}


\begin{DoxyItemize}
\item \href{\#i-see-12-proof-failures-how-do-i-select-which-one-to-debug}{\texttt{ I see 12 proof failures. How do I select which one to debug?}}
\item \href{\#how-do-i-debug-a-proof-failure}{\texttt{ How do I debug a proof failure?}}
\begin{DoxyItemize}
\item \href{\#read-the-trace}{\texttt{ Read the trace}}
\item \href{\#add-additional-information-to-the-trace}{\texttt{ Add additional information to the trace}}
\item \href{\#delta-debugging}{\texttt{ Delta debugging}}
\item \href{\#add-assertions-to-check-your-hypotheses}{\texttt{ Add assertions to check your hypotheses.}}
\item \href{\#use-assert0-to-dump-program-state-leading-to-a-checkpoint}{\texttt{ Use {\ttfamily assert(0)} to dump program state leading to a checkpoint}}
\item \href{\#use-assume-to-block-uninteresting-paths}{\texttt{ Use {\ttfamily assume(...)} to block uninteresting paths}}
\item \href{\#consider-the-possibility-it-is-a-fault-in-the-code-itself}{\texttt{ Consider the possibility it is a fault in the code itself}}
\end{DoxyItemize}
\item \href{\#how-do-i-improve-proofs-with-low-coverage}{\texttt{ How do I improve proofs with low coverage?}}
\begin{DoxyItemize}
\item \href{\#fix-any-cbmc-errors}{\texttt{ Fix any CBMC errors}}
\item \href{\#check-for-truly-unreachable-code}{\texttt{ Check for truly unreachable code.}}
\item \href{\#check-for-over-constrained-inputs}{\texttt{ Check for over-\/constrained inputs}}
\end{DoxyItemize}
\item \href{\#how-can-i-tell-if-my-proof-is-over-constrained}{\texttt{ How can I tell if my proof is over-\/constrained?}}
\item \href{\#what-should-i-do-if-cbmc-crashes}{\texttt{ What should I do if CBMC crashes?}}
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md130}{}\doxysection{I see 12 proof failures. How do I select which one to debug?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md130}
CBMC proof failures seem to come in batches\+: you run the proof, and see a dozen different errors reported In many cases, these failures are related\+: instead of stressing about the number of failures, pick one, debug it, and see if fixing it removes (many of) the others. Some good heuristics for deciding which failure to investigate\+:


\begin{DoxyEnumerate}
\item {\bfseries{Look for a failure that occurs early on in the proof.}} This will often be the one with the shortest trace \mbox{[}TODO viewer should output this information\mbox{]}. The shorter the trace leading to the issue, the easier it is to debug. ~\newline

\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item {\bfseries{Look for a failure in code you understand.}} Some functions are simpler than others\+: a failure in a simple function is often easier to analyze that one in a complicated function. And a failure in a function you understand is easier than one in a function you are not familiar with.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item {\bfseries{Look for a simple type of failure.}} For example, the trace from a null dereference is often easier to follow than the trace for a use of a DEAD pointer. But they\textquotesingle{}re normally exactly the same bug! Since null dereference bugs normally give the simplest traces, start with them first. Often, resolving the null dereference also fixes the other related bugs.
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md131}{}\doxysection{How do I debug a proof failure?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md131}
There are a number of techniques that have proven useful in debugging proof failures.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md132}{}\doxysubsection{Read the trace}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md132}
\mbox{[}TODO link to a guide to viewer\mbox{]} CBMC viewer generates a step-\/by-\/step trace that leads to the assertion violation. This trace details


\begin{DoxyItemize}
\item Every line of code executed
\item Every function call made
\item Every time a variable is assigned
\end{DoxyItemize}

Essentially, this trace contains everything you would get from attaching a debugger to the program, and single stepping until the violation occurred. Take a look at the values of the relevant variables right before the assertion violation. Do they make sense? If not, figure out where they were assigned. I often find that {\ttfamily Ctrl-\/F} is my friend here\+: I search for either the variable name, or the value it was assigned, and see where it appears in the trace.

Similarly, look at the set of function calls that led to the error. Do they make sense? Are there functions you expect to see there, but don\textquotesingle{}t? Are there functions you didn\textquotesingle{}t expect to see there, but do?\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md133}{}\doxysubsection{Add additional information to the trace}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md133}
The trace has all the information you need to understand the state of program memory at every point during the execution. But its not always that easy to reconstruct. In particular, the trace records the value of a variable when it is written to. But it doesn\textquotesingle{}t record the value of a variable that is only read, or passed along to another function.

You can solve this by adding \char`\"{}dummy writes\char`\"{} to the program. For example, let\textquotesingle{}s say you were debugging an error that involved the following function


\begin{DoxyCode}{0}
\DoxyCodeLine{int foo(struct bar* b, int x) \{}
\DoxyCodeLine{    baz(b-\/>data, x);}
\DoxyCodeLine{\}}

\end{DoxyCode}


Figuring out the value of {\ttfamily b-\/\texorpdfstring{$>$}{>}data} and {\ttfamily x} are possible given a complete trace, but its difficult. Any it might harder to figure out the value of {\ttfamily b-\/\texorpdfstring{$>$}{>}size}. Instead, annotate the code to track those values\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{int foo(struct bar* b, int x) \{}
\DoxyCodeLine{    struct bar debug\_foo\_b = *b;}
\DoxyCodeLine{    int debug\_foo\_x = x;}
\DoxyCodeLine{    baz(b-\/>data, x);}
\DoxyCodeLine{\}}

\end{DoxyCode}


the trace will now contain an assignment to {\ttfamily debug\+\_\+foo\+\_\+b}, which will let you see what values each member of the struct had.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md134}{}\doxysubsection{Delta debugging}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md134}
\href{http://web2.cs.columbia.edu/~junfeng/09fa-e6998/papers/delta-debug.pdf}{\texttt{ Delta debugging}} is a powerful technique for localizing faults and creating minimal reproducing test-\/cases. Essentially, you modify the program in some way, typically either by removing (commenting out) or modifying code. You then rerun the verification tool, and see if the results changed. The goal is to either\+:


\begin{DoxyEnumerate}
\item produce a small program which still displays the bug or
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item produce a small change between two programs, one of which has the bug, and the other doesn\textquotesingle{}t.
\end{DoxyEnumerate}

In case 1, you now have a small program which is hopefully easy to understand; In case 2, you have a small change which induces the bug, and hopefully leads you toward the root cause.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md135}{}\doxysubsection{Add assertions to check your hypotheses.}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md135}
For example, consider the case of a null pointer dereference of a pointer {\ttfamily p}. It is important to distinguish the case where the pointer {\itshape must} be null, vs the case where it {\itshape may} be null, vs the case where it {\itshape is never} null. You can test for these cases by adding {\ttfamily assert(p)} to the function. If the can be null, the assertion will trigger. If it cannot be null, the assertion will succeed.

Now, check {\ttfamily assert(!p)} instead. If can be non-\/null, this assertion will fail. If it can only be null, this assertion will succeed.

You now know which one of the three cases is true. And you can use the trace to see why it can be null/non-\/null.

You can do similar things to determine why a branch is reachable, or unreachable.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md136}{}\doxysubsection{Use $<$tt$>$assert(0)$<$/tt$>$ to dump program state leading to a checkpoint}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md136}
Sometimes, you want to know how/whether a particular line of code is reachable. One easy way to learn that is to put {\ttfamily assert(0)} right before the line. CBMC will detect the assertion violation, and give a trace explaining how it reached there, and with what values. If the assertion passes without error, you know that the line is unreachable given the current proof harness.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md137}{}\doxysubsection{Use $<$tt$>$assume(...)$<$/tt$>$ to block uninteresting paths}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md137}
There are often many possible execution paths that reach a given line of code / assertion. Some of these may reflect cases you are trying to understand, while others do not help with your current debugging plan. Left to its own devices, CBMC will non-\/deterministically choose one of those traces, which may not be the one you want. You can guide CBMC to the trace you want by sprinkling {\ttfamily \+\_\+\+\_\+\+CPROVER\+\_\+assume()} statements within the code. For example, you might {\ttfamily \+\_\+\+\_\+\+CPROVER\+\_\+assume()} that a function fails with an error code, to test whether the calling function handles that error code correctly. Or you might {\ttfamily \+\_\+\+\_\+\+CPROVER\+\_\+assume()} that a given variable is null, to simplify you search for the root cause of a null dereference.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md138}{}\doxysubsection{Consider the possibility it is a fault in the code itself}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md138}
In many cases, the error detected by CBMC represents a true issue within the code itself. This is particularly common in the case of functions which fail to validate their inputs. In this case, the fix is either to validate the inputs, and return an error if given invalid inputs, or to document the requirements on the inputs, and state that actions on illegal inputs are undefined behaviour. Which solution you choose depends on the risk profile of the code.

It is also common that code being verified has integer-\/overflows and other errors that only occur in unusual circumstances. In these cases, the solution is to either guarantee that inputs are sufficiently small to prevent these issues, or to use overflow-\/safe builtins, such as gcc\textquotesingle{}s {\ttfamily \+\_\+\+\_\+builtin\+\_\+mul\+\_\+overflow} (documented \href{https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html}{\texttt{ here}}).\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md139}{}\doxysection{How do I improve proofs with low coverage?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md139}
\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md140}{}\doxysubsection{Fix any CBMC errors}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md140}
Make sure that there are no missing function definitions, or property violations. Both of these errors can affect coverage calculations.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md141}{}\doxysubsection{Check for truly unreachable code.}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md141}
In some cases, code may be truly unreachable -\/ for example, redundant defensive checks. Or this may be code which is sometimes reachable, but not in the context of your proof. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{int size\_from\_enum(type\_enum t) \{}
\DoxyCodeLine{    switch (t) \{}
\DoxyCodeLine{    case BAR: return 1;}
\DoxyCodeLine{    case BAZ: return 2;}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\}}
\DoxyCodeLine{   }
\DoxyCodeLine{int function\_being\_tested() \{}
\DoxyCodeLine{    return size\_from\_enum(BAZ);}
\DoxyCodeLine{\}}

\end{DoxyCode}


In this case, most of the lines in {\ttfamily size\+\_\+from\+\_\+enum} will appear to be unreachable, even though the proof has full coverage of all truly reachable paths.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md142}{}\doxysubsection{Check for over-\/constrained inputs}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md142}
Consider the case where one side of a branch is not reached, or where execution does not continue past an assumption. In this case, it is possible that the inputs have been over-\/constrained\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md143}{}\doxysection{How can I tell if my proof is over-\/constrained?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md143}
This will normally appear in coverage -\/ overconstrained proofs will normally have unreachable portions of code. You can also add a \char`\"{}smoke test\char`\"{}, but adding assertions that you expect to fail to the code (which can be as simple as {\ttfamily assert(0)}). If these assertions do not fail, then sometime is wrong with your proof.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md144}{}\doxysection{What should I do if CBMC crashes?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__d_e_b_u_g__c_b_m_c_autotoc_md144}

\begin{DoxyEnumerate}
\item Make a new branch, containing the exact code that caused cbmc to crash. We recommend giving it a name like {\ttfamily cbmc-\/crashing-\/bug-\/1}.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Push it to public github repo (if possible)
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Post a bug report \href{https://github.com/diffblue/cbmc/issues/new}{\texttt{ here}}, linking to the branch that you pushed containing the bug.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Post a bug report on this repo, linking to the bug that you posted on the main CBMC repo. 
\end{DoxyEnumerate}