\hypertarget{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md310}{}\doxysubsubsection{Design}\label{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md310}

\begin{DoxyItemize}
\item How does Code\+Build decide what to install/test ? Historically the environment variables passed to the job dictate what is installed and which tests get run. Code\+Build has a pattern where environment variables can be over-\/ridden by Cloud\+Watch events or batch jobs, so in some cases the Code\+Build job definition is generic or filled with placeholders (e.\+g. s2n\+Fuzz\+Scheduled).
\item Why not build docker images with the dependencies layered in ? This is the end goal\+: get tests running in Code\+Build first, then optimize the containers where it makes sense.
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md311}{}\doxysubsubsection{Dep tree}\label{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md311}
General flow of the Code\+Build Test Projects


\begin{DoxyItemize}
\item buildspec\+\_\+\{OS\}.yml
\begin{DoxyItemize}
\item codebuild/install\+\_\+default\+\_\+dependencies.\+sh
\begin{DoxyItemize}
\item codebuild/install\+\_\+clang.\+sh
\item codebuild/install\+\_\+lib\+Fuzzer.\+sh
\item codebuild/install\+\_\+openssl\+\_\+1\+\_\+1\+\_\+1.\+sh
\item codebuild/install\+\_\+openssl\+\_\+1\+\_\+0\+\_\+2.\+sh
\item codebuild/install\+\_\+openssl\+\_\+1\+\_\+0\+\_\+2\+\_\+fips.\+sh
\item codebuild/install\+\_\+libressl.\+sh
\item codebuild/install\+\_\+python.\+sh
\item codebuild/install\+\_\+gnutls.\+sh
\item codebuild/install\+\_\+saw.\+sh
\item codebuild/install\+\_\+z3\+\_\+yices.\+sh
\item codebuild/install\+\_\+sslyze.\+sh
\end{DoxyItemize}
\item codebuild/s2n\+\_\+codebuild.\+sh
\begin{DoxyItemize}
\item codebuild/s2n\+\_\+override\+\_\+paths.\+sh
\item codebuild/copyright\+\_\+mistake\+\_\+scanner.\+sh
\item codebuild/run\+\_\+kwstyle.\+sh
\item codebuild/cpp\+\_\+style\+\_\+comment\+\_\+linter.\+sh
\item codebuild/run\+\_\+ctverif.\+sh
\item codebuild/run\+\_\+sidetrail.\+sh
\item codebuild/grep\+\_\+simple\+\_\+mistakes.\+sh
\end{DoxyItemize}
\item codebuild/s2n\+\_\+after\+\_\+codebuild.\+sh
\begin{DoxyItemize}
\item curl -\/s \href{https://codecov.io/bash}{\texttt{ https\+://codecov.\+io/bash}}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md312}{}\doxysubsection{Usage to setup Projects}\label{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md312}
Using your favorite virtualenv, install the following dependencies\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{pip install -\/r requirements.txt}

\end{DoxyCode}


To bootstrap the Code\+Build jobs, the python script\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\# Verify your config is correct}
\DoxyCodeLine{./create\_project.py -\/-\/config the-\/config-\/file.config}
\DoxyCodeLine{}
\DoxyCodeLine{\# If this is a new stack, commit the changes}
\DoxyCodeLine{./create\_project.py -\/-\/config the-\/config-\/file.config -\/-\/production}
\DoxyCodeLine{}
\DoxyCodeLine{\# If the stack already exists, then use a change set for the existing stack}
\DoxyCodeLine{./create\_project.py -\/-\/config the-\/config-\/file.config -\/-\/production -\/-\/modify-\/existing}

\end{DoxyCode}


If you are modifying an existing stack then a list of changes will be displayed and you have the option to accept or reject that change set.


\begin{DoxyCode}{0}
\DoxyCodeLine{ubuntu:codebuild/ \$ ./create\_project.py -\/-\/config codebuild-\/integv2.config -\/-\/production -\/-\/modify-\/existing}
\DoxyCodeLine{INFO:root:Wrote cfn yaml file to cfn/s2n\_codebuild\_projects.yml}
\DoxyCodeLine{INFO:botocore.credentials:Found credentials in environment variables.}
\DoxyCodeLine{INFO:root:CloudFormation template validation complete.}
\DoxyCodeLine{INFO:root:Waiting for change set A2d385d4f0fcd217fff42e8a0cf3d51bd34a542e916524018b13176413410c2ab}
\DoxyCodeLine{INFO:root:Summary of changes:}
\DoxyCodeLine{    Action                   Modify}
\DoxyCodeLine{    LogicalResourceId    s2nIntegrationV2OpenSSL111Gcc9Role}
\DoxyCodeLine{    PhysicalResourceId   integv2s2nCodeBuildTests-\/s2nIntegrationV2OpenSSL11-\/161F84G7NJWVC}
\DoxyCodeLine{    ResourceType         AWS::IAM::Role}
\DoxyCodeLine{    Replacement               False}
\DoxyCodeLine{    Scope                ['Properties']}
\DoxyCodeLine{    Details              [\{'Target': \{'Attribute': 'Properties', 'Name': 'Policies', 'RequiresRecreation': 'Never'\}, 'Evaluation': 'Static', 'ChangeSource': 'DirectModification'\}]}
\DoxyCodeLine{}
\DoxyCodeLine{Do these changes make sense? [Y/n]Y}
\DoxyCodeLine{INFO:root:Executing A2d385d4f0fcd217fff42e8a0cf3d51bd34a542e916524018b13176413410c2ab}
\DoxyCodeLine{INFO:root:Update completed}

\end{DoxyCode}



\begin{DoxyItemize}
\item Use Cloud\+Formation to create the stack with the generated template.
\item Open the Code\+Build projects in the console and setup the Source correctly, using your OTP credentials to connect to Github
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md313}{}\doxysubsection{Words about Code\+Build instance size and concurrency}\label{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md313}
The \href{https://docs.aws.amazon.com/codebuild/latest/userguide/limits.html}{\texttt{ AWS Codebuild}} docs list the number of concurrent jobs at 60. With extensive testing, we\textquotesingle{}ve learned this number appears to be weighted based on \href{https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html}{\texttt{ instance size}} (or provisioning limits), so running all tests on the largest possible instances will reduce actual concurrency. Additionally provisioning time is currently longer for larger instances, so there is a time penalty that might not be recovered by using a larger instance for short lived tests.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md314}{}\doxysubsection{Batch Builds}\label{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md314}
The {\ttfamily spec/buildspec\+\_\+omnibus\+\_\+batch.\+yml} contains a complete list of all Code\+Build jobs. In the future, this will replace the individual jobs created by the \mbox{\hyperlink{create__project_8py}{create\+\_\+project.\+py}} script.

The broken out batch jobs\+: fuzz, integration and general, are created with the script create\+\_\+batch.\+sh, which uses jq to parse out the jobs by title.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md315}{}\doxysubsection{Notes on moving from Travis-\/ci}\label{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md315}

\begin{DoxyItemize}
\item Install\+\_\+clang from Travis is using google chromium clang commit from 2017-\/ which requires python2.\+7 (EOL); updated for Code\+Build.
\item Code\+Build\textquotesingle{}s environment is more restrictive than Travis-\/ these jobs require elevated privilege to function.
\item Warning message from the fuzzer about test speed appear in Code\+Build output, but not in Travis-\/\+CI with the same test (See comments on AWS forums about a difference in ANSI TERM support); this also affects colorized output.
\item mac\+OS/\+OSX platform files were not copied because Code\+Build does not support mac\+OS builds.
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md316}{}\doxysubsection{Querying Code\+Build projects}\label{md_crt_aws_crt_cpp_crt_s2n_codebuild__r_e_a_d_m_e_autotoc_md316}
Here is a sample of how to double check the size of the build hosts, as an example. AWS\+\_\+\+ACCESS\+\_\+\+KEY\+\_\+\+ID and AWS\+\_\+\+SECRET\+\_\+\+ACCESS\+\_\+\+KEY for an associated AWS account will need to be set for this to work, as well as a file called jobs, listing the names of all the Code\+Build jobs you\textquotesingle{}d like to check.


\begin{DoxyCode}{0}
\DoxyCodeLine{for i in \$(cat jobs); do echo -\/e "{}\$i\(\backslash\)t"{};aws codebuild batch-\/get-\/projects -\/-\/name "{}\$i"{} |jq '.projects[].environment.computeType'; done}

\end{DoxyCode}
 