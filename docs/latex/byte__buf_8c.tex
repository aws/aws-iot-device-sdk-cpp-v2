\hypertarget{byte__buf_8c}{}\doxysection{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/source/byte\+\_\+buf.c File Reference}
\label{byte__buf_8c}\index{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/source/byte\_buf.c@{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/source/byte\_buf.c}}
{\ttfamily \#include $<$aws/common/byte\+\_\+buf.\+h$>$}\newline
{\ttfamily \#include $<$aws/common/private/byte\+\_\+buf.\+h$>$}\newline
{\ttfamily \#include $<$stdarg.\+h$>$}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{byte__buf_8c_adf8ed14982cd1aa9e83c924ebb5856ae}{aws\+\_\+byte\+\_\+buf\+\_\+init}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, size\+\_\+t capacity)
\item 
int \mbox{\hyperlink{byte__buf_8c_afcaa669dd210b0cf9820deca75c9a686}{aws\+\_\+byte\+\_\+buf\+\_\+init\+\_\+copy}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$dest, struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$src)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a07926449452596f7b4750430607a9277}{aws\+\_\+byte\+\_\+buf\+\_\+is\+\_\+valid}} (const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a6a58a8d6758717dcdbf2ed031d44d68c}{aws\+\_\+byte\+\_\+cursor\+\_\+is\+\_\+valid}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cursor)
\item 
void \mbox{\hyperlink{byte__buf_8c_aba38e9db5164e21174386de288aa1c7d}{aws\+\_\+byte\+\_\+buf\+\_\+reset}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, bool zero\+\_\+contents)
\item 
void \mbox{\hyperlink{byte__buf_8c_acbddfbd5ccda972a6630cd841fec7b21}{aws\+\_\+byte\+\_\+buf\+\_\+clean\+\_\+up}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}})
\item 
void \mbox{\hyperlink{byte__buf_8c_ac1d0a2e070ce4e156bc636c9873eb4ad}{aws\+\_\+byte\+\_\+buf\+\_\+secure\+\_\+zero}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}})
\item 
void \mbox{\hyperlink{byte__buf_8c_a9f4e4659a9a46d1014b10424a87b8286}{aws\+\_\+byte\+\_\+buf\+\_\+clean\+\_\+up\+\_\+secure}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a2246da0ca31f44fc92d4ebc9fa16cb45}{aws\+\_\+byte\+\_\+buf\+\_\+eq}} (const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const a, const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a23180f5c686096e7f2902e147635aeb1}{aws\+\_\+byte\+\_\+buf\+\_\+eq\+\_\+ignore\+\_\+case}} (const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const a, const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_ab9d84517a8dd0c4ab2b3b17c108814c4}{aws\+\_\+byte\+\_\+buf\+\_\+eq\+\_\+c\+\_\+str}} (const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, const char $\ast$const c\+\_\+str)
\item 
bool \mbox{\hyperlink{byte__buf_8c_af2e8f1e9a122054ada8a3e867aa9a6f8}{aws\+\_\+byte\+\_\+buf\+\_\+eq\+\_\+c\+\_\+str\+\_\+ignore\+\_\+case}} (const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, const char $\ast$const c\+\_\+str)
\item 
int \mbox{\hyperlink{byte__buf_8c_add0e7102270fffc97b9d7da4d0a38bd7}{aws\+\_\+byte\+\_\+buf\+\_\+init\+\_\+copy\+\_\+from\+\_\+cursor}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$dest, struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} src)
\item 
int \mbox{\hyperlink{byte__buf_8c_aac5490e5293c67b8f0a82342ea81c917}{aws\+\_\+byte\+\_\+buf\+\_\+init\+\_\+cache\+\_\+and\+\_\+update\+\_\+cursors}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$dest, struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator,...)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a8500b18cf261cffbd69dec5f4dd698c1}{aws\+\_\+byte\+\_\+cursor\+\_\+next\+\_\+split}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} input\+\_\+str, char split\+\_\+on, struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} substr)
\item 
int \mbox{\hyperlink{byte__buf_8c_a49db4870532ddfadf616887d3fb2fed5}{aws\+\_\+byte\+\_\+cursor\+\_\+split\+\_\+on\+\_\+char\+\_\+n}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} input\+\_\+str, char split\+\_\+on, size\+\_\+t n, struct \mbox{\hyperlink{structaws__array__list}{aws\+\_\+array\+\_\+list}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} output)
\item 
int \mbox{\hyperlink{byte__buf_8c_ac6ebbd786227e59a3aba25b8abe43d6e}{aws\+\_\+byte\+\_\+cursor\+\_\+split\+\_\+on\+\_\+char}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} input\+\_\+str, char split\+\_\+on, struct \mbox{\hyperlink{structaws__array__list}{aws\+\_\+array\+\_\+list}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} output)
\item 
int \mbox{\hyperlink{byte__buf_8c_a8034dfb48cf116946a092436e409bf9a}{aws\+\_\+byte\+\_\+cursor\+\_\+find\+\_\+exact}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} input\+\_\+str, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} to\+\_\+find, struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$first\+\_\+find)
\item 
int \mbox{\hyperlink{byte__buf_8c_a6ed7bf940089a3adfb6e44ab70203156}{aws\+\_\+byte\+\_\+buf\+\_\+cat}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$dest, size\+\_\+t number\+\_\+of\+\_\+args,...)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a6ac432a626706052a527c1349fb8cbd4}{aws\+\_\+byte\+\_\+cursor\+\_\+eq}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$a, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a509e25ff72150c5f4f4a40e48432c402}{aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+ignore\+\_\+case}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$a, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
\mbox{\hyperlink{byte__buf_8c_af9e2f9f9e603d6d21aceba0cccb77bb9}{AWS\+\_\+\+STATIC\+\_\+\+ASSERT}} (\mbox{\hyperlink{macros_8h_a7b837cfd09e209fa32b1129f8bc9c431}{AWS\+\_\+\+ARRAY\+\_\+\+SIZE}}(\mbox{\hyperlink{byte__buf_8c_a44397e404df152393bd3201025f462ef}{s\+\_\+tolower\+\_\+table}})==256)
\item 
const uint8\+\_\+t $\ast$ \mbox{\hyperlink{byte__buf_8c_af1fe4a204cae799ed595d635d9979590}{aws\+\_\+lookup\+\_\+table\+\_\+to\+\_\+lower\+\_\+get}} (void)
\item 
bool \mbox{\hyperlink{byte__buf_8c_ad7140a0d5f0196940bcf1d62f4679f33}{aws\+\_\+array\+\_\+eq\+\_\+ignore\+\_\+case}} (const void $\ast$const array\+\_\+a, const size\+\_\+t len\+\_\+a, const void $\ast$const array\+\_\+b, const size\+\_\+t len\+\_\+b)
\item 
bool \mbox{\hyperlink{byte__buf_8c_aa60206f73448db770f5f66a54cf72b5a}{aws\+\_\+array\+\_\+eq}} (const void $\ast$const array\+\_\+a, const size\+\_\+t len\+\_\+a, const void $\ast$const array\+\_\+b, const size\+\_\+t len\+\_\+b)
\item 
bool \mbox{\hyperlink{byte__buf_8c_ab764fa5e408f601deef8f78aa969a92c}{aws\+\_\+array\+\_\+eq\+\_\+c\+\_\+str\+\_\+ignore\+\_\+case}} (const void $\ast$const array, const size\+\_\+t array\+\_\+len, const char $\ast$const c\+\_\+str)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a173ae70dc07148c93669d9bf695ab9bd}{aws\+\_\+array\+\_\+eq\+\_\+c\+\_\+str}} (const void $\ast$const array, const size\+\_\+t array\+\_\+len, const char $\ast$const c\+\_\+str)
\item 
uint64\+\_\+t \mbox{\hyperlink{byte__buf_8c_ab2b52ce0371e324b33ec2006fe3207fa}{aws\+\_\+hash\+\_\+array\+\_\+ignore\+\_\+case}} (const void $\ast$array, const size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a0f1e4ab31fd4f3ca4329091911f1f1af}{len}})
\item 
uint64\+\_\+t \mbox{\hyperlink{byte__buf_8c_a2bb583d1f274a5863b152cee4749bcc9}{aws\+\_\+hash\+\_\+byte\+\_\+cursor\+\_\+ptr\+\_\+ignore\+\_\+case}} (const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_ac011de571ff16ba220d2e0d757e4e8b0}{item}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a31a7dc00c06d8a4abe69a9680934336a}{aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+byte\+\_\+buf}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const a, const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a6952e4ba3307e2a05d5edadc0d92cee0}{aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+byte\+\_\+buf\+\_\+ignore\+\_\+case}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const a, const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a410ca19b956f672343dfa71c2f534abe}{aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+c\+\_\+str}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const cursor, const char $\ast$const c\+\_\+str)
\item 
bool \mbox{\hyperlink{byte__buf_8c_afbd816b132e73605793c8a7b848997b1}{aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+c\+\_\+str\+\_\+ignore\+\_\+case}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const cursor, const char $\ast$const c\+\_\+str)
\item 
int \mbox{\hyperlink{byte__buf_8c_acd3ab456a1b70a558da8e18e2724a948}{aws\+\_\+byte\+\_\+buf\+\_\+append}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$to, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$from)
\item 
int \mbox{\hyperlink{byte__buf_8c_a448b75fae26a0e95e178ac9629482e6f}{aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+with\+\_\+lookup}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} to, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} from, const uint8\+\_\+t $\ast$lookup\+\_\+table)
\item 
static int \mbox{\hyperlink{byte__buf_8c_aec56ee1008054c5a0aee809cc324e330}{s\+\_\+aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+dynamic}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$to, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$from, bool clear\+\_\+released\+\_\+memory)
\item 
int \mbox{\hyperlink{byte__buf_8c_ab4a34b2d690f402d6f1eb78da880d43d}{aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+dynamic}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$to, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$from)
\item 
int \mbox{\hyperlink{byte__buf_8c_a208d9f01f769fbc2440aa7d98019e639}{aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+dynamic\+\_\+secure}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$to, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$from)
\item 
static int \mbox{\hyperlink{byte__buf_8c_a8af92432cfe7cc34703f62e15cc3283b}{s\+\_\+aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+byte\+\_\+dynamic}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$buffer, uint8\+\_\+t value, bool clear\+\_\+released\+\_\+memory)
\item 
int \mbox{\hyperlink{byte__buf_8c_a7ba06d49ab6e673130c3205c666e37c9}{aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+byte\+\_\+dynamic}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$buffer, uint8\+\_\+t value)
\item 
int \mbox{\hyperlink{byte__buf_8c_a64062c246870c740b40a7b847f75bad3}{aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+byte\+\_\+dynamic\+\_\+secure}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$buffer, uint8\+\_\+t value)
\item 
int \mbox{\hyperlink{byte__buf_8c_af900ec5d14c51db19a58383ecdaecbe3}{aws\+\_\+byte\+\_\+buf\+\_\+reserve}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$buffer, size\+\_\+t requested\+\_\+capacity)
\item 
int \mbox{\hyperlink{byte__buf_8c_a73cb440263d7afb68ae6a88ca92d98cf}{aws\+\_\+byte\+\_\+buf\+\_\+reserve\+\_\+relative}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$buffer, size\+\_\+t additional\+\_\+length)
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_a701ea769d956a8b45bb3bf3108e9ba60}{aws\+\_\+byte\+\_\+cursor\+\_\+right\+\_\+trim\+\_\+pred}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$source, \mbox{\hyperlink{byte__buf_8h_ace0fa67cb735decc07988bf215701e22}{aws\+\_\+byte\+\_\+predicate\+\_\+fn}} $\ast$predicate)
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_af052c1f50ed8119107b216d1623526ce}{aws\+\_\+byte\+\_\+cursor\+\_\+left\+\_\+trim\+\_\+pred}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$source, \mbox{\hyperlink{byte__buf_8h_ace0fa67cb735decc07988bf215701e22}{aws\+\_\+byte\+\_\+predicate\+\_\+fn}} $\ast$predicate)
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_a14a6efa66bf2efa66dd764c5b120129a}{aws\+\_\+byte\+\_\+cursor\+\_\+trim\+\_\+pred}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$source, \mbox{\hyperlink{byte__buf_8h_ace0fa67cb735decc07988bf215701e22}{aws\+\_\+byte\+\_\+predicate\+\_\+fn}} $\ast$predicate)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a0582daf1e0324e84c2eeddadbae49b76}{aws\+\_\+byte\+\_\+cursor\+\_\+satisfies\+\_\+pred}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$source, \mbox{\hyperlink{byte__buf_8h_ace0fa67cb735decc07988bf215701e22}{aws\+\_\+byte\+\_\+predicate\+\_\+fn}} $\ast$predicate)
\item 
int \mbox{\hyperlink{byte__buf_8c_a36c04f9cc728fb734ef9bc26432d177a}{aws\+\_\+byte\+\_\+cursor\+\_\+compare\+\_\+lexical}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$lhs, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$rhs)
\item 
int \mbox{\hyperlink{byte__buf_8c_abcf26003c9712b9d16e334aaef9888d1}{aws\+\_\+byte\+\_\+cursor\+\_\+compare\+\_\+lookup}} (const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$lhs, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$rhs, const uint8\+\_\+t $\ast$lookup\+\_\+table)
\item 
struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} \mbox{\hyperlink{byte__buf_8c_a2a9635250be1b7cc705444b15a4ee959}{aws\+\_\+byte\+\_\+buf\+\_\+from\+\_\+c\+\_\+str}} (const char $\ast$c\+\_\+str)
\item 
struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} \mbox{\hyperlink{byte__buf_8c_a20059771adc23906f5e01f881ed4e14a}{aws\+\_\+byte\+\_\+buf\+\_\+from\+\_\+array}} (const void $\ast$bytes, size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a0f1e4ab31fd4f3ca4329091911f1f1af}{len}})
\item 
struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} \mbox{\hyperlink{byte__buf_8c_aa1e35c2ba3ed311c07ea04d6afdcc5e9}{aws\+\_\+byte\+\_\+buf\+\_\+from\+\_\+empty\+\_\+array}} (const void $\ast$bytes, size\+\_\+t capacity)
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_ad880888d05132a33f4301d706a39abe2}{aws\+\_\+byte\+\_\+cursor\+\_\+from\+\_\+buf}} (const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}})
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_a1eb17ec562f4309e8d00717c9a6b9091}{aws\+\_\+byte\+\_\+cursor\+\_\+from\+\_\+c\+\_\+str}} (const char $\ast$c\+\_\+str)
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_a3af2b9b3bd6c53ad69de9f506590edf0}{aws\+\_\+byte\+\_\+cursor\+\_\+from\+\_\+array}} (const void $\ast$const bytes, const size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a0f1e4ab31fd4f3ca4329091911f1f1af}{len}})
\item 
size\+\_\+t \mbox{\hyperlink{byte__buf_8c_a877b6197e84a8a1671549cda787236d7}{aws\+\_\+nospec\+\_\+mask}} (size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a750b5d744c39a06bfb13e6eb010e35d0}{index}}, size\+\_\+t bound)
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_a71e79909e24bdfce3bb0e3331886dcd3}{aws\+\_\+byte\+\_\+cursor\+\_\+advance}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const cursor, const size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a0f1e4ab31fd4f3ca4329091911f1f1af}{len}})
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_a6b3528b29474a2962bf2c4c231e6abea}{aws\+\_\+byte\+\_\+cursor\+\_\+advance\+\_\+nospec}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const cursor, size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a0f1e4ab31fd4f3ca4329091911f1f1af}{len}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a667d2681ddc208ee6c9145d93366c41d}{aws\+\_\+byte\+\_\+cursor\+\_\+read}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} cur, void $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} dest, const size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a0f1e4ab31fd4f3ca4329091911f1f1af}{len}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_af16de03a2ca7561f966a77e8c22e1877}{aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+and\+\_\+fill\+\_\+buffer}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} cur, struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} dest)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a571e1fa5c7a551535358f724dd40c7cb}{aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+u8}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} cur, uint8\+\_\+t $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} var)
\item 
bool \mbox{\hyperlink{byte__buf_8c_aa8053828c7196b06a93ae486a5e996c7}{aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+be16}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cur, uint16\+\_\+t $\ast$var)
\item 
bool \mbox{\hyperlink{byte__buf_8c_afeaca6f258268874e503eb1672eff64b}{aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+be24}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cur, uint32\+\_\+t $\ast$var)
\item 
bool \mbox{\hyperlink{byte__buf_8c_aa1da6b78bf530fdc1536abd48e4ef084}{aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+be32}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cur, uint32\+\_\+t $\ast$var)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a33db95c91d74113e776e269b29b75d24}{aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+float\+\_\+be32}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cur, float $\ast$var)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a08b8d2d5abfa40c7d5da0d87889bb50c}{aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+float\+\_\+be64}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cur, double $\ast$var)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a60ebd0319d386143460aebd349870761}{aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+be64}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cur, uint64\+\_\+t $\ast$var)
\item 
\mbox{\hyperlink{byte__buf_8c_af7741579301dfe24b74938c1e34f0729}{AWS\+\_\+\+STATIC\+\_\+\+ASSERT}} (\mbox{\hyperlink{macros_8h_a7b837cfd09e209fa32b1129f8bc9c431}{AWS\+\_\+\+ARRAY\+\_\+\+SIZE}}(\mbox{\hyperlink{byte__buf_8c_a153765cf45f5be0abaeb4b946bb3e816}{s\+\_\+hex\+\_\+to\+\_\+num\+\_\+table}})==256)
\item 
const uint8\+\_\+t $\ast$ \mbox{\hyperlink{byte__buf_8c_ad2393c6ee6236ff1b1adc0bfc9424257}{aws\+\_\+lookup\+\_\+table\+\_\+hex\+\_\+to\+\_\+num\+\_\+get}} (void)
\item 
bool \mbox{\hyperlink{byte__buf_8c_aba4686c6333f36ab47caa3032c4f5cd0}{aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+hex\+\_\+u8}} (struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cur, uint8\+\_\+t $\ast$var)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a69f9a5b942f8bd53e13037e65cd88d87}{aws\+\_\+byte\+\_\+buf\+\_\+advance}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} buffer, struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} output, const size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a0f1e4ab31fd4f3ca4329091911f1f1af}{len}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_ad5eb15960520d84856f48e4cfe44e41c}{aws\+\_\+byte\+\_\+buf\+\_\+write}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, const uint8\+\_\+t $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} src, size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a0f1e4ab31fd4f3ca4329091911f1f1af}{len}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a9ee727a2ce9e82fe553908fe7fa69799}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+from\+\_\+whole\+\_\+buffer}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} src)
\item 
bool \mbox{\hyperlink{byte__buf_8c_ae96b20ca3aa078b8c4437be04d9eb673}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+from\+\_\+whole\+\_\+cursor}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} src)
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_a85b9ae8e8822d3a05daf3fc5eb513aef}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+to\+\_\+capacity}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$advancing\+\_\+cursor)
\item 
bool \mbox{\hyperlink{byte__buf_8c_ad4f47337cb3ec100c5473ab188c3eb05}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+u8}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, uint8\+\_\+t c)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a21ddba7196eb554b19184ab12129fb4b}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+u8\+\_\+n}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, uint8\+\_\+t c, size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_ad43c3812e6d13e0518d9f8b8f463ffcf}{count}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_a91870598496fcac2bf5d77ad6a998b7e}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+be16}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, uint16\+\_\+t x)
\item 
bool \mbox{\hyperlink{byte__buf_8c_abf380cf62e596ce34aaceabcf7996d9c}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+be24}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, uint32\+\_\+t x)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a81fd5bb13722894ccbfb6a39ed03e660}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+be32}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, uint32\+\_\+t x)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a40b9731ae303c500db1ca2420bf4f622}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+float\+\_\+be32}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, float x)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a7f5ea0bdff141303034776d462a902e0}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+be64}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, uint64\+\_\+t x)
\item 
bool \mbox{\hyperlink{byte__buf_8c_afac0cfa18673d619707634bcbd7c460e}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+float\+\_\+be64}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, double x)
\item 
int \mbox{\hyperlink{byte__buf_8c_a42ca07fbf29e7b255dadc32d72fccc1b}{aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+and\+\_\+update}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$to, struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$from\+\_\+and\+\_\+update)
\item 
int \mbox{\hyperlink{byte__buf_8c_ab8f3b8863e45d8b2c415567d865a7c74}{aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+null\+\_\+terminator}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}})
\item 
bool \mbox{\hyperlink{byte__buf_8c_ad0f48987b0892ebe2e376a6547ef6fa0}{aws\+\_\+isalnum}} (uint8\+\_\+t ch)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a3aa4205568acb1986c0bf61a1795c7ac}{aws\+\_\+isalpha}} (uint8\+\_\+t ch)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a193948a51fc6548d8de1bc5da56ea9c0}{aws\+\_\+isdigit}} (uint8\+\_\+t ch)
\item 
bool \mbox{\hyperlink{byte__buf_8c_a35764ea0c22877bb13898dbf1b930c98}{aws\+\_\+isxdigit}} (uint8\+\_\+t ch)
\item 
bool \mbox{\hyperlink{byte__buf_8c_ab7f620e2ee444abb2b32ce93be3085d4}{aws\+\_\+isspace}} (uint8\+\_\+t ch)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static const uint8\+\_\+t \mbox{\hyperlink{byte__buf_8c_a44397e404df152393bd3201025f462ef}{s\+\_\+tolower\+\_\+table}} \mbox{[}$\,$\mbox{]}
\item 
static const uint8\+\_\+t \mbox{\hyperlink{byte__buf_8c_a153765cf45f5be0abaeb4b946bb3e816}{s\+\_\+hex\+\_\+to\+\_\+num\+\_\+table}} \mbox{[}$\,$\mbox{]}
\item 
static struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{byte__buf_8c_acdf3d480fa71f545a92518909855bab2}{s\+\_\+null\+\_\+terminator\+\_\+cursor}} = \mbox{\hyperlink{byte__buf_8h_a25bb15426b081484f79b35669fc81b90}{AWS\+\_\+\+BYTE\+\_\+\+CUR\+\_\+\+INIT\+\_\+\+FROM\+\_\+\+STRING\+\_\+\+LITERAL}}(\char`\"{}\textbackslash{}0\char`\"{})
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{byte__buf_8c_aa60206f73448db770f5f66a54cf72b5a}\label{byte__buf_8c_aa60206f73448db770f5f66a54cf72b5a}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_array\_eq@{aws\_array\_eq}}
\index{aws\_array\_eq@{aws\_array\_eq}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_array\_eq()}{aws\_array\_eq()}}
{\footnotesize\ttfamily bool aws\+\_\+array\+\_\+eq (\begin{DoxyParamCaption}\item[{const void $\ast$const}]{array\+\_\+a,  }\item[{const size\+\_\+t}]{len\+\_\+a,  }\item[{const void $\ast$}]{array\+\_\+b,  }\item[{const size\+\_\+t}]{len\+\_\+b }\end{DoxyParamCaption})}

Compare two arrays. Return whether their contents are equivalent. NULL may be passed as the array pointer if its length is declared to be 0. \mbox{\Hypertarget{byte__buf_8c_a173ae70dc07148c93669d9bf695ab9bd}\label{byte__buf_8c_a173ae70dc07148c93669d9bf695ab9bd}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_array\_eq\_c\_str@{aws\_array\_eq\_c\_str}}
\index{aws\_array\_eq\_c\_str@{aws\_array\_eq\_c\_str}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_array\_eq\_c\_str()}{aws\_array\_eq\_c\_str()}}
{\footnotesize\ttfamily bool aws\+\_\+array\+\_\+eq\+\_\+c\+\_\+str (\begin{DoxyParamCaption}\item[{const void $\ast$const}]{array,  }\item[{const size\+\_\+t}]{array\+\_\+len,  }\item[{const char $\ast$const}]{c\+\_\+str }\end{DoxyParamCaption})}

Compare an array and a null-\/terminated string. Returns true if their contents are equivalent. The array should NOT contain a null-\/terminator, or the comparison will always return false. NULL may be passed as the array pointer if its length is declared to be 0. \mbox{\Hypertarget{byte__buf_8c_ab764fa5e408f601deef8f78aa969a92c}\label{byte__buf_8c_ab764fa5e408f601deef8f78aa969a92c}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_array\_eq\_c\_str\_ignore\_case@{aws\_array\_eq\_c\_str\_ignore\_case}}
\index{aws\_array\_eq\_c\_str\_ignore\_case@{aws\_array\_eq\_c\_str\_ignore\_case}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_array\_eq\_c\_str\_ignore\_case()}{aws\_array\_eq\_c\_str\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+array\+\_\+eq\+\_\+c\+\_\+str\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const void $\ast$const}]{array,  }\item[{const size\+\_\+t}]{array\+\_\+len,  }\item[{const char $\ast$const}]{c\+\_\+str }\end{DoxyParamCaption})}

Perform a case-\/insensitive string comparison of an array and a null-\/terminated string. Return whether their contents are equivalent. The array should NOT contain a null-\/terminator, or the comparison will always return false. NULL may be passed as the array pointer if its length is declared to be 0. The \char`\"{}\+C\char`\"{} locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-\/8 will work fine too. \mbox{\Hypertarget{byte__buf_8c_ad7140a0d5f0196940bcf1d62f4679f33}\label{byte__buf_8c_ad7140a0d5f0196940bcf1d62f4679f33}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_array\_eq\_ignore\_case@{aws\_array\_eq\_ignore\_case}}
\index{aws\_array\_eq\_ignore\_case@{aws\_array\_eq\_ignore\_case}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_array\_eq\_ignore\_case()}{aws\_array\_eq\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+array\+\_\+eq\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const void $\ast$const}]{array\+\_\+a,  }\item[{const size\+\_\+t}]{len\+\_\+a,  }\item[{const void $\ast$const}]{array\+\_\+b,  }\item[{const size\+\_\+t}]{len\+\_\+b }\end{DoxyParamCaption})}

Perform a case-\/insensitive string comparison of two arrays. Return whether their contents are equivalent. NULL may be passed as the array pointer if its length is declared to be 0. The \char`\"{}\+C\char`\"{} locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-\/8 will work fine too. \mbox{\Hypertarget{byte__buf_8c_a69f9a5b942f8bd53e13037e65cd88d87}\label{byte__buf_8c_a69f9a5b942f8bd53e13037e65cd88d87}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_advance@{aws\_byte\_buf\_advance}}
\index{aws\_byte\_buf\_advance@{aws\_byte\_buf\_advance}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_advance()}{aws\_byte\_buf\_advance()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+advance (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{buffer,  }\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const \mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{output,  }\item[{const size\+\_\+t}]{len }\end{DoxyParamCaption})}

Appends a sub-\/buffer to the specified buffer.

If the buffer has at least `len' bytes remaining (buffer-\/\texorpdfstring{$>$}{>}capacity -\/ buffer-\/\texorpdfstring{$>$}{>}len \texorpdfstring{$>$}{>}= len), then buffer-\/\texorpdfstring{$>$}{>}len is incremented by len, and an \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} is assigned to $\ast$output corresponding to the last len bytes of the input buffer. The \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} at $\ast$output will have a null allocator, a zero initial length, and a capacity of \textquotesingle{}len\textquotesingle{}. The function then returns true.

If there is insufficient space, then this function nulls all fields in $\ast$output and returns false. \mbox{\Hypertarget{byte__buf_8c_acd3ab456a1b70a558da8e18e2724a948}\label{byte__buf_8c_acd3ab456a1b70a558da8e18e2724a948}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_append@{aws\_byte\_buf\_append}}
\index{aws\_byte\_buf\_append@{aws\_byte\_buf\_append}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_append()}{aws\_byte\_buf\_append()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+append (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{to,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{from }\end{DoxyParamCaption})}

Copies from to to. If to is too small, AWS\+\_\+\+ERROR\+\_\+\+DEST\+\_\+\+COPY\+\_\+\+TOO\+\_\+\+SMALL will be returned. dest-\/\texorpdfstring{$>$}{>}len will contain the amount of data actually copied to dest.

from and to may be the same buffer, permitting copying a buffer into itself. \mbox{\Hypertarget{byte__buf_8c_a42ca07fbf29e7b255dadc32d72fccc1b}\label{byte__buf_8c_a42ca07fbf29e7b255dadc32d72fccc1b}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_append\_and\_update@{aws\_byte\_buf\_append\_and\_update}}
\index{aws\_byte\_buf\_append\_and\_update@{aws\_byte\_buf\_append\_and\_update}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_append\_and\_update()}{aws\_byte\_buf\_append\_and\_update()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+and\+\_\+update (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{to,  }\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{from\+\_\+and\+\_\+update }\end{DoxyParamCaption})}

Copy contents of cursor to buffer, then update cursor to reference the memory stored in the buffer. If buffer is too small, AWS\+\_\+\+ERROR\+\_\+\+DEST\+\_\+\+COPY\+\_\+\+TOO\+\_\+\+SMALL will be returned.

The cursor is permitted to reference memory from earlier in the buffer. \mbox{\Hypertarget{byte__buf_8c_a7ba06d49ab6e673130c3205c666e37c9}\label{byte__buf_8c_a7ba06d49ab6e673130c3205c666e37c9}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_append\_byte\_dynamic@{aws\_byte\_buf\_append\_byte\_dynamic}}
\index{aws\_byte\_buf\_append\_byte\_dynamic@{aws\_byte\_buf\_append\_byte\_dynamic}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_append\_byte\_dynamic()}{aws\_byte\_buf\_append\_byte\_dynamic()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+byte\+\_\+dynamic (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buffer,  }\item[{uint8\+\_\+t}]{value }\end{DoxyParamCaption})}

Copies a single byte into {\ttfamily to}. If {\ttfamily to} is too small, the buffer will be grown appropriately and the old contents copied over, before the byte is appended.

If the grow fails (overflow or OOM), then an error will be returned. \mbox{\Hypertarget{byte__buf_8c_a64062c246870c740b40a7b847f75bad3}\label{byte__buf_8c_a64062c246870c740b40a7b847f75bad3}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_append\_byte\_dynamic\_secure@{aws\_byte\_buf\_append\_byte\_dynamic\_secure}}
\index{aws\_byte\_buf\_append\_byte\_dynamic\_secure@{aws\_byte\_buf\_append\_byte\_dynamic\_secure}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_append\_byte\_dynamic\_secure()}{aws\_byte\_buf\_append\_byte\_dynamic\_secure()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+byte\+\_\+dynamic\+\_\+secure (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buffer,  }\item[{uint8\+\_\+t}]{value }\end{DoxyParamCaption})}

Copies a single byte into {\ttfamily to}. If {\ttfamily to} is too small, the buffer will be grown appropriately and the old contents copied over, before the byte is appended.

If the grow fails (overflow or OOM), then an error will be returned.

If the buffer is grown, the old buffer will be securely cleared before getting freed. \mbox{\Hypertarget{byte__buf_8c_ab4a34b2d690f402d6f1eb78da880d43d}\label{byte__buf_8c_ab4a34b2d690f402d6f1eb78da880d43d}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_append\_dynamic@{aws\_byte\_buf\_append\_dynamic}}
\index{aws\_byte\_buf\_append\_dynamic@{aws\_byte\_buf\_append\_dynamic}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_append\_dynamic()}{aws\_byte\_buf\_append\_dynamic()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+dynamic (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{to,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{from }\end{DoxyParamCaption})}

Copies from to to. If to is too small, the buffer will be grown appropriately and the old contents copied to, before the new contents are appended.

If the grow fails (overflow or OOM), then an error will be returned.

from and to may be the same buffer, permitting copying a buffer into itself. \mbox{\Hypertarget{byte__buf_8c_a208d9f01f769fbc2440aa7d98019e639}\label{byte__buf_8c_a208d9f01f769fbc2440aa7d98019e639}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_append\_dynamic\_secure@{aws\_byte\_buf\_append\_dynamic\_secure}}
\index{aws\_byte\_buf\_append\_dynamic\_secure@{aws\_byte\_buf\_append\_dynamic\_secure}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_append\_dynamic\_secure()}{aws\_byte\_buf\_append\_dynamic\_secure()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+dynamic\+\_\+secure (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{to,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{from }\end{DoxyParamCaption})}

Copies {\ttfamily from} to {\ttfamily to}. If {\ttfamily to} is too small, the buffer will be grown appropriately and the old contents copied over, before the new contents are appended.

If the grow fails (overflow or OOM), then an error will be returned.

If the buffer is grown, the old buffer will be securely cleared before getting freed.

{\ttfamily from} and {\ttfamily to} may be the same buffer, permitting copying a buffer into itself. \mbox{\Hypertarget{byte__buf_8c_ab8f3b8863e45d8b2c415567d865a7c74}\label{byte__buf_8c_ab8f3b8863e45d8b2c415567d865a7c74}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_append\_null\_terminator@{aws\_byte\_buf\_append\_null\_terminator}}
\index{aws\_byte\_buf\_append\_null\_terminator@{aws\_byte\_buf\_append\_null\_terminator}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_append\_null\_terminator()}{aws\_byte\_buf\_append\_null\_terminator()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+null\+\_\+terminator (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf }\end{DoxyParamCaption})}

Appends \textquotesingle{}\textbackslash{}0\textquotesingle{} at the end of the buffer. \mbox{\Hypertarget{byte__buf_8c_a448b75fae26a0e95e178ac9629482e6f}\label{byte__buf_8c_a448b75fae26a0e95e178ac9629482e6f}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_append\_with\_lookup@{aws\_byte\_buf\_append\_with\_lookup}}
\index{aws\_byte\_buf\_append\_with\_lookup@{aws\_byte\_buf\_append\_with\_lookup}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_append\_with\_lookup()}{aws\_byte\_buf\_append\_with\_lookup()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+with\+\_\+lookup (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{to,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{from,  }\item[{const uint8\+\_\+t $\ast$}]{lookup\+\_\+table }\end{DoxyParamCaption})}

Copies from to to while converting bytes via the passed in lookup table. If to is too small, AWS\+\_\+\+ERROR\+\_\+\+DEST\+\_\+\+COPY\+\_\+\+TOO\+\_\+\+SMALL will be returned. to-\/\texorpdfstring{$>$}{>}len will contain its original size plus the amount of data actually copied to to.

from and to should not be the same buffer (overlap is not handled) lookup\+\_\+table must be at least 256 bytes \mbox{\Hypertarget{byte__buf_8c_a6ed7bf940089a3adfb6e44ab70203156}\label{byte__buf_8c_a6ed7bf940089a3adfb6e44ab70203156}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_cat@{aws\_byte\_buf\_cat}}
\index{aws\_byte\_buf\_cat@{aws\_byte\_buf\_cat}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_cat()}{aws\_byte\_buf\_cat()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+cat (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{dest,  }\item[{size\+\_\+t}]{number\+\_\+of\+\_\+args,  }\item[{}]{... }\end{DoxyParamCaption})}

Concatenates a variable number of struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$ into destination. Number of args must be greater than 1. If dest is too small, AWS\+\_\+\+ERROR\+\_\+\+DEST\+\_\+\+COPY\+\_\+\+TOO\+\_\+\+SMALL will be returned. dest-\/\texorpdfstring{$>$}{>}len will contain the amount of data actually copied to dest. \mbox{\Hypertarget{byte__buf_8c_acbddfbd5ccda972a6630cd841fec7b21}\label{byte__buf_8c_acbddfbd5ccda972a6630cd841fec7b21}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_clean\_up@{aws\_byte\_buf\_clean\_up}}
\index{aws\_byte\_buf\_clean\_up@{aws\_byte\_buf\_clean\_up}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_clean\_up()}{aws\_byte\_buf\_clean\_up()}}
{\footnotesize\ttfamily void aws\+\_\+byte\+\_\+buf\+\_\+clean\+\_\+up (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf }\end{DoxyParamCaption})}

\mbox{\Hypertarget{byte__buf_8c_a9f4e4659a9a46d1014b10424a87b8286}\label{byte__buf_8c_a9f4e4659a9a46d1014b10424a87b8286}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_clean\_up\_secure@{aws\_byte\_buf\_clean\_up\_secure}}
\index{aws\_byte\_buf\_clean\_up\_secure@{aws\_byte\_buf\_clean\_up\_secure}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_clean\_up\_secure()}{aws\_byte\_buf\_clean\_up\_secure()}}
{\footnotesize\ttfamily void aws\+\_\+byte\+\_\+buf\+\_\+clean\+\_\+up\+\_\+secure (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf }\end{DoxyParamCaption})}

Equivalent to calling aws\+\_\+byte\+\_\+buf\+\_\+secure\+\_\+zero and then aws\+\_\+byte\+\_\+buf\+\_\+clean\+\_\+up on the buffer. \mbox{\Hypertarget{byte__buf_8c_a2246da0ca31f44fc92d4ebc9fa16cb45}\label{byte__buf_8c_a2246da0ca31f44fc92d4ebc9fa16cb45}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_eq@{aws\_byte\_buf\_eq}}
\index{aws\_byte\_buf\_eq@{aws\_byte\_buf\_eq}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_eq()}{aws\_byte\_buf\_eq()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+eq (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{b }\end{DoxyParamCaption})}

Compare two \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} structures. Return whether their contents are equivalent. \mbox{\Hypertarget{byte__buf_8c_ab9d84517a8dd0c4ab2b3b17c108814c4}\label{byte__buf_8c_ab9d84517a8dd0c4ab2b3b17c108814c4}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_eq\_c\_str@{aws\_byte\_buf\_eq\_c\_str}}
\index{aws\_byte\_buf\_eq\_c\_str@{aws\_byte\_buf\_eq\_c\_str}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_eq\_c\_str()}{aws\_byte\_buf\_eq\_c\_str()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+eq\+\_\+c\+\_\+str (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{buf,  }\item[{const char $\ast$const}]{c\+\_\+str }\end{DoxyParamCaption})}

Compare an \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} and a null-\/terminated string. Returns true if their contents are equivalent. The buffer should NOT contain a null-\/terminator, or the comparison will always return false. \mbox{\Hypertarget{byte__buf_8c_af2e8f1e9a122054ada8a3e867aa9a6f8}\label{byte__buf_8c_af2e8f1e9a122054ada8a3e867aa9a6f8}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_eq\_c\_str\_ignore\_case@{aws\_byte\_buf\_eq\_c\_str\_ignore\_case}}
\index{aws\_byte\_buf\_eq\_c\_str\_ignore\_case@{aws\_byte\_buf\_eq\_c\_str\_ignore\_case}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_eq\_c\_str\_ignore\_case()}{aws\_byte\_buf\_eq\_c\_str\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+eq\+\_\+c\+\_\+str\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{buf,  }\item[{const char $\ast$const}]{c\+\_\+str }\end{DoxyParamCaption})}

Perform a case-\/insensitive string comparison of an \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} and a null-\/terminated string. Return whether their contents are equivalent. The buffer should NOT contain a null-\/terminator, or the comparison will always return false. The \char`\"{}\+C\char`\"{} locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-\/8 will work fine too. \mbox{\Hypertarget{byte__buf_8c_a23180f5c686096e7f2902e147635aeb1}\label{byte__buf_8c_a23180f5c686096e7f2902e147635aeb1}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_eq\_ignore\_case@{aws\_byte\_buf\_eq\_ignore\_case}}
\index{aws\_byte\_buf\_eq\_ignore\_case@{aws\_byte\_buf\_eq\_ignore\_case}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_eq\_ignore\_case()}{aws\_byte\_buf\_eq\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+eq\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{b }\end{DoxyParamCaption})}

Perform a case-\/insensitive string comparison of two \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} structures. Return whether their contents are equivalent. The \char`\"{}\+C\char`\"{} locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-\/8 will work fine too. \mbox{\Hypertarget{byte__buf_8c_a20059771adc23906f5e01f881ed4e14a}\label{byte__buf_8c_a20059771adc23906f5e01f881ed4e14a}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_from\_array@{aws\_byte\_buf\_from\_array}}
\index{aws\_byte\_buf\_from\_array@{aws\_byte\_buf\_from\_array}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_from\_array()}{aws\_byte\_buf\_from\_array()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} aws\+\_\+byte\+\_\+buf\+\_\+from\+\_\+array (\begin{DoxyParamCaption}\item[{const void $\ast$}]{bytes,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}

\mbox{\Hypertarget{byte__buf_8c_a2a9635250be1b7cc705444b15a4ee959}\label{byte__buf_8c_a2a9635250be1b7cc705444b15a4ee959}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_from\_c\_str@{aws\_byte\_buf\_from\_c\_str}}
\index{aws\_byte\_buf\_from\_c\_str@{aws\_byte\_buf\_from\_c\_str}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_from\_c\_str()}{aws\_byte\_buf\_from\_c\_str()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} aws\+\_\+byte\+\_\+buf\+\_\+from\+\_\+c\+\_\+str (\begin{DoxyParamCaption}\item[{const char $\ast$}]{c\+\_\+str }\end{DoxyParamCaption})}

For creating a byte buffer from a null-\/terminated string literal. \mbox{\Hypertarget{byte__buf_8c_aa1e35c2ba3ed311c07ea04d6afdcc5e9}\label{byte__buf_8c_aa1e35c2ba3ed311c07ea04d6afdcc5e9}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_from\_empty\_array@{aws\_byte\_buf\_from\_empty\_array}}
\index{aws\_byte\_buf\_from\_empty\_array@{aws\_byte\_buf\_from\_empty\_array}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_from\_empty\_array()}{aws\_byte\_buf\_from\_empty\_array()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} aws\+\_\+byte\+\_\+buf\+\_\+from\+\_\+empty\+\_\+array (\begin{DoxyParamCaption}\item[{const void $\ast$}]{bytes,  }\item[{size\+\_\+t}]{capacity }\end{DoxyParamCaption})}

\mbox{\Hypertarget{byte__buf_8c_adf8ed14982cd1aa9e83c924ebb5856ae}\label{byte__buf_8c_adf8ed14982cd1aa9e83c924ebb5856ae}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_init@{aws\_byte\_buf\_init}}
\index{aws\_byte\_buf\_init@{aws\_byte\_buf\_init}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_init()}{aws\_byte\_buf\_init()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+init (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{size\+\_\+t}]{capacity }\end{DoxyParamCaption})}

Copyright Amazon.\+com, Inc. or its affiliates. All Rights Reserved. SPDX-\/\+License-\/\+Identifier\+: Apache-\/2.\+0. \mbox{\Hypertarget{byte__buf_8c_aac5490e5293c67b8f0a82342ea81c917}\label{byte__buf_8c_aac5490e5293c67b8f0a82342ea81c917}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_init\_cache\_and\_update\_cursors@{aws\_byte\_buf\_init\_cache\_and\_update\_cursors}}
\index{aws\_byte\_buf\_init\_cache\_and\_update\_cursors@{aws\_byte\_buf\_init\_cache\_and\_update\_cursors}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_init\_cache\_and\_update\_cursors()}{aws\_byte\_buf\_init\_cache\_and\_update\_cursors()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+init\+\_\+cache\+\_\+and\+\_\+update\+\_\+cursors (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{dest,  }\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{}]{... }\end{DoxyParamCaption})}

Init buffer with contents of multiple cursors, and update cursors to reference the memory stored in the buffer. Each cursor arg must be an {\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}. NULL must be passed as the final arg. NOTE\+: Do not append/grow/resize buffers initialized this way, or the cursors will end up referencing invalid memory. Returns AWS\+\_\+\+OP\+\_\+\+SUCCESS in case of success. AWS\+\_\+\+OP\+\_\+\+ERR is returned if memory can\textquotesingle{}t be allocated or the total cursor length exceeds SIZE\+\_\+\+MAX. \mbox{\Hypertarget{byte__buf_8c_afcaa669dd210b0cf9820deca75c9a686}\label{byte__buf_8c_afcaa669dd210b0cf9820deca75c9a686}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_init\_copy@{aws\_byte\_buf\_init\_copy}}
\index{aws\_byte\_buf\_init\_copy@{aws\_byte\_buf\_init\_copy}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_init\_copy()}{aws\_byte\_buf\_init\_copy()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+init\+\_\+copy (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{dest,  }\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{src }\end{DoxyParamCaption})}

Initializes an \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} structure base on another valid one. Requires\+: $\ast$src and $\ast$allocator are valid objects. Ensures\+: $\ast$dest is a valid \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} with a new backing array dest-\/\texorpdfstring{$>$}{>}buffer which is a copy of the elements from src-\/\texorpdfstring{$>$}{>}buffer. \mbox{\Hypertarget{byte__buf_8c_add0e7102270fffc97b9d7da4d0a38bd7}\label{byte__buf_8c_add0e7102270fffc97b9d7da4d0a38bd7}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_init\_copy\_from\_cursor@{aws\_byte\_buf\_init\_copy\_from\_cursor}}
\index{aws\_byte\_buf\_init\_copy\_from\_cursor@{aws\_byte\_buf\_init\_copy\_from\_cursor}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_init\_copy\_from\_cursor()}{aws\_byte\_buf\_init\_copy\_from\_cursor()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+init\+\_\+copy\+\_\+from\+\_\+cursor (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{dest,  }\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}}}]{src }\end{DoxyParamCaption})}

Copies src buffer into dest and sets the correct len and capacity. A new memory zone is allocated for dest-\/\texorpdfstring{$>$}{>}buffer. When dest is no longer needed it will have to be cleaned-\/up using aws\+\_\+byte\+\_\+buf\+\_\+clean\+\_\+up(dest). Dest capacity and len will be equal to the src len. Allocator of the dest will be identical with parameter allocator. If src buffer is null the dest will have a null buffer with a len and a capacity of 0 Returns AWS\+\_\+\+OP\+\_\+\+SUCCESS in case of success or AWS\+\_\+\+OP\+\_\+\+ERR when memory can\textquotesingle{}t be allocated. \mbox{\Hypertarget{byte__buf_8c_a07926449452596f7b4750430607a9277}\label{byte__buf_8c_a07926449452596f7b4750430607a9277}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_is\_valid@{aws\_byte\_buf\_is\_valid}}
\index{aws\_byte\_buf\_is\_valid@{aws\_byte\_buf\_is\_valid}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_is\_valid()}{aws\_byte\_buf\_is\_valid()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+is\+\_\+valid (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{buf }\end{DoxyParamCaption})}

Evaluates the set of properties that define the shape of all valid \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} structures. It is also a cheap check, in the sense it run in constant time (i.\+e., no loops or recursion). \mbox{\Hypertarget{byte__buf_8c_af900ec5d14c51db19a58383ecdaecbe3}\label{byte__buf_8c_af900ec5d14c51db19a58383ecdaecbe3}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_reserve@{aws\_byte\_buf\_reserve}}
\index{aws\_byte\_buf\_reserve@{aws\_byte\_buf\_reserve}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_reserve()}{aws\_byte\_buf\_reserve()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+reserve (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buffer,  }\item[{size\+\_\+t}]{requested\+\_\+capacity }\end{DoxyParamCaption})}

Attempts to increase the capacity of a buffer to the requested capacity

If the the buffer\textquotesingle{}s capacity is currently larger than the request capacity, the function does nothing (no shrink is performed). \mbox{\Hypertarget{byte__buf_8c_a73cb440263d7afb68ae6a88ca92d98cf}\label{byte__buf_8c_a73cb440263d7afb68ae6a88ca92d98cf}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_reserve\_relative@{aws\_byte\_buf\_reserve\_relative}}
\index{aws\_byte\_buf\_reserve\_relative@{aws\_byte\_buf\_reserve\_relative}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_reserve\_relative()}{aws\_byte\_buf\_reserve\_relative()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+buf\+\_\+reserve\+\_\+relative (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buffer,  }\item[{size\+\_\+t}]{additional\+\_\+length }\end{DoxyParamCaption})}

Convenience function that attempts to increase the capacity of a buffer relative to the current length.

aws\+\_\+byte\+\_\+buf\+\_\+reserve\+\_\+relative(buf, x) $\sim$$\sim$ aws\+\_\+byte\+\_\+buf\+\_\+reserve(buf, buf-\/\texorpdfstring{$>$}{>}len + x) \mbox{\Hypertarget{byte__buf_8c_aba38e9db5164e21174386de288aa1c7d}\label{byte__buf_8c_aba38e9db5164e21174386de288aa1c7d}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_reset@{aws\_byte\_buf\_reset}}
\index{aws\_byte\_buf\_reset@{aws\_byte\_buf\_reset}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_reset()}{aws\_byte\_buf\_reset()}}
{\footnotesize\ttfamily void aws\+\_\+byte\+\_\+buf\+\_\+reset (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{bool}]{zero\+\_\+contents }\end{DoxyParamCaption})}

Resets the len of the buffer to 0, but does not free the memory. The buffer can then be reused. Optionally zeroes the contents, if the \char`\"{}zero\+\_\+contents\char`\"{} flag is true. \mbox{\Hypertarget{byte__buf_8c_ac1d0a2e070ce4e156bc636c9873eb4ad}\label{byte__buf_8c_ac1d0a2e070ce4e156bc636c9873eb4ad}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_secure\_zero@{aws\_byte\_buf\_secure\_zero}}
\index{aws\_byte\_buf\_secure\_zero@{aws\_byte\_buf\_secure\_zero}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_secure\_zero()}{aws\_byte\_buf\_secure\_zero()}}
{\footnotesize\ttfamily void aws\+\_\+byte\+\_\+buf\+\_\+secure\+\_\+zero (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf }\end{DoxyParamCaption})}

Sets all bytes of buffer to zero and resets len to zero. \mbox{\Hypertarget{byte__buf_8c_ad5eb15960520d84856f48e4cfe44e41c}\label{byte__buf_8c_ad5eb15960520d84856f48e4cfe44e41c}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write@{aws\_byte\_buf\_write}}
\index{aws\_byte\_buf\_write@{aws\_byte\_buf\_write}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write()}{aws\_byte\_buf\_write()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{buf,  }\item[{const uint8\+\_\+t $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{src,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}

Write specified number of bytes from array to byte buffer.

On success, returns true and updates the buffer length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged. \mbox{\Hypertarget{byte__buf_8c_a91870598496fcac2bf5d77ad6a998b7e}\label{byte__buf_8c_a91870598496fcac2bf5d77ad6a998b7e}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_be16@{aws\_byte\_buf\_write\_be16}}
\index{aws\_byte\_buf\_write\_be16@{aws\_byte\_buf\_write\_be16}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_be16()}{aws\_byte\_buf\_write\_be16()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+be16 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{uint16\+\_\+t}]{x }\end{DoxyParamCaption})}

Writes a 16-\/bit integer in network byte order (big endian) to buffer.

On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_abf380cf62e596ce34aaceabcf7996d9c}\label{byte__buf_8c_abf380cf62e596ce34aaceabcf7996d9c}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_be24@{aws\_byte\_buf\_write\_be24}}
\index{aws\_byte\_buf\_write\_be24@{aws\_byte\_buf\_write\_be24}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_be24()}{aws\_byte\_buf\_write\_be24()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+be24 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{uint32\+\_\+t}]{x }\end{DoxyParamCaption})}

Writes low 24-\/bits (3 bytes) of an unsigned integer in network byte order (big endian) to buffer. Ex\+: If x is 0x00\+AABBCC then \{0x\+AA, 0x\+BB, 0x\+CC\} is written to buffer.

On success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, or x\textquotesingle{}s value cannot fit in 3 bytes, returns false, leaving the buffer unchanged. \mbox{\Hypertarget{byte__buf_8c_a81fd5bb13722894ccbfb6a39ed03e660}\label{byte__buf_8c_a81fd5bb13722894ccbfb6a39ed03e660}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_be32@{aws\_byte\_buf\_write\_be32}}
\index{aws\_byte\_buf\_write\_be32@{aws\_byte\_buf\_write\_be32}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_be32()}{aws\_byte\_buf\_write\_be32()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+be32 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{uint32\+\_\+t}]{x }\end{DoxyParamCaption})}

Writes a 32-\/bit integer in network byte order (big endian) to buffer.

On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_a7f5ea0bdff141303034776d462a902e0}\label{byte__buf_8c_a7f5ea0bdff141303034776d462a902e0}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_be64@{aws\_byte\_buf\_write\_be64}}
\index{aws\_byte\_buf\_write\_be64@{aws\_byte\_buf\_write\_be64}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_be64()}{aws\_byte\_buf\_write\_be64()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+be64 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{uint64\+\_\+t}]{x }\end{DoxyParamCaption})}

Writes a 64-\/bit integer in network byte order (big endian) to buffer.

On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_a40b9731ae303c500db1ca2420bf4f622}\label{byte__buf_8c_a40b9731ae303c500db1ca2420bf4f622}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_float\_be32@{aws\_byte\_buf\_write\_float\_be32}}
\index{aws\_byte\_buf\_write\_float\_be32@{aws\_byte\_buf\_write\_float\_be32}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_float\_be32()}{aws\_byte\_buf\_write\_float\_be32()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+float\+\_\+be32 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{float}]{x }\end{DoxyParamCaption})}

Writes a 32-\/bit float in network byte order (big endian) to buffer.

On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_afac0cfa18673d619707634bcbd7c460e}\label{byte__buf_8c_afac0cfa18673d619707634bcbd7c460e}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_float\_be64@{aws\_byte\_buf\_write\_float\_be64}}
\index{aws\_byte\_buf\_write\_float\_be64@{aws\_byte\_buf\_write\_float\_be64}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_float\_be64()}{aws\_byte\_buf\_write\_float\_be64()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+float\+\_\+be64 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{double}]{x }\end{DoxyParamCaption})}

Writes a 64-\/bit float in network byte order (big endian) to buffer.

On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_a9ee727a2ce9e82fe553908fe7fa69799}\label{byte__buf_8c_a9ee727a2ce9e82fe553908fe7fa69799}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_from\_whole\_buffer@{aws\_byte\_buf\_write\_from\_whole\_buffer}}
\index{aws\_byte\_buf\_write\_from\_whole\_buffer@{aws\_byte\_buf\_write\_from\_whole\_buffer}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_from\_whole\_buffer()}{aws\_byte\_buf\_write\_from\_whole\_buffer()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+from\+\_\+whole\+\_\+buffer (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{buf,  }\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}}}]{src }\end{DoxyParamCaption})}

Copies all bytes from buffer to buffer.

On success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged. \mbox{\Hypertarget{byte__buf_8c_ae96b20ca3aa078b8c4437be04d9eb673}\label{byte__buf_8c_ae96b20ca3aa078b8c4437be04d9eb673}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_from\_whole\_cursor@{aws\_byte\_buf\_write\_from\_whole\_cursor}}
\index{aws\_byte\_buf\_write\_from\_whole\_cursor@{aws\_byte\_buf\_write\_from\_whole\_cursor}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_from\_whole\_cursor()}{aws\_byte\_buf\_write\_from\_whole\_cursor()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+from\+\_\+whole\+\_\+cursor (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{buf,  }\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}}}]{src }\end{DoxyParamCaption})}

Copies all bytes from buffer to buffer.

On success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged. \mbox{\Hypertarget{byte__buf_8c_a85b9ae8e8822d3a05daf3fc5eb513aef}\label{byte__buf_8c_a85b9ae8e8822d3a05daf3fc5eb513aef}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_to\_capacity@{aws\_byte\_buf\_write\_to\_capacity}}
\index{aws\_byte\_buf\_write\_to\_capacity@{aws\_byte\_buf\_write\_to\_capacity}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_to\_capacity()}{aws\_byte\_buf\_write\_to\_capacity()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+to\+\_\+capacity (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{advancing\+\_\+cursor }\end{DoxyParamCaption})}

Without increasing buf\textquotesingle{}s capacity, write as much as possible from advancing\+\_\+cursor into buf.

buf\textquotesingle{}s len is updated accordingly. advancing\+\_\+cursor is advanced so it contains the remaining unwritten parts. Returns the section of advancing\+\_\+cursor which was written.

This function cannot fail. If buf is full (len == capacity) or advancing\+\_\+len has 0 length, then buf and advancing\+\_\+cursor are not altered and a cursor with 0 length is returned.

Example\+: Given a buf with 2 bytes of space available and advancing\+\_\+cursor with contents \char`\"{}abc\char`\"{}. \char`\"{}ab\char`\"{} will be written to buf and buf-\/\texorpdfstring{$>$}{>}len will increase 2 and become equal to buf-\/\texorpdfstring{$>$}{>}capacity. advancing\+\_\+cursor will advance so its contents become the unwritten \char`\"{}c\char`\"{}. The returned cursor\textquotesingle{}s contents will be the \char`\"{}ab\char`\"{} from the original advancing\+\_\+cursor. \mbox{\Hypertarget{byte__buf_8c_ad4f47337cb3ec100c5473ab188c3eb05}\label{byte__buf_8c_ad4f47337cb3ec100c5473ab188c3eb05}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_u8@{aws\_byte\_buf\_write\_u8}}
\index{aws\_byte\_buf\_write\_u8@{aws\_byte\_buf\_write\_u8}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_u8()}{aws\_byte\_buf\_write\_u8()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+u8 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{buf,  }\item[{uint8\+\_\+t}]{c }\end{DoxyParamCaption})}

Copies one byte to buffer.

On success, returns true and updates the cursor /length accordingly.

If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_a21ddba7196eb554b19184ab12129fb4b}\label{byte__buf_8c_a21ddba7196eb554b19184ab12129fb4b}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_buf\_write\_u8\_n@{aws\_byte\_buf\_write\_u8\_n}}
\index{aws\_byte\_buf\_write\_u8\_n@{aws\_byte\_buf\_write\_u8\_n}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_u8\_n()}{aws\_byte\_buf\_write\_u8\_n()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+u8\+\_\+n (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf,  }\item[{uint8\+\_\+t}]{c,  }\item[{size\+\_\+t}]{count }\end{DoxyParamCaption})}

Writes one byte repeatedly to buffer (like memset)

If there is insufficient space in the buffer, returns false, leaving the buffer unchanged. \mbox{\Hypertarget{byte__buf_8c_a71e79909e24bdfce3bb0e3331886dcd3}\label{byte__buf_8c_a71e79909e24bdfce3bb0e3331886dcd3}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_advance@{aws\_byte\_cursor\_advance}}
\index{aws\_byte\_cursor\_advance@{aws\_byte\_cursor\_advance}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_advance()}{aws\_byte\_cursor\_advance()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+cursor\+\_\+advance (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const}]{cursor,  }\item[{const size\+\_\+t}]{len }\end{DoxyParamCaption})}

Tests if the given \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} has at least len bytes remaining. If so, $\ast$buf is advanced by len bytes (incrementing -\/\texorpdfstring{$>$}{>}ptr and decrementing -\/\texorpdfstring{$>$}{>}len), and an \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} referring to the first len bytes of the original $\ast$buf is returned. Otherwise, an \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} with -\/\texorpdfstring{$>$}{>}ptr = NULL, -\/\texorpdfstring{$>$}{>}len = 0 is returned.

Note that if len is above (SIZE\+\_\+\+MAX / 2), this function will also treat it as a buffer overflow, and return NULL without changing $\ast$buf. \mbox{\Hypertarget{byte__buf_8c_a6b3528b29474a2962bf2c4c231e6abea}\label{byte__buf_8c_a6b3528b29474a2962bf2c4c231e6abea}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_advance\_nospec@{aws\_byte\_cursor\_advance\_nospec}}
\index{aws\_byte\_cursor\_advance\_nospec@{aws\_byte\_cursor\_advance\_nospec}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_advance\_nospec()}{aws\_byte\_cursor\_advance\_nospec()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+cursor\+\_\+advance\+\_\+nospec (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const}]{cursor,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}

Behaves identically to aws\+\_\+byte\+\_\+cursor\+\_\+advance, but avoids speculative execution potentially reading out-\/of-\/bounds pointers (by returning an empty ptr in such speculated paths).

This should generally be done when using an untrusted or data-\/dependent value for \textquotesingle{}len\textquotesingle{}, to avoid speculating into a path where cursor-\/\texorpdfstring{$>$}{>}ptr points outside the true ptr length. \mbox{\Hypertarget{byte__buf_8c_a36c04f9cc728fb734ef9bc26432d177a}\label{byte__buf_8c_a36c04f9cc728fb734ef9bc26432d177a}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_compare\_lexical@{aws\_byte\_cursor\_compare\_lexical}}
\index{aws\_byte\_cursor\_compare\_lexical@{aws\_byte\_cursor\_compare\_lexical}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_compare\_lexical()}{aws\_byte\_cursor\_compare\_lexical()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+cursor\+\_\+compare\+\_\+lexical (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{lhs,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{rhs }\end{DoxyParamCaption})}

Lexical (byte value) comparison of two byte cursors \mbox{\Hypertarget{byte__buf_8c_abcf26003c9712b9d16e334aaef9888d1}\label{byte__buf_8c_abcf26003c9712b9d16e334aaef9888d1}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_compare\_lookup@{aws\_byte\_cursor\_compare\_lookup}}
\index{aws\_byte\_cursor\_compare\_lookup@{aws\_byte\_cursor\_compare\_lookup}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_compare\_lookup()}{aws\_byte\_cursor\_compare\_lookup()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+cursor\+\_\+compare\+\_\+lookup (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{lhs,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{rhs,  }\item[{const uint8\+\_\+t $\ast$}]{lookup\+\_\+table }\end{DoxyParamCaption})}

Lexical (byte value) comparison of two byte cursors where the raw values are sent through a lookup table first \mbox{\Hypertarget{byte__buf_8c_a6ac432a626706052a527c1349fb8cbd4}\label{byte__buf_8c_a6ac432a626706052a527c1349fb8cbd4}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_eq@{aws\_byte\_cursor\_eq}}
\index{aws\_byte\_cursor\_eq@{aws\_byte\_cursor\_eq}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_eq()}{aws\_byte\_cursor\_eq()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+eq (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{b }\end{DoxyParamCaption})}

Compare two \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} structures. Return whether their contents are equivalent. \mbox{\Hypertarget{byte__buf_8c_a31a7dc00c06d8a4abe69a9680934336a}\label{byte__buf_8c_a31a7dc00c06d8a4abe69a9680934336a}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_eq\_byte\_buf@{aws\_byte\_cursor\_eq\_byte\_buf}}
\index{aws\_byte\_cursor\_eq\_byte\_buf@{aws\_byte\_cursor\_eq\_byte\_buf}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_eq\_byte\_buf()}{aws\_byte\_cursor\_eq\_byte\_buf()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+byte\+\_\+buf (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{b }\end{DoxyParamCaption})}

Compare an \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} and an \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}}. Return whether their contents are equivalent. \mbox{\Hypertarget{byte__buf_8c_a6952e4ba3307e2a05d5edadc0d92cee0}\label{byte__buf_8c_a6952e4ba3307e2a05d5edadc0d92cee0}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_eq\_byte\_buf\_ignore\_case@{aws\_byte\_cursor\_eq\_byte\_buf\_ignore\_case}}
\index{aws\_byte\_cursor\_eq\_byte\_buf\_ignore\_case@{aws\_byte\_cursor\_eq\_byte\_buf\_ignore\_case}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_eq\_byte\_buf\_ignore\_case()}{aws\_byte\_cursor\_eq\_byte\_buf\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+byte\+\_\+buf\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{b }\end{DoxyParamCaption})}

Perform a case-\/insensitive string comparison of an \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} and an \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}}. Return whether their contents are equivalent. The \char`\"{}\+C\char`\"{} locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-\/8 will work fine too. \mbox{\Hypertarget{byte__buf_8c_a410ca19b956f672343dfa71c2f534abe}\label{byte__buf_8c_a410ca19b956f672343dfa71c2f534abe}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_eq\_c\_str@{aws\_byte\_cursor\_eq\_c\_str}}
\index{aws\_byte\_cursor\_eq\_c\_str@{aws\_byte\_cursor\_eq\_c\_str}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_eq\_c\_str()}{aws\_byte\_cursor\_eq\_c\_str()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+c\+\_\+str (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const}]{cursor,  }\item[{const char $\ast$const}]{c\+\_\+str }\end{DoxyParamCaption})}

Compare an \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} and a null-\/terminated string. Returns true if their contents are equivalent. The cursor should NOT contain a null-\/terminator, or the comparison will always return false. \mbox{\Hypertarget{byte__buf_8c_afbd816b132e73605793c8a7b848997b1}\label{byte__buf_8c_afbd816b132e73605793c8a7b848997b1}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_eq\_c\_str\_ignore\_case@{aws\_byte\_cursor\_eq\_c\_str\_ignore\_case}}
\index{aws\_byte\_cursor\_eq\_c\_str\_ignore\_case@{aws\_byte\_cursor\_eq\_c\_str\_ignore\_case}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_eq\_c\_str\_ignore\_case()}{aws\_byte\_cursor\_eq\_c\_str\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+c\+\_\+str\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$const}]{cursor,  }\item[{const char $\ast$const}]{c\+\_\+str }\end{DoxyParamCaption})}

Perform a case-\/insensitive string comparison of an \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} and a null-\/terminated string. Return whether their contents are equivalent. The cursor should NOT contain a null-\/terminator, or the comparison will always return false. The \char`\"{}\+C\char`\"{} locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-\/8 will work fine too. \mbox{\Hypertarget{byte__buf_8c_a509e25ff72150c5f4f4a40e48432c402}\label{byte__buf_8c_a509e25ff72150c5f4f4a40e48432c402}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_eq\_ignore\_case@{aws\_byte\_cursor\_eq\_ignore\_case}}
\index{aws\_byte\_cursor\_eq\_ignore\_case@{aws\_byte\_cursor\_eq\_ignore\_case}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_eq\_ignore\_case()}{aws\_byte\_cursor\_eq\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+eq\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{b }\end{DoxyParamCaption})}

Perform a case-\/insensitive string comparison of two \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} structures. Return whether their contents are equivalent. The \char`\"{}\+C\char`\"{} locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-\/8 will work fine too. \mbox{\Hypertarget{byte__buf_8c_a8034dfb48cf116946a092436e409bf9a}\label{byte__buf_8c_a8034dfb48cf116946a092436e409bf9a}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_find\_exact@{aws\_byte\_cursor\_find\_exact}}
\index{aws\_byte\_cursor\_find\_exact@{aws\_byte\_cursor\_find\_exact}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_find\_exact()}{aws\_byte\_cursor\_find\_exact()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+cursor\+\_\+find\+\_\+exact (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{input\+\_\+str,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{to\+\_\+find,  }\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{first\+\_\+find }\end{DoxyParamCaption})}

Search for an exact byte match inside a cursor. The first match will be returned. Returns AWS\+\_\+\+OP\+\_\+\+SUCCESS on successful match and first\+\_\+find will be set to the offset in input\+\_\+str, and length will be the remaining length from input\+\_\+str past the returned offset. If the match was not found, AWS\+\_\+\+OP\+\_\+\+ERR will be returned and AWS\+\_\+\+ERROR\+\_\+\+STRING\+\_\+\+MATCH\+\_\+\+NOT\+\_\+\+FOUND will be raised. \mbox{\Hypertarget{byte__buf_8c_a3af2b9b3bd6c53ad69de9f506590edf0}\label{byte__buf_8c_a3af2b9b3bd6c53ad69de9f506590edf0}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_from\_array@{aws\_byte\_cursor\_from\_array}}
\index{aws\_byte\_cursor\_from\_array@{aws\_byte\_cursor\_from\_array}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_from\_array()}{aws\_byte\_cursor\_from\_array()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+cursor\+\_\+from\+\_\+array (\begin{DoxyParamCaption}\item[{const void $\ast$const}]{bytes,  }\item[{const size\+\_\+t}]{len }\end{DoxyParamCaption})}

\mbox{\Hypertarget{byte__buf_8c_ad880888d05132a33f4301d706a39abe2}\label{byte__buf_8c_ad880888d05132a33f4301d706a39abe2}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_from\_buf@{aws\_byte\_cursor\_from\_buf}}
\index{aws\_byte\_cursor\_from\_buf@{aws\_byte\_cursor\_from\_buf}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_from\_buf()}{aws\_byte\_cursor\_from\_buf()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+cursor\+\_\+from\+\_\+buf (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$const}]{buf }\end{DoxyParamCaption})}

\mbox{\Hypertarget{byte__buf_8c_a1eb17ec562f4309e8d00717c9a6b9091}\label{byte__buf_8c_a1eb17ec562f4309e8d00717c9a6b9091}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_from\_c\_str@{aws\_byte\_cursor\_from\_c\_str}}
\index{aws\_byte\_cursor\_from\_c\_str@{aws\_byte\_cursor\_from\_c\_str}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_from\_c\_str()}{aws\_byte\_cursor\_from\_c\_str()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+cursor\+\_\+from\+\_\+c\+\_\+str (\begin{DoxyParamCaption}\item[{const char $\ast$}]{c\+\_\+str }\end{DoxyParamCaption})}

\mbox{\Hypertarget{byte__buf_8c_a6a58a8d6758717dcdbf2ed031d44d68c}\label{byte__buf_8c_a6a58a8d6758717dcdbf2ed031d44d68c}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_is\_valid@{aws\_byte\_cursor\_is\_valid}}
\index{aws\_byte\_cursor\_is\_valid@{aws\_byte\_cursor\_is\_valid}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_is\_valid()}{aws\_byte\_cursor\_is\_valid()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+is\+\_\+valid (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cursor }\end{DoxyParamCaption})}

Evaluates the set of properties that define the shape of all valid \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} structures. It is also a cheap check, in the sense it runs in constant time (i.\+e., no loops or recursion). \mbox{\Hypertarget{byte__buf_8c_af052c1f50ed8119107b216d1623526ce}\label{byte__buf_8c_af052c1f50ed8119107b216d1623526ce}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_left\_trim\_pred@{aws\_byte\_cursor\_left\_trim\_pred}}
\index{aws\_byte\_cursor\_left\_trim\_pred@{aws\_byte\_cursor\_left\_trim\_pred}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_left\_trim\_pred()}{aws\_byte\_cursor\_left\_trim\_pred()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+cursor\+\_\+left\+\_\+trim\+\_\+pred (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{source,  }\item[{\mbox{\hyperlink{byte__buf_8h_ace0fa67cb735decc07988bf215701e22}{aws\+\_\+byte\+\_\+predicate\+\_\+fn}} $\ast$}]{predicate }\end{DoxyParamCaption})}

Shrinks a byte cursor from the left for as long as the supplied predicate is true \mbox{\Hypertarget{byte__buf_8c_a8500b18cf261cffbd69dec5f4dd698c1}\label{byte__buf_8c_a8500b18cf261cffbd69dec5f4dd698c1}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_next\_split@{aws\_byte\_cursor\_next\_split}}
\index{aws\_byte\_cursor\_next\_split@{aws\_byte\_cursor\_next\_split}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_next\_split()}{aws\_byte\_cursor\_next\_split()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+next\+\_\+split (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{input\+\_\+str,  }\item[{char}]{split\+\_\+on,  }\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{substr }\end{DoxyParamCaption})}

No copies, no buffer allocations. Iterates over input\+\_\+str, and returns the next substring between split\+\_\+on instances.

Edge case rules are as follows\+: If the input is an empty string, an empty cursor will be the one entry returned. If the input begins with split\+\_\+on, an empty cursor will be the first entry returned. If the input has two adjacent split\+\_\+on tokens, an empty cursor will be returned. If the input ends with split\+\_\+on, an empty cursor will be returned last.

It is the user\textquotesingle{}s responsibility zero-\/initialize substr before the first call.

It is the user\textquotesingle{}s responsibility to make sure the input buffer stays in memory long enough to use the results. \mbox{\Hypertarget{byte__buf_8c_a667d2681ddc208ee6c9145d93366c41d}\label{byte__buf_8c_a667d2681ddc208ee6c9145d93366c41d}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read@{aws\_byte\_cursor\_read}}
\index{aws\_byte\_cursor\_read@{aws\_byte\_cursor\_read}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read()}{aws\_byte\_cursor\_read()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{cur,  }\item[{void $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{dest,  }\item[{const size\+\_\+t}]{len }\end{DoxyParamCaption})}

Reads specified length of data from byte cursor and copies it to the destination array.

On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_af16de03a2ca7561f966a77e8c22e1877}\label{byte__buf_8c_af16de03a2ca7561f966a77e8c22e1877}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read\_and\_fill\_buffer@{aws\_byte\_cursor\_read\_and\_fill\_buffer}}
\index{aws\_byte\_cursor\_read\_and\_fill\_buffer@{aws\_byte\_cursor\_read\_and\_fill\_buffer}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read\_and\_fill\_buffer()}{aws\_byte\_cursor\_read\_and\_fill\_buffer()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+and\+\_\+fill\+\_\+buffer (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{cur,  }\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{dest }\end{DoxyParamCaption})}

Reads as many bytes from cursor as size of buffer, and copies them to buffer.

On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_aa8053828c7196b06a93ae486a5e996c7}\label{byte__buf_8c_aa8053828c7196b06a93ae486a5e996c7}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read\_be16@{aws\_byte\_cursor\_read\_be16}}
\index{aws\_byte\_cursor\_read\_be16@{aws\_byte\_cursor\_read\_be16}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read\_be16()}{aws\_byte\_cursor\_read\_be16()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+be16 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cur,  }\item[{uint16\+\_\+t $\ast$}]{var }\end{DoxyParamCaption})}

Reads a 16-\/bit value in network byte order from cur, and places it in host byte order into var.

On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_afeaca6f258268874e503eb1672eff64b}\label{byte__buf_8c_afeaca6f258268874e503eb1672eff64b}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read\_be24@{aws\_byte\_cursor\_read\_be24}}
\index{aws\_byte\_cursor\_read\_be24@{aws\_byte\_cursor\_read\_be24}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read\_be24()}{aws\_byte\_cursor\_read\_be24()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+be24 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cur,  }\item[{uint32\+\_\+t $\ast$}]{var }\end{DoxyParamCaption})}

Reads an unsigned 24-\/bit value (3 bytes) in network byte order from cur, and places it in host byte order into 32-\/bit var. Ex\+: if cur\textquotesingle{}s next 3 bytes are \{0x\+AA, 0x\+BB, 0x\+CC\}, then var becomes 0x00\+AABBCC.

On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_aa1da6b78bf530fdc1536abd48e4ef084}\label{byte__buf_8c_aa1da6b78bf530fdc1536abd48e4ef084}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read\_be32@{aws\_byte\_cursor\_read\_be32}}
\index{aws\_byte\_cursor\_read\_be32@{aws\_byte\_cursor\_read\_be32}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read\_be32()}{aws\_byte\_cursor\_read\_be32()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+be32 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cur,  }\item[{uint32\+\_\+t $\ast$}]{var }\end{DoxyParamCaption})}

Reads a 32-\/bit value in network byte order from cur, and places it in host byte order into var.

On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_a60ebd0319d386143460aebd349870761}\label{byte__buf_8c_a60ebd0319d386143460aebd349870761}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read\_be64@{aws\_byte\_cursor\_read\_be64}}
\index{aws\_byte\_cursor\_read\_be64@{aws\_byte\_cursor\_read\_be64}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read\_be64()}{aws\_byte\_cursor\_read\_be64()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+be64 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cur,  }\item[{uint64\+\_\+t $\ast$}]{var }\end{DoxyParamCaption})}

Reads a 64-\/bit value in network byte order from cur, and places it in host byte order into var.

On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_a33db95c91d74113e776e269b29b75d24}\label{byte__buf_8c_a33db95c91d74113e776e269b29b75d24}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read\_float\_be32@{aws\_byte\_cursor\_read\_float\_be32}}
\index{aws\_byte\_cursor\_read\_float\_be32@{aws\_byte\_cursor\_read\_float\_be32}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read\_float\_be32()}{aws\_byte\_cursor\_read\_float\_be32()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+float\+\_\+be32 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cur,  }\item[{float $\ast$}]{var }\end{DoxyParamCaption})}

Reads a 32-\/bit value in network byte order from cur, and places it in host byte order into var.

On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_a08b8d2d5abfa40c7d5da0d87889bb50c}\label{byte__buf_8c_a08b8d2d5abfa40c7d5da0d87889bb50c}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read\_float\_be64@{aws\_byte\_cursor\_read\_float\_be64}}
\index{aws\_byte\_cursor\_read\_float\_be64@{aws\_byte\_cursor\_read\_float\_be64}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read\_float\_be64()}{aws\_byte\_cursor\_read\_float\_be64()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+float\+\_\+be64 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cur,  }\item[{double $\ast$}]{var }\end{DoxyParamCaption})}

Reads a 64-\/bit value in network byte order from cur, and places it in host byte order into var.

On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_aba4686c6333f36ab47caa3032c4f5cd0}\label{byte__buf_8c_aba4686c6333f36ab47caa3032c4f5cd0}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read\_hex\_u8@{aws\_byte\_cursor\_read\_hex\_u8}}
\index{aws\_byte\_cursor\_read\_hex\_u8@{aws\_byte\_cursor\_read\_hex\_u8}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read\_hex\_u8()}{aws\_byte\_cursor\_read\_hex\_u8()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+hex\+\_\+u8 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cur,  }\item[{uint8\+\_\+t $\ast$}]{var }\end{DoxyParamCaption})}

Reads 2 hex characters from ASCII/\+UTF-\/8 text to produce an 8-\/bit number. Accepts both lowercase \textquotesingle{}a\textquotesingle{}-\/\textquotesingle{}f\textquotesingle{} and uppercase \textquotesingle{}A\textquotesingle{}-\/\textquotesingle{}F\textquotesingle{}. For example\+: \char`\"{}0\+F\char`\"{} produces 15.

On success, returns true and advances the cursor by 2. If there is insufficient space in the cursor or an invalid character is encountered, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_a571e1fa5c7a551535358f724dd40c7cb}\label{byte__buf_8c_a571e1fa5c7a551535358f724dd40c7cb}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_read\_u8@{aws\_byte\_cursor\_read\_u8}}
\index{aws\_byte\_cursor\_read\_u8@{aws\_byte\_cursor\_read\_u8}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_read\_u8()}{aws\_byte\_cursor\_read\_u8()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+read\+\_\+u8 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{cur,  }\item[{uint8\+\_\+t $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{var }\end{DoxyParamCaption})}

Reads a single byte from cursor, placing it in $\ast$var.

On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. \mbox{\Hypertarget{byte__buf_8c_a701ea769d956a8b45bb3bf3108e9ba60}\label{byte__buf_8c_a701ea769d956a8b45bb3bf3108e9ba60}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_right\_trim\_pred@{aws\_byte\_cursor\_right\_trim\_pred}}
\index{aws\_byte\_cursor\_right\_trim\_pred@{aws\_byte\_cursor\_right\_trim\_pred}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_right\_trim\_pred()}{aws\_byte\_cursor\_right\_trim\_pred()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+cursor\+\_\+right\+\_\+trim\+\_\+pred (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{source,  }\item[{\mbox{\hyperlink{byte__buf_8h_ace0fa67cb735decc07988bf215701e22}{aws\+\_\+byte\+\_\+predicate\+\_\+fn}} $\ast$}]{predicate }\end{DoxyParamCaption})}

Shrinks a byte cursor from the right for as long as the supplied predicate is true \mbox{\Hypertarget{byte__buf_8c_a0582daf1e0324e84c2eeddadbae49b76}\label{byte__buf_8c_a0582daf1e0324e84c2eeddadbae49b76}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_satisfies\_pred@{aws\_byte\_cursor\_satisfies\_pred}}
\index{aws\_byte\_cursor\_satisfies\_pred@{aws\_byte\_cursor\_satisfies\_pred}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_satisfies\_pred()}{aws\_byte\_cursor\_satisfies\_pred()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+cursor\+\_\+satisfies\+\_\+pred (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{source,  }\item[{\mbox{\hyperlink{byte__buf_8h_ace0fa67cb735decc07988bf215701e22}{aws\+\_\+byte\+\_\+predicate\+\_\+fn}} $\ast$}]{predicate }\end{DoxyParamCaption})}

Returns true if the byte cursor\textquotesingle{}s range of bytes all satisfy the predicate \mbox{\Hypertarget{byte__buf_8c_ac6ebbd786227e59a3aba25b8abe43d6e}\label{byte__buf_8c_ac6ebbd786227e59a3aba25b8abe43d6e}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_split\_on\_char@{aws\_byte\_cursor\_split\_on\_char}}
\index{aws\_byte\_cursor\_split\_on\_char@{aws\_byte\_cursor\_split\_on\_char}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_split\_on\_char()}{aws\_byte\_cursor\_split\_on\_char()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+cursor\+\_\+split\+\_\+on\+\_\+char (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{input\+\_\+str,  }\item[{char}]{split\+\_\+on,  }\item[{struct \mbox{\hyperlink{structaws__array__list}{aws\+\_\+array\+\_\+list}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{output }\end{DoxyParamCaption})}

No copies, no buffer allocations. Fills in output with a list of \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} instances where buffer is an offset into the input\+\_\+str and len is the length of that string in the original buffer.

Edge case rules are as follows\+: if the input begins with split\+\_\+on, an empty cursor will be the first entry in output. if the input has two adjacent split\+\_\+on tokens, an empty cursor will be inserted into the output. if the input ends with split\+\_\+on, an empty cursor will be appended to the output.

It is the user\textquotesingle{}s responsibility to properly initialize output. Recommended number of preallocated elements from output is your most likely guess for the upper bound of the number of elements resulting from the split.

The type that will be stored in output is struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} (you\textquotesingle{}ll need this for the item size param).

It is the user\textquotesingle{}s responsibility to make sure the input buffer stays in memory long enough to use the results. \mbox{\Hypertarget{byte__buf_8c_a49db4870532ddfadf616887d3fb2fed5}\label{byte__buf_8c_a49db4870532ddfadf616887d3fb2fed5}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_split\_on\_char\_n@{aws\_byte\_cursor\_split\_on\_char\_n}}
\index{aws\_byte\_cursor\_split\_on\_char\_n@{aws\_byte\_cursor\_split\_on\_char\_n}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_split\_on\_char\_n()}{aws\_byte\_cursor\_split\_on\_char\_n()}}
{\footnotesize\ttfamily int aws\+\_\+byte\+\_\+cursor\+\_\+split\+\_\+on\+\_\+char\+\_\+n (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{input\+\_\+str,  }\item[{char}]{split\+\_\+on,  }\item[{size\+\_\+t}]{n,  }\item[{struct \mbox{\hyperlink{structaws__array__list}{aws\+\_\+array\+\_\+list}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{output }\end{DoxyParamCaption})}

No copies, no buffer allocations. Fills in output with a list of \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} instances where buffer is an offset into the input\+\_\+str and len is the length of that string in the original buffer. N is the max number of splits, if this value is zero, it will add all splits to the output.

Edge case rules are as follows\+: if the input begins with split\+\_\+on, an empty cursor will be the first entry in output if the input has two adjacent split\+\_\+on tokens, an empty cursor will be inserted into the output. if the input ends with split\+\_\+on, an empty cursor will be appended to the output.

It is the user\textquotesingle{}s responsibility to properly initialize output. Recommended number of preallocated elements from output is your most likely guess for the upper bound of the number of elements resulting from the split.

If the output array is not large enough, input\+\_\+str will be updated to point to the first character after the last processed split\+\_\+on instance.

The type that will be stored in output is struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} (you\textquotesingle{}ll need this for the item size param).

It is the user\textquotesingle{}s responsibility to make sure the input buffer stays in memory long enough to use the results. \mbox{\Hypertarget{byte__buf_8c_a14a6efa66bf2efa66dd764c5b120129a}\label{byte__buf_8c_a14a6efa66bf2efa66dd764c5b120129a}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_byte\_cursor\_trim\_pred@{aws\_byte\_cursor\_trim\_pred}}
\index{aws\_byte\_cursor\_trim\_pred@{aws\_byte\_cursor\_trim\_pred}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_trim\_pred()}{aws\_byte\_cursor\_trim\_pred()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+cursor\+\_\+trim\+\_\+pred (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{source,  }\item[{\mbox{\hyperlink{byte__buf_8h_ace0fa67cb735decc07988bf215701e22}{aws\+\_\+byte\+\_\+predicate\+\_\+fn}} $\ast$}]{predicate }\end{DoxyParamCaption})}

Shrinks a byte cursor from both sides for as long as the supplied predicate is true \mbox{\Hypertarget{byte__buf_8c_ab2b52ce0371e324b33ec2006fe3207fa}\label{byte__buf_8c_ab2b52ce0371e324b33ec2006fe3207fa}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_hash\_array\_ignore\_case@{aws\_hash\_array\_ignore\_case}}
\index{aws\_hash\_array\_ignore\_case@{aws\_hash\_array\_ignore\_case}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_array\_ignore\_case()}{aws\_hash\_array\_ignore\_case()}}
{\footnotesize\ttfamily uint64\+\_\+t aws\+\_\+hash\+\_\+array\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const void $\ast$}]{array,  }\item[{const size\+\_\+t}]{len }\end{DoxyParamCaption})}

Case-\/insensitive hash function for array containing ASCII or UTF-\/8 text. \mbox{\Hypertarget{byte__buf_8c_a2bb583d1f274a5863b152cee4749bcc9}\label{byte__buf_8c_a2bb583d1f274a5863b152cee4749bcc9}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_hash\_byte\_cursor\_ptr\_ignore\_case@{aws\_hash\_byte\_cursor\_ptr\_ignore\_case}}
\index{aws\_hash\_byte\_cursor\_ptr\_ignore\_case@{aws\_hash\_byte\_cursor\_ptr\_ignore\_case}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_byte\_cursor\_ptr\_ignore\_case()}{aws\_hash\_byte\_cursor\_ptr\_ignore\_case()}}
{\footnotesize\ttfamily uint64\+\_\+t aws\+\_\+hash\+\_\+byte\+\_\+cursor\+\_\+ptr\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const void $\ast$}]{item }\end{DoxyParamCaption})}

Case-\/insensitive hash function for aws\+\_\+byte\+\_\+cursors stored in an \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}}. For case-\/sensitive hashing, use \mbox{\hyperlink{hash__table_8h_a54682fd811203b400867b9cb64c42acd}{aws\+\_\+hash\+\_\+byte\+\_\+cursor\+\_\+ptr()}}. \mbox{\Hypertarget{byte__buf_8c_ad0f48987b0892ebe2e376a6547ef6fa0}\label{byte__buf_8c_ad0f48987b0892ebe2e376a6547ef6fa0}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_isalnum@{aws\_isalnum}}
\index{aws\_isalnum@{aws\_isalnum}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_isalnum()}{aws\_isalnum()}}
{\footnotesize\ttfamily bool aws\+\_\+isalnum (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{ch }\end{DoxyParamCaption})}

Like isalnum(), but ignores C locale. Returns true if ch has the value of ASCII/\+UTF-\/8\+: \textquotesingle{}a\textquotesingle{}-\/\textquotesingle{}z\textquotesingle{}, \textquotesingle{}A\textquotesingle{}-\/\textquotesingle{}Z\textquotesingle{}, or \textquotesingle{}0\textquotesingle{}-\/\textquotesingle{}9\textquotesingle{}. \mbox{\Hypertarget{byte__buf_8c_a3aa4205568acb1986c0bf61a1795c7ac}\label{byte__buf_8c_a3aa4205568acb1986c0bf61a1795c7ac}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_isalpha@{aws\_isalpha}}
\index{aws\_isalpha@{aws\_isalpha}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_isalpha()}{aws\_isalpha()}}
{\footnotesize\ttfamily bool aws\+\_\+isalpha (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{ch }\end{DoxyParamCaption})}

Like isalpha(), but ignores C locale. Returns true if ch has the value of ASCII/\+UTF-\/8\+: \textquotesingle{}a\textquotesingle{}-\/\textquotesingle{}z\textquotesingle{} or \textquotesingle{}A\textquotesingle{}-\/\textquotesingle{}Z\textquotesingle{}. \mbox{\Hypertarget{byte__buf_8c_a193948a51fc6548d8de1bc5da56ea9c0}\label{byte__buf_8c_a193948a51fc6548d8de1bc5da56ea9c0}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_isdigit@{aws\_isdigit}}
\index{aws\_isdigit@{aws\_isdigit}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_isdigit()}{aws\_isdigit()}}
{\footnotesize\ttfamily bool aws\+\_\+isdigit (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{ch }\end{DoxyParamCaption})}

Like isdigit(). Returns true if ch has the value of ASCII/\+UTF-\/8\+: \textquotesingle{}0\textquotesingle{}-\/\textquotesingle{}9\textquotesingle{}.

Note\+: C\textquotesingle{}s built-\/in isdigit() is also supposed to ignore the C locale, but cppreference.\+com claims \char`\"{}some implementations (e.\+g. Microsoft in 1252 codepage) may classify additional single-\/byte characters as digits\char`\"{} \mbox{\Hypertarget{byte__buf_8c_ab7f620e2ee444abb2b32ce93be3085d4}\label{byte__buf_8c_ab7f620e2ee444abb2b32ce93be3085d4}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_isspace@{aws\_isspace}}
\index{aws\_isspace@{aws\_isspace}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_isspace()}{aws\_isspace()}}
{\footnotesize\ttfamily bool aws\+\_\+isspace (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{ch }\end{DoxyParamCaption})}

Like isspace(), but ignores C locale. Return true if ch has the value of ASCII/\+UTF-\/8\+: space (0x20), form feed (0x0C), line feed (0x0A), carriage return (0x0D), horizontal tab (0x09), or vertical tab (0x0B). \mbox{\Hypertarget{byte__buf_8c_a35764ea0c22877bb13898dbf1b930c98}\label{byte__buf_8c_a35764ea0c22877bb13898dbf1b930c98}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_isxdigit@{aws\_isxdigit}}
\index{aws\_isxdigit@{aws\_isxdigit}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_isxdigit()}{aws\_isxdigit()}}
{\footnotesize\ttfamily bool aws\+\_\+isxdigit (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{ch }\end{DoxyParamCaption})}

Like isxdigit(). Returns true if ch has the value of ASCII/\+UTF-\/8\+: \textquotesingle{}0\textquotesingle{}-\/\textquotesingle{}9\textquotesingle{}, \textquotesingle{}a\textquotesingle{}-\/\textquotesingle{}f\textquotesingle{}, or \textquotesingle{}A\textquotesingle{}-\/\textquotesingle{}F\textquotesingle{}.

Note\+: C\textquotesingle{}s built-\/in isxdigit() is also supposed to ignore the C locale, but cppreference.\+com claims \char`\"{}some implementations (e.\+g. Microsoft in 1252 codepage) may classify additional single-\/byte characters as digits\char`\"{} \mbox{\Hypertarget{byte__buf_8c_ad2393c6ee6236ff1b1adc0bfc9424257}\label{byte__buf_8c_ad2393c6ee6236ff1b1adc0bfc9424257}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_lookup\_table\_hex\_to\_num\_get@{aws\_lookup\_table\_hex\_to\_num\_get}}
\index{aws\_lookup\_table\_hex\_to\_num\_get@{aws\_lookup\_table\_hex\_to\_num\_get}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_lookup\_table\_hex\_to\_num\_get()}{aws\_lookup\_table\_hex\_to\_num\_get()}}
{\footnotesize\ttfamily const uint8\+\_\+t$\ast$ aws\+\_\+lookup\+\_\+table\+\_\+hex\+\_\+to\+\_\+num\+\_\+get (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Returns lookup table to go from ASCII/\+UTF-\/8 hex character to a number (0-\/15). Non-\/hex characters map to 255. Valid examples\+: \textquotesingle{}0\textquotesingle{} -\/\texorpdfstring{$>$}{>} 0 \textquotesingle{}F\textquotesingle{} -\/\texorpdfstring{$>$}{>} 15 \textquotesingle{}f\textquotesingle{} -\/\texorpdfstring{$>$}{>} 15 Invalid examples\+: \textquotesingle{} \textquotesingle{} -\/\texorpdfstring{$>$}{>} 255 \textquotesingle{}Z\textquotesingle{} -\/\texorpdfstring{$>$}{>} 255 \textquotesingle{}\textbackslash{}0\textquotesingle{} -\/\texorpdfstring{$>$}{>} 255 \mbox{\Hypertarget{byte__buf_8c_af1fe4a204cae799ed595d635d9979590}\label{byte__buf_8c_af1fe4a204cae799ed595d635d9979590}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_lookup\_table\_to\_lower\_get@{aws\_lookup\_table\_to\_lower\_get}}
\index{aws\_lookup\_table\_to\_lower\_get@{aws\_lookup\_table\_to\_lower\_get}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_lookup\_table\_to\_lower\_get()}{aws\_lookup\_table\_to\_lower\_get()}}
{\footnotesize\ttfamily const uint8\+\_\+t$\ast$ aws\+\_\+lookup\+\_\+table\+\_\+to\+\_\+lower\+\_\+get (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Returns a lookup table for bytes that is the identity transformation with the exception of uppercase ascii characters getting replaced with lowercase characters. Used in caseless comparisons. \mbox{\Hypertarget{byte__buf_8c_a877b6197e84a8a1671549cda787236d7}\label{byte__buf_8c_a877b6197e84a8a1671549cda787236d7}} 
\index{byte\_buf.c@{byte\_buf.c}!aws\_nospec\_mask@{aws\_nospec\_mask}}
\index{aws\_nospec\_mask@{aws\_nospec\_mask}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{aws\_nospec\_mask()}{aws\_nospec\_mask()}}
{\footnotesize\ttfamily size\+\_\+t aws\+\_\+nospec\+\_\+mask (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{index,  }\item[{size\+\_\+t}]{bound }\end{DoxyParamCaption})}

If index \texorpdfstring{$>$}{>}= bound, bound \texorpdfstring{$>$}{>} (SIZE\+\_\+\+MAX / 2), or index \texorpdfstring{$>$}{>} (SIZE\+\_\+\+MAX / 2), returns 0. Otherwise, returns UINTPTR\+\_\+\+MAX. This function is designed to return the correct value even under CPU speculation conditions, and is intended to be used for SPECTRE mitigation purposes. \mbox{\Hypertarget{byte__buf_8c_af7741579301dfe24b74938c1e34f0729}\label{byte__buf_8c_af7741579301dfe24b74938c1e34f0729}} 
\index{byte\_buf.c@{byte\_buf.c}!AWS\_STATIC\_ASSERT@{AWS\_STATIC\_ASSERT}}
\index{AWS\_STATIC\_ASSERT@{AWS\_STATIC\_ASSERT}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{AWS\_STATIC\_ASSERT()}{AWS\_STATIC\_ASSERT()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily AWS\+\_\+\+STATIC\+\_\+\+ASSERT (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{macros_8h_a7b837cfd09e209fa32b1129f8bc9c431}{AWS\+\_\+\+ARRAY\+\_\+\+SIZE}}(\mbox{\hyperlink{byte__buf_8c_a153765cf45f5be0abaeb4b946bb3e816}{s\+\_\+hex\+\_\+to\+\_\+num\+\_\+table}})}]{ = {\ttfamily =256} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{byte__buf_8c_af9e2f9f9e603d6d21aceba0cccb77bb9}\label{byte__buf_8c_af9e2f9f9e603d6d21aceba0cccb77bb9}} 
\index{byte\_buf.c@{byte\_buf.c}!AWS\_STATIC\_ASSERT@{AWS\_STATIC\_ASSERT}}
\index{AWS\_STATIC\_ASSERT@{AWS\_STATIC\_ASSERT}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{AWS\_STATIC\_ASSERT()}{AWS\_STATIC\_ASSERT()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily AWS\+\_\+\+STATIC\+\_\+\+ASSERT (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{macros_8h_a7b837cfd09e209fa32b1129f8bc9c431}{AWS\+\_\+\+ARRAY\+\_\+\+SIZE}}(\mbox{\hyperlink{byte__buf_8c_a44397e404df152393bd3201025f462ef}{s\+\_\+tolower\+\_\+table}})}]{ = {\ttfamily =256} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{byte__buf_8c_a8af92432cfe7cc34703f62e15cc3283b}\label{byte__buf_8c_a8af92432cfe7cc34703f62e15cc3283b}} 
\index{byte\_buf.c@{byte\_buf.c}!s\_aws\_byte\_buf\_append\_byte\_dynamic@{s\_aws\_byte\_buf\_append\_byte\_dynamic}}
\index{s\_aws\_byte\_buf\_append\_byte\_dynamic@{s\_aws\_byte\_buf\_append\_byte\_dynamic}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{s\_aws\_byte\_buf\_append\_byte\_dynamic()}{s\_aws\_byte\_buf\_append\_byte\_dynamic()}}
{\footnotesize\ttfamily static int s\+\_\+aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+byte\+\_\+dynamic (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buffer,  }\item[{uint8\+\_\+t}]{value,  }\item[{bool}]{clear\+\_\+released\+\_\+memory }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{byte__buf_8c_aec56ee1008054c5a0aee809cc324e330}\label{byte__buf_8c_aec56ee1008054c5a0aee809cc324e330}} 
\index{byte\_buf.c@{byte\_buf.c}!s\_aws\_byte\_buf\_append\_dynamic@{s\_aws\_byte\_buf\_append\_dynamic}}
\index{s\_aws\_byte\_buf\_append\_dynamic@{s\_aws\_byte\_buf\_append\_dynamic}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{s\_aws\_byte\_buf\_append\_dynamic()}{s\_aws\_byte\_buf\_append\_dynamic()}}
{\footnotesize\ttfamily static int s\+\_\+aws\+\_\+byte\+\_\+buf\+\_\+append\+\_\+dynamic (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{to,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{from,  }\item[{bool}]{clear\+\_\+released\+\_\+memory }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{byte__buf_8c_a153765cf45f5be0abaeb4b946bb3e816}\label{byte__buf_8c_a153765cf45f5be0abaeb4b946bb3e816}} 
\index{byte\_buf.c@{byte\_buf.c}!s\_hex\_to\_num\_table@{s\_hex\_to\_num\_table}}
\index{s\_hex\_to\_num\_table@{s\_hex\_to\_num\_table}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{s\_hex\_to\_num\_table}{s\_hex\_to\_num\_table}}
{\footnotesize\ttfamily const uint8\+\_\+t s\+\_\+hex\+\_\+to\+\_\+num\+\_\+table\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{= \{}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    255, 255,}
\DoxyCodeLine{    }
\DoxyCodeLine{    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    }
\DoxyCodeLine{    0xA, 0xB, 0xC, 0xD, 0xE, 0xF,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    255, 255, 255,}
\DoxyCodeLine{    }
\DoxyCodeLine{    0xa, 0xb, 0xc, 0xd, 0xe, 0xf,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,}
\DoxyCodeLine{\}}

\end{DoxyCode}
\mbox{\Hypertarget{byte__buf_8c_acdf3d480fa71f545a92518909855bab2}\label{byte__buf_8c_acdf3d480fa71f545a92518909855bab2}} 
\index{byte\_buf.c@{byte\_buf.c}!s\_null\_terminator\_cursor@{s\_null\_terminator\_cursor}}
\index{s\_null\_terminator\_cursor@{s\_null\_terminator\_cursor}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{s\_null\_terminator\_cursor}{s\_null\_terminator\_cursor}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} s\+\_\+null\+\_\+terminator\+\_\+cursor = \mbox{\hyperlink{byte__buf_8h_a25bb15426b081484f79b35669fc81b90}{AWS\+\_\+\+BYTE\+\_\+\+CUR\+\_\+\+INIT\+\_\+\+FROM\+\_\+\+STRING\+\_\+\+LITERAL}}(\char`\"{}\textbackslash{}0\char`\"{})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{byte__buf_8c_a44397e404df152393bd3201025f462ef}\label{byte__buf_8c_a44397e404df152393bd3201025f462ef}} 
\index{byte\_buf.c@{byte\_buf.c}!s\_tolower\_table@{s\_tolower\_table}}
\index{s\_tolower\_table@{s\_tolower\_table}!byte\_buf.c@{byte\_buf.c}}
\doxysubsubsection{\texorpdfstring{s\_tolower\_table}{s\_tolower\_table}}
{\footnotesize\ttfamily const uint8\+\_\+t s\+\_\+tolower\+\_\+table\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{= \{}
\DoxyCodeLine{    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,}
\DoxyCodeLine{    22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,}
\DoxyCodeLine{    44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  \textcolor{charliteral}{'a'},}
\DoxyCodeLine{    \textcolor{charliteral}{'b'}, \textcolor{charliteral}{'c'}, \textcolor{charliteral}{'d'}, \textcolor{charliteral}{'e'}, \textcolor{charliteral}{'f'}, \textcolor{charliteral}{'g'}, \textcolor{charliteral}{'h'}, \textcolor{charliteral}{'i'}, \textcolor{charliteral}{'j'}, \textcolor{charliteral}{'k'}, \textcolor{charliteral}{'l'}, \textcolor{charliteral}{'m'}, \textcolor{charliteral}{'n'}, \textcolor{charliteral}{'o'}, \textcolor{charliteral}{'p'}, \textcolor{charliteral}{'q'}, \textcolor{charliteral}{'r'}, \textcolor{charliteral}{'s'}, \textcolor{charliteral}{'t'}, \textcolor{charliteral}{'u'}, \textcolor{charliteral}{'v'}, \textcolor{charliteral}{'w'},}
\DoxyCodeLine{    \textcolor{charliteral}{'x'}, \textcolor{charliteral}{'y'}, \textcolor{charliteral}{'z'}, 91,  92,  93,  94,  95,  96,  \textcolor{charliteral}{'a'}, \textcolor{charliteral}{'b'}, \textcolor{charliteral}{'c'}, \textcolor{charliteral}{'d'}, \textcolor{charliteral}{'e'}, \textcolor{charliteral}{'f'}, \textcolor{charliteral}{'g'}, \textcolor{charliteral}{'h'}, \textcolor{charliteral}{'i'}, \textcolor{charliteral}{'j'}, \textcolor{charliteral}{'k'}, \textcolor{charliteral}{'l'}, \textcolor{charliteral}{'m'},}
\DoxyCodeLine{    \textcolor{charliteral}{'n'}, \textcolor{charliteral}{'o'}, \textcolor{charliteral}{'p'}, \textcolor{charliteral}{'q'}, \textcolor{charliteral}{'r'}, \textcolor{charliteral}{'s'}, \textcolor{charliteral}{'t'}, \textcolor{charliteral}{'u'}, \textcolor{charliteral}{'v'}, \textcolor{charliteral}{'w'}, \textcolor{charliteral}{'x'}, \textcolor{charliteral}{'y'}, \textcolor{charliteral}{'z'}, 123, 124, 125, 126, 127, 128, 129, 130, 131,}
\DoxyCodeLine{    132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,}
\DoxyCodeLine{    154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,}
\DoxyCodeLine{    176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,}
\DoxyCodeLine{    198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,}
\DoxyCodeLine{    220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,}
\DoxyCodeLine{    242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255\}}

\end{DoxyCode}
