We verified the C implementation of the Supersingular Isogeny Key Encapsulation (SIKE) algorithm using the SAW tool and Cryptol language. Due to the complexity of SIKE, we applied different verification approaches for different portions of the code. These provide varying levels of assurance, i.\+e. they each rule out specific categories of errors in the code\+:\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md575}{}\doxysubsection{Approaches}\label{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md575}

\begin{DoxyItemize}
\item Approach 1 (strongest)\+: verification of the mathematical behaviour of the code and the operational behaviour of the code,guaranteeing the absence of program errors.
\item Approach 2\+: verification of the operational behaviour of the code, guaranteeing the absence of program errors.
\item Approach 3 (weakest)\+: verification of operational behaviour with additional simplifying assumptions, for example bounding the size of inputs or iterations in a loop. We applied these approaches so as to maximize the assurance we achieved with the time / resources available. We also omitted a very small number of functions as a result of limitations in our verification tools.
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md576}{}\doxysubsection{Organization}\label{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md576}
\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md577}{}\doxysubsubsection{By mathematical concept and SIKE file}\label{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md577}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ \#   }&\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Approach   }&\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ SIKE file   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Cryptol Specification   }&\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ SAW Proof    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ \#   }&\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Approach   }&\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ SIKE file   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Cryptol Specification   }&\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ SAW Proof    }\\\cline{1-6}
\endhead
\PBS\raggedleft 1   &\PBS\raggedleft Base math operations   &1   &\PBS\raggedleft config.\+h   &\PBS\centering fp\+\_\+generic.\+cry \& fpx.\+cry   &\PBS\raggedleft word.\+saw    \\\cline{1-6}
\PBS\raggedleft 2   &\PBS\raggedleft Low-\/level field operators (fp)   &1   &\PBS\raggedleft fp\+\_\+generic.\+c   &\PBS\centering fp\+\_\+generic.\+cry   &\PBS\raggedleft field.\+saw \& word.\+saw    \\\cline{1-6}
\PBS\raggedleft 3   &\PBS\raggedleft Higher-\/level field operators (fp2)   &1   &\PBS\raggedleft \mbox{\hyperlink{fpx_8c}{fpx.\+c}}   &\PBS\centering fpx.\+cry   &\PBS\raggedleft field.\+saw \& word.\+saw    \\\cline{1-6}
\PBS\raggedleft 4   &\PBS\raggedleft CShake   &1   &\PBS\raggedleft flips202.\+c   &\PBS\centering Keccak.\+cry   &\PBS\raggedleft cshake.\+saw    \\\cline{1-6}
\PBS\raggedleft 5   &\PBS\raggedleft Isogeny Functions   &2\&3   &\PBS\raggedleft \mbox{\hyperlink{ec__isogeny_8c}{ec\+\_\+isogeny.\+c}}   &\PBS\centering ec\+\_\+isogeny.\+cry   &\PBS\raggedleft curv.\+saw \& isogeny.\+saw    \\\cline{1-6}
\PBS\raggedleft 6   &\PBS\raggedleft Key generation and encoding   &2\&3   &\PBS\raggedleft \mbox{\hyperlink{sidh_8c}{sidh.\+c}}   &\PBS\centering sidh.\+cry   &\PBS\raggedleft word.\+saw \& sidh.\+saw    \\\cline{1-6}
\PBS\raggedleft 7   &\PBS\raggedleft SIKE top-\/level   &2   &\PBS\raggedleft sike.\+c   &\PBS\centering sike.\+cry   &\PBS\raggedleft sike.\+saw   \\\cline{1-6}
\end{longtabu}


To be read as,
\begin{DoxyEnumerate}
\item We verified the mathematical behaviour and the operational behaviour of the code (approach 1) that implements base mathematical operations. Specifically, the functions defined in config.\+h, are modeleled in fpx.\+cry and fp\+\_\+generic.\+cry and verified with proofs defined in word.\+saw.
\item We verified the mathematical behaviour and the operational behaviour of the code (approach 1) that implements low-\/level field operators. Specifically, the functions defined in fp\+\_\+generic.\+c are modeleled in fp\+\_\+generic.\+cry and verified with proofs defined in field.\+saw and word.\+saw.
\item We verified the mathematical behaviour and the operational behaviour of the code (approach 1) that implements low-\/level field operators. Specifically, the functions defined in \mbox{\hyperlink{fpx_8c}{fpx.\+c}}, are modeleled in fpx.\+cry and verified with proofs defined in field.\+saw and word.\+saw.
\item We verified the mathematical behaviour and the operational behaviour of the code (approach 1) that implements CSHAKE operations. Specifically, the functions defined in flips202.\+c, are modeleled in Keccak.\+cry and verified with proofs defined in cshake.\+saw.
\item We verified the operational behaviour with additional simplifying assumptions, of the code that implements the isogeny functions. Specifically, the functions defined in \mbox{\hyperlink{ec__isogeny_8c}{ec\+\_\+isogeny.\+c}}, are modeleled in ec\+\_\+isogeny.\+cry and verified with proofs defined in curv.\+saw and isogeny.\+saw. A handful of functions ({\ttfamily ladder3pt}, {\ttfamily x\+DBLe}, {\ttfamily x\+TPLe}) required additional simplifying assumptions (approach 3) due to unbounded loops and large iterations, but the rest of the functions ({\ttfamily get\+\_\+3\+\_\+isog},{\ttfamily x\+DBLADD},...) did not require those assumptions (approach 2).
\item We verified the operational behaviour with additional simplifying assumptions, of the code that implements the key generation and encoding algorithms. Specifically, the functions defined in \mbox{\hyperlink{sidh_8c}{sidh.\+c}}, are modeleled in sidh.\+cry and verified with proofs defined in word.\+saw and sidh.\+saw. A handful of functions ({\ttfamily Ephemeral\+Key\+Generation\+\_\+A}, {\ttfamily Ephemeral\+Key\+Generation\+\_\+B}, {\ttfamily Ephemeral\+Secret\+Agreement\+\_\+A},and {\ttfamily Ephemeral\+Secret\+Agreement\+\_\+B}) required additional simplifying assumptions (approach 3) due to unbounded loops and large iterations, but the rest of the functions ({\ttfamily fp2\+\_\+encode\+\_\+ov},{\ttfamily init\+\_\+basis\+\_\+ov},...) did not require those assumptions (approach 2).
\begin{DoxyEnumerate}
\item We verified the operational behaviour of the code that implements the top-\/level SIKE functions. Specifically, the functions defined in sike.\+c, are modeleled in sike.\+cry and verified with proofs defined in sike.\+saw. ~\newline
 
\end{DoxyEnumerate}
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md578}{}\doxysubsubsection{By directory}\label{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md578}

\begin{DoxyItemize}
\item /proof\+: SAWscript proofs
\item /spec\+: Cryptol code to represent SIKE algorithm
\item /spec/interface\+: Communicates directly by Sawscript
\item /spec/abstract\+\_\+spec\+: Represents the formal specification closely
\item /spec/include \+: CShake file
\item /spec/lib \+: Math operations, Type definitions, and Utility functions.
\item /spec/shared \+: Constants and Types defined for the interface
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md579}{}\doxysubsubsection{Changes to the C Code\+:}\label{md_crt_aws_crt_cpp_crt_s2n_tests_saw_sike_r1__r_e_a_d_m_e_autotoc_md579}
SAW is not currently able to effectively generate symbolic representations of computations of a large scale. As a result, we occasionally need to decrease the number of iterations we prove correct. The Sidh functions {\ttfamily Ephemeral\+Key\+Generation\+\_\+A}, {\ttfamily Ephemeral\+Key\+Generation\+\_\+B}, {\ttfamily Ephemeral\+Secret\+Agreement\+\_\+A},and {\ttfamily Ephemeral\+Secret\+Agreement\+\_\+B} have loops statically bound to a large number of iterations. For these function we modified the C code to bound the for-\/loop to an input variable and then verified the function for a set of fixed sizes. The code was modified, by replacing the constant upper-\/bounds ( {\ttfamily MAX\+\_\+\+Alice}) with an input parameter ({\ttfamily F1}). 