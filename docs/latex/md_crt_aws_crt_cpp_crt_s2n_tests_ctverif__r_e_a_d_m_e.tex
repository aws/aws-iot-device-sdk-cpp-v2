This repository contains tests which ensure that key s2n functions are not susceptible to timing attacks and are indeed constant time.

For more details, see \href{https://github.com/awslabs/s2n/issues/463}{\texttt{ https\+://github.\+com/awslabs/s2n/issues/463}}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md530}{}\doxysection{What are timing side channels}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md530}
Crypographic protocols such as TLS are supposed to keep secret information secret. They do this by ensuring that WHICH bytes go over the wire is hidden using encryption. However, if the code is not carefully written, WHEN bytes go over the wire may depend on values that were supposed to remain secret.

For example, if code checks a password as follows


\begin{DoxyCode}{0}
\DoxyCodeLine{for (i = 0; i < length; ++i) \{}
\DoxyCodeLine{  if password[i] != input[i] \{}
\DoxyCodeLine{    send("{}bad password"{});}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 then the amount of time until the reply message is received will depend on which byte in the password is incorrect. An attacker can simply guess
\begin{DoxyItemize}
\item a$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$
\item b$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$
\item c$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$
\end{DoxyItemize}

until the time to receive the error message changes, and then they know the first letter in the password. Repeating for the remaining characters turns an exponential guessing challenge into a linear one.

There are two major ways that timing side channels appear in code\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md531}{}\doxysubsection{Branches that depend on secret data}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md531}
In this case, the program may execute more code, and hence take more time, in one branch than another. The password example above is a branch based timing side-\/channel.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md532}{}\doxysubsection{Memory accesses that depend on secret data}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md532}
In this case, if one memory location is in cache, while another is not, there will be a detectable delay fetching the location from main memory. For example, an AES computation that uses software lookup tables can leak the secret key over the network based on cache timing \href{https://cr.yp.to/antiforgery/cachetiming-20050414.pdf}{\texttt{ https\+://cr.\+yp.\+to/antiforgery/cachetiming-\/20050414.\+pdf}}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md533}{}\doxysubsection{The implication}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md533}
The runtime of code should not depend on the value of secret data, and therefore, cryptographic code should ensure that
\begin{DoxyEnumerate}
\item No branch depends on secret data
\item No memory access depends on secret data
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md534}{}\doxysection{The tests}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md534}
Currently, we have constant-\/time proofs of two functions from utils/s2n\+\_\+safety.\+c
\begin{DoxyEnumerate}
\item s2n\+\_\+constant\+\_\+time\+\_\+equals
\item s2n\+\_\+constant\+\_\+time\+\_\+copy\+\_\+or\+\_\+dont
\end{DoxyEnumerate}

A proof proceeds in the following steps\+:
\begin{DoxyEnumerate}
\item Annotate public inputs using \mbox{\hyperlink{ctverif_2s2n__annotations_8h_a82b5a2764625cc3f652354d7ded65476}{S2\+N\+\_\+\+PUBLIC\+\_\+\+INPUT()}}. All other inputs are assumed to be private
\item Use the ct-\/verif tool, which compiles the program into the Boogie intermediate representation, and adds assertions that\+:
\begin{DoxyEnumerate}
\item No branch depends on secret data
\item No memory access depends on secret data
\end{DoxyEnumerate}
\item Use the Boogie program-\/analysis framework to convert the code under test into an SMT formula
\item Use the z3 prover to prove that either\+:
\begin{DoxyItemize}
\item None of the assertions can be violated (in which case the code is constant time) OR
\item Some of the assertions can be violated, in which case the code is not guaranteed to be constant time.
\end{DoxyItemize}
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md535}{}\doxysection{How to execute the tests}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md535}
\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md536}{}\doxysubsection{Install the dependencies}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md536}
Running these tests will require the following dependencies (tested on Ubuntu 14.\+04). To see how to install this on a clean ubuntu machine, take a look at the .travis scripts in this repo.


\begin{DoxyItemize}
\item ct-\/verif (available from \href{https://github.com/imdea-software/verifying-constant-time/}{\texttt{ https\+://github.\+com/imdea-\/software/verifying-\/constant-\/time/}})
\begin{DoxyItemize}
\item Export its base directory as \$\+CTVERIF\+\_\+\+DIR
\end{DoxyItemize}
\item SMACK and all its dependencies
\begin{DoxyItemize}
\item The easiest way to get these is to use the build.\+sh in smack/bin
\item Ensure that all of the installed depencies are on the \$\+PATH
\item source the smack.\+environment that the smack build script creates
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md537}{}\doxysubsection{Move the code you want to test into place}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md537}

\begin{DoxyCode}{0}
\DoxyCodeLine{cp ../../utils/s2n\_safety.c .}

\end{DoxyCode}
 \hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md538}{}\doxysubsection{Execute the test}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md538}

\begin{DoxyCode}{0}
\DoxyCodeLine{make clean}
\DoxyCodeLine{EXPECTED\_PASS=2}
\DoxyCodeLine{EXPECTED\_FAIL=0}
\DoxyCodeLine{make 2>\&1 | ./count\_success.pl \$EXPECTED\_PASS \$EXPECTED\_FAIL}

\end{DoxyCode}


If both tests pass, you will see 
\begin{DoxyCode}{0}
\DoxyCodeLine{verified: 2 errors: 0 as expected}

\end{DoxyCode}


If not all tests pass, you will see a message like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ERROR:  Expected verified: 2    errors: 0.}
\DoxyCodeLine{        Got      verified: 1    errors: 1.}

\end{DoxyCode}
\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md539}{}\doxysection{Questions?}\label{md_crt_aws_crt_cpp_crt_s2n_tests_ctverif__r_e_a_d_m_e_autotoc_md539}
contact \href{mailto:dsn@amazon.com}{\texttt{ dsn@amazon.\+com}} 