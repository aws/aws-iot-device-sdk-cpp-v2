\hypertarget{proof__allocators_8h}{}\doxysection{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/verification/cbmc/include/proof\+\_\+helpers/proof\+\_\+allocators.h File Reference}
\label{proof__allocators_8h}\index{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/verification/cbmc/include/proof\_helpers/proof\_allocators.h@{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/verification/cbmc/include/proof\_helpers/proof\_allocators.h}}
{\ttfamily \#include $<$aws/common/common.\+h$>$}\newline
{\ttfamily \#include $<$proof\+\_\+helpers/nondet.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{proof__allocators_8h_aaa791eb9a3f067c6a24c70626bddcc66}{MAX\+\_\+\+MALLOC}}~(SIZE\+\_\+\+MAX $>$$>$ (CBMC\+\_\+\+OBJECT\+\_\+\+BITS + 1))
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8h_aef817d036f3a738bc0a9421516367200}{bounded\+\_\+calloc}} (size\+\_\+t num, size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8h_ab3dbc7b96e0fac4e1caa23b4c365bd7c}{bounded\+\_\+malloc}} (size\+\_\+t size)
\item 
struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$ \mbox{\hyperlink{proof__allocators_8h_a7a9308e08c67eda215f3760da5b7b407}{can\+\_\+fail\+\_\+allocator}} ()
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8h_a1155485865621f39fac3967ce334123c}{can\+\_\+fail\+\_\+calloc}} (size\+\_\+t num, size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8h_aaa127ec3bf84bdf0e9274082aa3c7354}{can\+\_\+fail\+\_\+malloc}} (size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8h_a02f33782e5f8451ec09e3ea847a89368}{can\+\_\+fail\+\_\+realloc}} (void $\ast$ptr, size\+\_\+t newsize)
\end{DoxyCompactItemize}


\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{proof__allocators_8h_aaa791eb9a3f067c6a24c70626bddcc66}\label{proof__allocators_8h_aaa791eb9a3f067c6a24c70626bddcc66}} 
\index{proof\_allocators.h@{proof\_allocators.h}!MAX\_MALLOC@{MAX\_MALLOC}}
\index{MAX\_MALLOC@{MAX\_MALLOC}!proof\_allocators.h@{proof\_allocators.h}}
\doxysubsubsection{\texorpdfstring{MAX\_MALLOC}{MAX\_MALLOC}}
{\footnotesize\ttfamily \#define MAX\+\_\+\+MALLOC~(SIZE\+\_\+\+MAX $>$$>$ (CBMC\+\_\+\+OBJECT\+\_\+\+BITS + 1))}

Copyright Amazon.\+com, Inc. or its affiliates. All Rights Reserved. SPDX-\/\+License-\/\+Identifier\+: Apache-\/2.\+0. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{proof__allocators_8h_aef817d036f3a738bc0a9421516367200}\label{proof__allocators_8h_aef817d036f3a738bc0a9421516367200}} 
\index{proof\_allocators.h@{proof\_allocators.h}!bounded\_calloc@{bounded\_calloc}}
\index{bounded\_calloc@{bounded\_calloc}!proof\_allocators.h@{proof\_allocators.h}}
\doxysubsubsection{\texorpdfstring{bounded\_calloc()}{bounded\_calloc()}}
{\footnotesize\ttfamily void$\ast$ bounded\+\_\+calloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{num,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of calloc always succeeds, even if the requested size is larger than CBMC can internally represent. This function does a \+\_\+\+\_\+\+CPROVER\+\_\+assume(size \texorpdfstring{$<$}{<}= MAX\+\_\+\+MALLOC); before calling calloc, and hence will never return an invalid pointer. \mbox{\Hypertarget{proof__allocators_8h_ab3dbc7b96e0fac4e1caa23b4c365bd7c}\label{proof__allocators_8h_ab3dbc7b96e0fac4e1caa23b4c365bd7c}} 
\index{proof\_allocators.h@{proof\_allocators.h}!bounded\_malloc@{bounded\_malloc}}
\index{bounded\_malloc@{bounded\_malloc}!proof\_allocators.h@{proof\_allocators.h}}
\doxysubsubsection{\texorpdfstring{bounded\_malloc()}{bounded\_malloc()}}
{\footnotesize\ttfamily void$\ast$ bounded\+\_\+malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of malloc always succeeds, even if the requested size is larger than CBMC can internally represent. This function does a \+\_\+\+\_\+\+CPROVER\+\_\+assume(size \texorpdfstring{$<$}{<}= MAX\+\_\+\+MALLOC); before calling malloc, and hence will never return an invalid pointer. \mbox{\Hypertarget{proof__allocators_8h_a7a9308e08c67eda215f3760da5b7b407}\label{proof__allocators_8h_a7a9308e08c67eda215f3760da5b7b407}} 
\index{proof\_allocators.h@{proof\_allocators.h}!can\_fail\_allocator@{can\_fail\_allocator}}
\index{can\_fail\_allocator@{can\_fail\_allocator}!proof\_allocators.h@{proof\_allocators.h}}
\doxysubsubsection{\texorpdfstring{can\_fail\_allocator()}{can\_fail\_allocator()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}}$\ast$ can\+\_\+fail\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Implemenation of \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} specalized to allow CBMC to find as many bugs as possible \mbox{\Hypertarget{proof__allocators_8h_a1155485865621f39fac3967ce334123c}\label{proof__allocators_8h_a1155485865621f39fac3967ce334123c}} 
\index{proof\_allocators.h@{proof\_allocators.h}!can\_fail\_calloc@{can\_fail\_calloc}}
\index{can\_fail\_calloc@{can\_fail\_calloc}!proof\_allocators.h@{proof\_allocators.h}}
\doxysubsubsection{\texorpdfstring{can\_fail\_calloc()}{can\_fail\_calloc()}}
{\footnotesize\ttfamily void$\ast$ can\+\_\+fail\+\_\+calloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{num,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of calloc never returns NULL, which can mask bugs in C programs. Thus function\+: 1) Deterministically returns NULL if more memory is requested than CBMC can represent 2) Nondeterminstically returns either valid memory or NULL otherwise \mbox{\Hypertarget{proof__allocators_8h_aaa127ec3bf84bdf0e9274082aa3c7354}\label{proof__allocators_8h_aaa127ec3bf84bdf0e9274082aa3c7354}} 
\index{proof\_allocators.h@{proof\_allocators.h}!can\_fail\_malloc@{can\_fail\_malloc}}
\index{can\_fail\_malloc@{can\_fail\_malloc}!proof\_allocators.h@{proof\_allocators.h}}
\doxysubsubsection{\texorpdfstring{can\_fail\_malloc()}{can\_fail\_malloc()}}
{\footnotesize\ttfamily void$\ast$ can\+\_\+fail\+\_\+malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of malloc never returns NULL, which can mask bugs in C programs. Thus function\+: 1) Deterministically returns NULL if more memory is requested than CBMC can represent 2) Nondeterminstically returns either valid memory or NULL otherwise \mbox{\Hypertarget{proof__allocators_8h_a02f33782e5f8451ec09e3ea847a89368}\label{proof__allocators_8h_a02f33782e5f8451ec09e3ea847a89368}} 
\index{proof\_allocators.h@{proof\_allocators.h}!can\_fail\_realloc@{can\_fail\_realloc}}
\index{can\_fail\_realloc@{can\_fail\_realloc}!proof\_allocators.h@{proof\_allocators.h}}
\doxysubsubsection{\texorpdfstring{can\_fail\_realloc()}{can\_fail\_realloc()}}
{\footnotesize\ttfamily void$\ast$ can\+\_\+fail\+\_\+realloc (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr,  }\item[{size\+\_\+t}]{newsize }\end{DoxyParamCaption})}

CBMC model of realloc never returns NULL, which can mask bugs in C programs. Thus function\+: 1) Deterministically returns NULL if more memory is requested than CBMC can represent 2) Does the full range of valid behaviours if (newsize == 0) 3) Nondeterminstically returns either valid memory or NULL otherwise

\href{https://en.cppreference.com/w/c/memory/realloc}{\texttt{ https\+://en.\+cppreference.\+com/w/c/memory/realloc}} If there is not enough memory, the old memory block is not freed and null pointer is returned.

If ptr is NULL, the behavior is the same as calling malloc(new\+\_\+size).

If new\+\_\+size is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-\/null pointer may be returned that may not be used to access storage). 