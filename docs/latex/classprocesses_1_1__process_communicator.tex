\hypertarget{classprocesses_1_1__process_communicator}{}\doxysection{processes.\+\_\+process\+Communicator Class Reference}
\label{classprocesses_1_1__process_communicator}\index{processes.\_processCommunicator@{processes.\_processCommunicator}}
Inheritance diagram for processes.\+\_\+process\+Communicator\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classprocesses_1_1__process_communicator}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{classprocesses_1_1__process_communicator_acd696f42ce1ace31bc9c923aee051122}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, \mbox{\hyperlink{classprocesses_1_1__process_communicator_a3ac788eb36702ab023d9cfff4dbbe0af}{proc}})
\item 
def \mbox{\hyperlink{classprocesses_1_1__process_communicator_a0029d5a594a5012948325a1098057fb8}{wait\+\_\+for}} (self, \mbox{\hyperlink{classprocesses_1_1__process_communicator_a705576cad963041e54be485fecaebeb4}{wait\+\_\+for\+\_\+marker}}, timeout=None)
\item 
def \mbox{\hyperlink{classprocesses_1_1__process_communicator_acd47cf1a69c773b3caff26afe4d620b3}{communicate}} (self, input\+\_\+data=None, send\+\_\+marker\+\_\+list=None, close\+\_\+marker=None, timeout=None)
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classprocesses_1_1__process_communicator_a3ac788eb36702ab023d9cfff4dbbe0af}{proc}}
\item 
\mbox{\hyperlink{classprocesses_1_1__process_communicator_a705576cad963041e54be485fecaebeb4}{wait\+\_\+for\+\_\+marker}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}This class allows greater control over stdin than using Popen.communicate().
Popen.communicate() closes stdin as soon as data is written. This causes
TLS clients (OpenSSL derivatives) to shut down before the handshake is complete.

To prevent a premature shutdown, we need to wait until the handshake is complete
before writing to stdin. To accomplish this we `poll` stdout for a send
marker. Once that marker is found, we can write input data to stdin. The
benefit of using `poll` and `os.read` is that we get non-blocking IO. Our timeouts
are much more reliable, and we don't risk deadlocking on a readline() call which
will never complete.

Another method is to read stdout line by line. This removes a lot of code that
registers and unregisters file descriptors with a selector. It would make reading
and writing sequential (as opposed to event based), which can be easier to read
and maintain. The downsides with this method exist in the current integration test
framework. We rely on sleeps and waits, and still hit hard to debug deadlocks from
time to time.
\end{DoxyVerb}
 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classprocesses_1_1__process_communicator_acd696f42ce1ace31bc9c923aee051122}\label{classprocesses_1_1__process_communicator_acd696f42ce1ace31bc9c923aee051122}} 
\index{processes.\_processCommunicator@{processes.\_processCommunicator}!\_\_init\_\_@{\_\_init\_\_}}
\index{\_\_init\_\_@{\_\_init\_\_}!processes.\_processCommunicator@{processes.\_processCommunicator}}
\doxysubsubsection{\texorpdfstring{\_\_init\_\_()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def processes.\+\_\+process\+Communicator.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{proc }\end{DoxyParamCaption})}



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classprocesses_1_1__process_communicator_acd47cf1a69c773b3caff26afe4d620b3}\label{classprocesses_1_1__process_communicator_acd47cf1a69c773b3caff26afe4d620b3}} 
\index{processes.\_processCommunicator@{processes.\_processCommunicator}!communicate@{communicate}}
\index{communicate@{communicate}!processes.\_processCommunicator@{processes.\_processCommunicator}}
\doxysubsubsection{\texorpdfstring{communicate()}{communicate()}}
{\footnotesize\ttfamily def processes.\+\_\+process\+Communicator.\+communicate (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{input\+\_\+data = {\ttfamily None},  }\item[{}]{send\+\_\+marker\+\_\+list = {\ttfamily None},  }\item[{}]{close\+\_\+marker = {\ttfamily None},  }\item[{}]{timeout = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Communicates with the managed process. If send_marker_list is set, input_data will not be sent
until the marker is seen.

This method acts very similar to the Popen.communicate method. The only difference is the
send_marker_list and close_marker.
\end{DoxyVerb}
 \mbox{\Hypertarget{classprocesses_1_1__process_communicator_a0029d5a594a5012948325a1098057fb8}\label{classprocesses_1_1__process_communicator_a0029d5a594a5012948325a1098057fb8}} 
\index{processes.\_processCommunicator@{processes.\_processCommunicator}!wait\_for@{wait\_for}}
\index{wait\_for@{wait\_for}!processes.\_processCommunicator@{processes.\_processCommunicator}}
\doxysubsubsection{\texorpdfstring{wait\_for()}{wait\_for()}}
{\footnotesize\ttfamily def processes.\+\_\+process\+Communicator.\+wait\+\_\+for (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{wait\+\_\+for\+\_\+marker,  }\item[{}]{timeout = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Wait for a specific marker in stdout.
If the marker is not seen, a timeout will be raised.
\end{DoxyVerb}
 

\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classprocesses_1_1__process_communicator_a3ac788eb36702ab023d9cfff4dbbe0af}\label{classprocesses_1_1__process_communicator_a3ac788eb36702ab023d9cfff4dbbe0af}} 
\index{processes.\_processCommunicator@{processes.\_processCommunicator}!proc@{proc}}
\index{proc@{proc}!processes.\_processCommunicator@{processes.\_processCommunicator}}
\doxysubsubsection{\texorpdfstring{proc}{proc}}
{\footnotesize\ttfamily processes.\+\_\+process\+Communicator.\+proc}

\mbox{\Hypertarget{classprocesses_1_1__process_communicator_a705576cad963041e54be485fecaebeb4}\label{classprocesses_1_1__process_communicator_a705576cad963041e54be485fecaebeb4}} 
\index{processes.\_processCommunicator@{processes.\_processCommunicator}!wait\_for\_marker@{wait\_for\_marker}}
\index{wait\_for\_marker@{wait\_for\_marker}!processes.\_processCommunicator@{processes.\_processCommunicator}}
\doxysubsubsection{\texorpdfstring{wait\_for\_marker}{wait\_for\_marker}}
{\footnotesize\ttfamily processes.\+\_\+process\+Communicator.\+wait\+\_\+for\+\_\+marker}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
crt/aws-\/crt-\/cpp/crt/s2n/tests/integrationv2/\mbox{\hyperlink{processes_8py}{processes.\+py}}\end{DoxyCompactItemize}
