This repository contains tests which ensure that key s2n functions are not susceptible to timing attacks. For more details, see \href{https://github.com/awslabs/s2n/issues/463}{\texttt{ https\+://github.\+com/awslabs/s2n/issues/463}}

{\bfseries{Table of Contents}} ~\newline



\begin{DoxyItemize}
\item \href{\#what-are-timing-side-channels}{\texttt{ What are timing side channels}}
\item \href{\#s2n-countermeasures-against-timing-side-channels}{\texttt{ s2n countermeasures against timing side channels}}
\item \href{\#why-use-formal-methods-to-prove-the-correctness-of-s2ns-countermeasures}{\texttt{ Why use formal methods to prove the correctness of s2n\textquotesingle{}s countermeasures?}}
\item \href{\#how-does-sidetrail-prove-the-correctness-of-code-blinding-countermeasures}{\texttt{ How does Side\+Trail prove the correctness of code blinding countermeasures}}
\begin{DoxyItemize}
\item \href{\#high-level-overview}{\texttt{ High level overview}}
\item \href{\#user-annotations}{\texttt{ User annotations}}
\item \href{\#the-gory-details}{\texttt{ The gory details}}
\end{DoxyItemize}
\item \href{\#how-to-execute-the-tests}{\texttt{ How to execute the tests}}
\begin{DoxyItemize}
\item \href{\#get-docker}{\texttt{ Get Docker}}
\item \href{\#building-the-image}{\texttt{ Building the image}}
\item \href{\#starting-docker}{\texttt{ Starting docker}}
\item \href{\#running-a-proof-inside-docker}{\texttt{ Running a proof inside docker}}
\end{DoxyItemize}
\item \href{\#debugging-sidetrail-failures}{\texttt{ Debugging Side\+Trail failures}}
\item \href{\#questions}{\texttt{ Questions?}}
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md590}{}\doxysection{What are timing side channels}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md590}
Cryptographic protocols such as TLS are supposed to keep secret information secret. They do this by ensuring that WHICH bytes go over the wire is hidden using encryption. However, if the code is not carefully written, WHEN bytes go over the wire may depend on values that were supposed to remain secret.

For example, if code checks a password as follows


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for} (i = 0; i < \mbox{\hyperlink{iocp__event__loop_8c_ae809d5359ac030c60a30a8f0b2294b82}{length}}; ++i) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} \mbox{\hyperlink{connection__state__test_8c_af7b550f3b3dbd60c52719a28b826fdd8}{password}}[i] != input[i] \{}
\DoxyCodeLine{    send(\textcolor{stringliteral}{"{}bad password"{}});}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


then the amount of time until the reply message is received will depend on which byte in the password is incorrect. An attacker can simply guess


\begin{DoxyItemize}
\item a$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$
\item b$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$
\item c$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$
\end{DoxyItemize}

until the time to receive the error message changes, and then they know the first letter in the password. Repeating for the remaining characters turns an exponential guessing challenge into a linear one.

A variant of this attack, called LUCKY13, has been demonstrated against some implementations the Cipher Block Chaining (CBC) mode of SSL/\+TLS. In this attack, the TLS server is tricked into treating a (secret) encrypted byte as a padding length field. A naive TLS implementation will remove the specified amount of padding, then calculate a hash on the remaining bytes in the packet. If the value in the secret byte was large, a small number of bytes will be hashed; if it was small, a larger number of bytes will be hashed, creating a timing difference, which in theory can reveal the value in the secret byte.

For a detailed discussion of the LUCKY13 attack and how s2n mitigates against it, see \href{https://aws.amazon.com/blogs/security/s2n-and-lucky-13/}{\texttt{ this blog post}}.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md591}{}\doxysection{s2n countermeasures against timing side channels}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md591}
s2n takes a belt and suspenders approach to preventing side-\/channel attacks.
\begin{DoxyEnumerate}
\item First of all, it uses code-\/balancing to ensure that the same number of hash compression rounds are processed, no matter the value in the secret byte.
\item Second, it adds a delay of up to 10 seconds whenever any error is triggered, which increases by orders of magnitude the number of timing samples an attacker would need, even if they found a way around countermeasure 1.
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md592}{}\doxysection{Why use formal methods to prove the correctness of s2n\textquotesingle{}s countermeasures?}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md592}
Side channels are notoriously difficult to defend against, since code with a side-\/channel has the same functional behaviour as code that is side-\/channel free. Testing can find bugs, but it cannot prove their absence. In order to prove the absence of a timing side-\/channel (up to a timing model of system execution), you need a formal proof.

Formal proofs are also useful because they help prevent regressions. If a code change causes a timing side-\/channel to be introduced, the proof will fail, and the developer will be notified before the bug goes to production.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md593}{}\doxysection{How does Side\+Trail prove the correctness of code blinding countermeasures}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md593}
\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md594}{}\doxysubsection{High level overview}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md594}
A program has a timing side channel if the amount of time needed to execute it depends on the value of a secret input to the program. Side\+Trail take a program, annotates every instruction with its runtime cost, and then generates a mathematical formula which symbolically represents the cost of executing the program given an input. Side\+Trail then asks an automated theorem prover, called a Satisfiability Modulo Theories (SMT) solver, if there is a pair of secret inputs to the program that would take different amounts of time to process. The SMT solver, using clever heuristics, exhaustively searches the state of all possible program inputs, and either returns a proof that there is no timing side-\/channel, or an example of a pair of inputs that lead to a timing channel, along with the estimated leakage.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md595}{}\doxysubsection{User annotations}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md595}
In addition to the standard {\ttfamily assert()/assume()/} annotations supported through SMACK, there are several annotations supported by Side\+Trail, which allow the user to pass information to the Side\+Trail proof\+:


\begin{DoxyEnumerate}
\item {\ttfamily \+\_\+\+\_\+\+VERIFIER\+\_\+\+ASSUME\+\_\+\+LEAKAGE(arg)}\+: When the timing-\/modeling transformation encounters this call, it increments the leakage tracking variables by \char`\"{}arg\char`\"{}
\item {\ttfamily \mbox{\hyperlink{sidetrail_2working_2stubs_2s2n__annotations_8h_a82b5a2764625cc3f652354d7ded65476}{S2\+N\+\_\+\+PUBLIC\+\_\+\+INPUT(arg)}}}\+: the argument given here is taken to be public. All other variables are assumed private by default.
\item {\ttfamily \mbox{\hyperlink{sidetrail_2working_2stubs_2s2n__annotations_8h_a535b22580ac6790a65c3ad3baa8ff119}{S2\+N\+\_\+\+INVARIENT(arg)}}}\+: asserts that the given argument is an invariant of the loop, and as such holds on each execution of the loop, and at loop exit.
\item {\ttfamily \+\_\+\+\_\+\+VERIFIER\+\_\+\+ASSERT\+\_\+\+MAX\+\_\+\+LEAKAGE(arg)}\+: asserts that the given function is time-\/balanced, with a leakage of less than \char`\"{}arg\char`\"{} time units.
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md596}{}\doxysubsection{The gory details}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md596}
Mathematically, a program {\ttfamily P(secret, public)} has runtime {\ttfamily Time(\+P(secret,public))}. A program has a timing side-\/channel of delta if {\ttfamily $\vert$\+Time(P(secret\+\_\+1,public)) -\/ Time(\+P(secret\+\_\+2,public))$\vert$ = delta}. If we can represent {\ttfamily Time(\+P(secret,public))} as a mathematical formula, we can use a theorem prover to mathematically prove that the timing leakage of the program, for all choices of {\ttfamily secret\+\_\+1, secret\+\_\+2}, is less than {\ttfamily delta}.

Side\+Trail proceeds in several steps\+:


\begin{DoxyEnumerate}
\item Compile the code to llvm bitcode -\/ this allows Side\+Trail to accurately represent the effect of compiler optimizations on runtime
\item Use LLVM\textquotesingle{}s timing model to associate every bitcode operation with a timing cost
\item Use SMACK to compile the annotated LLVM code to Boogie\+PL (this represents {\ttfamily (P(secret,public))} in the above formula
\item Use bam-\/bam-\/boogieman to
\begin{DoxyItemize}
\item Add a timing cost variable to the program, generating {\ttfamily Time(\+P(secret,public))}
\item Make two copies of the resulting program, one which has inputs {\ttfamily (secret\+\_\+1, public)}, the other of which has inputs {\ttfamily (secret\+\_\+2, public)}
\item Assert that the difference in time between the two programs is less than {\ttfamily delta}
\end{DoxyItemize}
\item Use boogie to prove (via the z3 theorem prover) that either
\begin{DoxyItemize}
\item The time is indeed less than {\ttfamily delta}
\item or, the time is greater than {\ttfamily delta}, in which case the prover can emit a trace leading to the error
\end{DoxyItemize}
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md597}{}\doxysection{How to execute the tests}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md597}
\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md598}{}\doxysubsection{Get Docker}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md598}
We assume you have docker installed and running on your machine. If not, follow the instructions to install it \href{https://docs.docker.com/get-docker/}{\texttt{ https\+://docs.\+docker.\+com/get-\/docker/}}

We will assume that you have a variable {\ttfamily \$\+S2N} which encodes the path to s2n on your machine


\begin{DoxyCode}{0}
\DoxyCodeLine{export S2N=<path\_to\_s2n>}

\end{DoxyCode}
\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md599}{}\doxysubsection{Building the image}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md599}
To build the image, start with {\ttfamily s2n/codebuild/spec/sidetrail/\+Dockerfile}


\begin{DoxyCode}{0}
\DoxyCodeLine{cd \$S2N}
\DoxyCodeLine{docker build -\/f codebuild/spec/sidetrail/Dockerfile -\/-\/tag sidetrail .}

\end{DoxyCode}


This step takes about 25 minutes on my laptop.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md600}{}\doxysubsection{Starting docker}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md600}

\begin{DoxyCode}{0}
\DoxyCodeLine{cd \$S2N}
\DoxyCodeLine{docker run -\/it -\/v `pwd`:/home/s2n -\/-\/entrypoint /bin/bash sidetrail}

\end{DoxyCode}


You will now be presented with a docker shell. Inside this shell, run\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{source /sidetrail-\/install-\/dir/smack.environment }

\end{DoxyCode}


This step is important. If you do not source this file when you begin working, Side\+Trail may appear to run, but not actually analyze the code.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md601}{}\doxysubsection{Running a proof inside docker}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md601}

\begin{DoxyCode}{0}
\DoxyCodeLine{cd /home/s2n/tests/sidetrail/working}
\DoxyCodeLine{cd <testname>}
\DoxyCodeLine{./clean.sh ; ./run.sh}

\end{DoxyCode}


You should see output that looks something like this


\begin{DoxyCode}{0}
\DoxyCodeLine{...}
\DoxyCodeLine{...}
\DoxyCodeLine{warning: memory intrinsic length exceeds threshold (0); adding quantifiers.}
\DoxyCodeLine{SMACK generated s2n\_record\_parse\_wrapper@s2n\_record\_read\_wrapper.c.compiled.bpl}
\DoxyCodeLine{warning: module contains undefined functions: malloc, \_\_CONTRACT\_invariant, nondet}
\DoxyCodeLine{}
\DoxyCodeLine{ \_\_\_\_                \_            \_   }
\DoxyCodeLine{|  \_ \(\backslash\) \_ \_\_ \_\_\_   \_\_| |\_   \_  \_\_\_| |\_ }
\DoxyCodeLine{| |\_) | '\_\_/ \_ \(\backslash\) / \_` | | | |/ \_\_| \_\_|}
\DoxyCodeLine{|  \_\_/| | | (\_) | (\_| | |\_| | (\_\_| |\_ }
\DoxyCodeLine{|\_|   |\_|  \(\backslash\)\_\_\_/ \(\backslash\)\_\_,\_|\(\backslash\)\_\_,\_|\(\backslash\)\_\_\_|\(\backslash\)\_\_|}
\DoxyCodeLine{                                      }
\DoxyCodeLine{s2n\_record\_parse\_wrapper@s2n\_record\_read\_wrapper.c}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\_\_     \_\_        \_  \_\_       }
\DoxyCodeLine{\(\backslash\) \(\backslash\)   / /\_\_ \_ \_\_(\_)/ \_|\_   \_ }
\DoxyCodeLine{ \(\backslash\) \(\backslash\) / / \_ \(\backslash\) '\_\_| | |\_| | | |}
\DoxyCodeLine{  \(\backslash\) V /  \_\_/ |  | |  \_| |\_| |}
\DoxyCodeLine{   \(\backslash\)\_/ \(\backslash\)\_\_\_|\_|  |\_|\_|  \(\backslash\)\_\_, |}
\DoxyCodeLine{                       |\_\_\_/ }
\DoxyCodeLine{s2n\_record\_parse\_wrapper@s2n\_record\_read\_wrapper.c}
\DoxyCodeLine{}
\DoxyCodeLine{+  boogie /printModel 4 /doModSetAnalysis s2n\_record\_parse\_wrapper@s2n\_record\_read\_wrapper.c.product.bpl}
\DoxyCodeLine{Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-\/2014, Microsoft.}
\DoxyCodeLine{}
\DoxyCodeLine{Boogie program verifier finished with 1 verified, 0 errors}
\DoxyCodeLine{}
\DoxyCodeLine{real    0m23.334s}
\DoxyCodeLine{user    0m20.983s}
\DoxyCodeLine{sys 0m2.395s}

\end{DoxyCode}


If you do not see the line,


\begin{DoxyCode}{0}
\DoxyCodeLine{Boogie program verifier finished with 1 verified, 0 errors}

\end{DoxyCode}


then you probably forgot to source {\ttfamily smack.\+environment}. Go back and do so.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md602}{}\doxysection{Debugging Side\+Trail failures}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md602}
Consult \mbox{\hyperlink{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__d_e_b_u_g_g_i_n_g}{the debugging guide}}.\hypertarget{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md603}{}\doxysection{Questions?}\label{md_crt_aws_crt_cpp_crt_s2n_tests_sidetrail__r_e_a_d_m_e_autotoc_md603}
contact \href{mailto:aws-arg-platforms-support@amazon.com}{\texttt{ aws-\/arg-\/platforms-\/support@amazon.\+com}} 