\#\+CBMC FAQ

{\bfseries{Table of Contents}}


\begin{DoxyItemize}
\item \href{\#how-should-i-select-the-initial-entry-point-to-verify}{\texttt{ How should I select the initial entry-\/point to verify?}}
\begin{DoxyItemize}
\item \href{\#top-down-approach}{\texttt{ Top down approach}}
\item \href{\#bottom-up-approach}{\texttt{ Bottom up approach}}
\end{DoxyItemize}
\item \href{\#how-do-i-set-up-the-tools-i-need}{\texttt{ How do I set up the tools I need?}}
\item \href{\#how-do-i-set-up-my-repository-for-verification}{\texttt{ How do I set up my repository for verification?}}
\item \href{\#how-do-i-write-a-good-proof-harness}{\texttt{ How do I write a good proof harness?}}
\item \href{\#how-do-i-write-function-prepost-conditions}{\texttt{ How do I write function pre/post conditions?}}
\item \href{\#how-do-i-write-a-proof-makefile}{\texttt{ How do I write a proof Makefile?}}
\item \href{\#how-do-i-write-a-good-ensures-function}{\texttt{ How do I write a good ensures function?}}
\item \href{\#how-should-i-write-a-good-is_valid-function}{\texttt{ How should I write a good is\+\_\+valid function?}}
\item \href{\#i-see-12-proof-failures-how-do-i-select-which-one-to-debug}{\texttt{ I see 12 proof failures. How do I select which one to debug?}}
\item \href{\#how-do-i-debug-a-proof-failure}{\texttt{ How do I debug a proof failure?}}
\item \href{\#what-are-some-examples-of-good-cbmc-proofs}{\texttt{ What are some examples of good CBMC proofs?}}
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md145}{}\doxysubsection{How should I select the initial entry-\/point to verify?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md145}
There are two basic approaches that we have used at AWS to verify C code using CBMC\+: {\bfseries{top down}}, and {\bfseries{bottom up}}. In our experience, the top-\/down approach is best suited to a\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md146}{}\doxysubsubsection{Top down approach}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md146}
The top-\/down approach begins by selecting the most critical entry-\/points into the code. For example, when verifying an HTTP library, you might choose to begin with the network parser that handles data directly off the wire. Since this parser is directly exposed to untrusted input, verification leads to a significant security benefit.


\begin{DoxyItemize}
\item Advantages\+:
\begin{DoxyItemize}
\item Can be useful in cases where there is a limited amount of time to complete as much useful verification as possible, for example to before an upcoming feature release.
\item Focus directly on the most security/safety critical portions of the code
\end{DoxyItemize}
\item Disadvantages\+:
\begin{DoxyItemize}
\item Proofs can be very large, and tax the performance limits of CBMC
\item Can require writing a large number of initializer functions
\item Can require writing a large number of validity predicates
\item Little opportunity to reuse work.
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md147}{}\doxysubsubsection{Bottom up approach}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md147}
The bottom-\/up approach follows the natural dependency flow of the codebase being verified. In our experience, the more self-\/contained a piece of code is, the easier it is to verify.


\begin{DoxyEnumerate}
\item Make a dependency graph of the modules in your program.
\item Select the leaves of the graph -\/ those modules which other modules depend upon, but which do not depend on other modules themselves. Typically, these include the basic data-\/structures and algorithms used by the rest of the codebase. Which one of these you choose is a matter of style\+: you can use the \mbox{[}TODO, link to coding guidelines\mbox{]} coding guidelines to help select modules which are likely to be good verification targets.
\item Inside a given module, select the best initial verification target. This is often, but not always, one of the simpler functions. In particular, you are looking for a function which is both easy to verify, and will give good insight into the data-\/structure invariants of the data-\/structures used in the given module. In our experience, it often makes sense to start with allocation or initialization functions (which often have named that end in {\ttfamily \+\_\+alloc()} or {\ttfamily \+\_\+init()}
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md148}{}\doxysubsection{How do I set up the tools I need?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md148}
\mbox{[}TODO\mbox{]} -\/ basically brew install / apt-\/get install. Link to that page.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md149}{}\doxysubsection{How do I set up my repository for verification?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md149}
We have created a \char`\"{}\+Proof Starter Kit\char`\"{} repository, which includes the basic information required to set up a build-\/system for your first proof.


\begin{DoxyEnumerate}
\item Select where the proofs, and related artifacts, will go. Most projects put them parallel to existing verification artifacts.\mbox{[}TODO, should we retire .cbmc\+\_\+batch, and move it to tests/cbmc? for all projects\mbox{]} For example, if your project has folders {\ttfamily project/tests/unit}, {\ttfamily projects/tests/integration}, and {\ttfamily projects/tests/fuzzing}, we would suggest adding a folder {\ttfamily project/tests/cbmc}.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Add the \char`\"{}\+CBMC Proof Starter Kit\char`\"{} repository, available at \mbox{[}TODO\mbox{]}, to the {\ttfamily /cbmc} folder as a submodule. Use the command {\ttfamily \mbox{[}TODO\mbox{]}}. This will install a standard makefile, as well as a set of useful utility files. Follow the documentation in that repository to set any needed project specific overrides in the makefile.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Create the folders\+:
\begin{DoxyEnumerate}
\item {\ttfamily tests/cbmc/proofs}
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item {\ttfamily tests/cbmc/stubs}
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item {\ttfamily tests/cbmc/include}
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item {\ttfamily tests/cbmc/source}
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Choose an initial proof target {\ttfamily functionname} following the instructions above. We recommend choosing as simple a function as possible to verify in this case. This forms a \char`\"{}tracer bullet\char`\"{} proof to ensure that your infrastructure is working correctly.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Create the folder {\ttfamily tests/cbmc/proofs/functionname}
\begin{DoxyEnumerate}
\item Copy the sample proof makefile, and the sample proof harness, into that folder from the \char`\"{}proof starter kit\char`\"{} repo, and fill in the blanks. How to actually write the proof is discussed below \mbox{[}TODO link\mbox{]}
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Follow the instructions at \mbox{[}TODO where??\mbox{]} to enable CBMC CI for your repository
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md150}{}\doxysubsection{How do I write a good proof harness?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md150}
We have developed a style of writing proofs that we believe is readable, maintainable, and modular. This style was driven by feedback from developers, and addresses the need to communicate {\itshape exactly what we are proving} to developers and users.

Our proofs have the following features\+:
\begin{DoxyEnumerate}
\item They are structured as {\itshape harnesses} that call into the function being verified, similar to unit tests. This makes it easy to see how they work, as developers can `execute' the proof in their heads. This style also yields more useful error traces.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item They state their assumptions declaratively. Rather than creating a fully-\/initialized data structure in imperative style, we create unconstrained data structures and then constrain them just enough to prove the property of interest. This means the only assumptions on the data structure\textquotesingle{}s values are the ones we state in the harness.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item They follow a predictable pattern\+: setting up data structures, assuming preconditions on them, calling into the code being verified, and asserting postconditions.
\end{DoxyEnumerate}

The following code is an example of a proof harness\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{void aws\_array\_list\_get\_at\_ptr\_harness() \{}
\DoxyCodeLine{    /* initialization */}
\DoxyCodeLine{    struct aws\_array\_list list;}
\DoxyCodeLine{    \_\_CPROVER\_assume(aws\_array\_list\_is\_bounded(\&list));}
\DoxyCodeLine{    ensure\_array\_list\_has\_allocated\_data\_member(\&list);}
\DoxyCodeLine{}
\DoxyCodeLine{    /* generate unconstrained inputs */}
\DoxyCodeLine{    void **val = can\_fail\_malloc(sizeof(void *));}
\DoxyCodeLine{    size\_t index;}
\DoxyCodeLine{}
\DoxyCodeLine{    /* preconditions */}
\DoxyCodeLine{    \_\_CPROVER\_assume(aws\_array\_list\_is\_valid(\&list));}
\DoxyCodeLine{    \_\_CPROVER\_assume(val != NULL);}
\DoxyCodeLine{}
\DoxyCodeLine{    /* call function under verification */}
\DoxyCodeLine{    if(!aws\_array\_list\_get\_at\_ptr(\&list, val, index)) \{}
\DoxyCodeLine{      /* If aws\_array\_list\_get\_at\_ptr is successful,}
\DoxyCodeLine{       * i.e. ret==0, we ensure the list isn't}
\DoxyCodeLine{       * empty and index is within bounds */}
\DoxyCodeLine{        assert(list.data != NULL);}
\DoxyCodeLine{        assert(list.length > index);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    /* postconditions */}
\DoxyCodeLine{    assert(aws\_array\_list\_is\_valid(\&list));}
\DoxyCodeLine{    assert(val != NULL);}
\DoxyCodeLine{\}}

\end{DoxyCode}


The harness shown above consists of five parts\+:


\begin{DoxyEnumerate}
\item Initialize the data structure to unconstrained values. We developed initializers for all verified data structures using a consistent naming scheme\+: {\ttfamily ensure\+\_\+\{data\+\_\+structure\}\+\_\+has\+\_\+allocated\+\_\+data\+\_\+member()}.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Generate unconstrained inputs to the function.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Constrain all inputs to meet the function specification and assume all preconditions using {\ttfamily assume} statements. If necessary, bound the data structures so that the proof terminates.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Call the function under verification with these inputs.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Check any function postconditions using {\ttfamily assert} statements.
\end{DoxyEnumerate}

This style of writing a proof harness is motivated by our desire to make assumptions explicit to developers. This style consists of two steps. The first step does the minimal work required to imperatively allocate structures with unconstrained fields, as described in Items 1 and 2 in the above list. The second step uses {\ttfamily assume} statements to enforce the specification about the values that go in those fields (Item 3). This makes the specification used in the proof harness clear and allows them to be further reused as assertions in the mainline code.

Syntactically, a proof harness looks quite similar to a unit test. The main difference is that a proof harness calls the target function with a partially-\/constrained input rather than a concrete value; when symbolically executed by CBMC, this has the effect of exploring the function under {\itshape all} possible inputs that satisfy the constraints.

In fact, historically, we started from unit tests, and tried to make them symbolic by replacing concrete values with unconstrained values. We found this difficult, since there are relations that constrain fields in a data structure and must be enforced (e.\+g., {\ttfamily length \texorpdfstring{$<$}{<} capacity} and {\ttfamily capacity != 0 IMPLIES buffer != 0}). Even worse, these imperative proof-\/harnesses turned out to be difficult to reason about and to explain to the development team.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md151}{}\doxysubsection{How do I write function pre/post conditions?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md151}
The preconditions used as assumptions in (Item \$(3)\$) are developed using an iterative process. For each module, we start by specifying the simplest predicates that we can think of for the data structure --- usually, that the data of the data structure is correctly allocated. Then we gradually refine these predicates, until the development team accepts them as reasonable invariants for the data structure, aided by having all the unit and regression tests pass.

Using this process, we defined a set of predicates for each data structure in the C source file so that they can be easily accessed and modified by the library developers, and so that they serve as documentation for the library\textquotesingle{}s users. For instance, in the case of the {\ttfamily array\+\_\+list}, we started with the invariant that {\ttfamily data} points to {\ttfamily current\+\_\+size} allocated bytes. After several iterations, the validity invariant for {\ttfamily array\+\_\+list} ended up looking like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{bool aws\_array\_list\_is\_valid(}
\DoxyCodeLine{       const struct aws\_array\_list *list) \{}
\DoxyCodeLine{  if (!list) return false;}
\DoxyCodeLine{  size\_t required\_size = 0;}
\DoxyCodeLine{  bool required\_size\_is\_valid =}
\DoxyCodeLine{      (aws\_mul\_size\_checked(list-\/>length,}
\DoxyCodeLine{                            list-\/>item\_size,}
\DoxyCodeLine{                            \&required\_size)}
\DoxyCodeLine{       == AWS\_OP\_SUCCESS);}
\DoxyCodeLine{}
\DoxyCodeLine{  bool current\_size\_is\_valid =}
\DoxyCodeLine{      (list-\/>current\_size >= required\_size);}
\DoxyCodeLine{  bool data\_is\_valid =}
\DoxyCodeLine{      ((list-\/>current\_size == 0 \&\& list-\/>data == NULL)}
\DoxyCodeLine{      || AWS\_MEM\_IS\_WRITABLE(list-\/>data, list-\/>current\_size));}
\DoxyCodeLine{  bool item\_size\_is\_valid = (list-\/>item\_size != 0);}
\DoxyCodeLine{}
\DoxyCodeLine{  return required\_size\_is\_valid}
\DoxyCodeLine{      \&\& current\_size\_is\_valid}
\DoxyCodeLine{      \&\& data\_is\_valid \&\& item\_size\_is\_valid;}
\DoxyCodeLine{\}}

\end{DoxyCode}


The invariant above describes four conditions satisfied by a valid {\ttfamily array\+\_\+list}\+:


\begin{DoxyEnumerate}
\item the sum of the sizes of the items of the list must fit in an unsigned integer of type {\ttfamily size\+\_\+t}, which is checked using the function {\ttfamily aws\+\_\+mul\+\_\+size\+\_\+checked}
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item the size of the {\ttfamily array\+\_\+list} in bytes ({\ttfamily current\+\_\+size}) has to be larger than or equal to the sum of the sizes of its items;
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item the {\ttfamily data} pointer must point to a valid memory location, otherwise it must be {\ttfamily NULL} if the size of the {\ttfamily array\+\_\+list} is zero;
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item the {\ttfamily item\+\_\+size} must be positive.
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md152}{}\doxysubsection{How do I write a proof Makefile?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md152}
\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md153}{}\doxysubsection{How do I write a good ensures function?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md153}
\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md154}{}\doxysubsection{How should I write a good is\+\_\+valid function?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md154}
\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md155}{}\doxysubsection{I see 12 proof failures. How do I select which one to debug?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md155}
CBMC proof failures seem to come in batches\+: you run the proof, and see a dozen different errors reported In many cases, these failures are related\+: instead of stressing about the number of failures, pick one, debug it, and see if fixing it removes (many of) the others. Some good heuristics for deciding which failure to investigate\+:


\begin{DoxyEnumerate}
\item Look for a failure that occurs early on in the proof. This will often be the one with the shortest trace \mbox{[}TODO viewer should output this information\mbox{]}. The shorter the trace leading to the issue, the easier it is to debug.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Look for a failure in code you understand. Some functions are simpler than others\+: a failure in a simple function is often easier to analyze that one in a complicated function. And a failure in a function you understand is easier than one in
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Look for a simple type of failure. For example, the trace from a null dereference is often easier to follow than the trace for a use of a DEAD pointer. But they\textquotesingle{}re normally exactly the same bug!
\end{DoxyEnumerate}\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md156}{}\doxysubsection{How do I debug a proof failure?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md156}
There are a number of techniques that have proven useful in debugging proof failures.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md157}{}\doxysubsection{What are some examples of good CBMC proofs?}\label{md_crt_aws_crt_cpp_crt_aws_c_common_verification_cbmc_templates_training_material__f_a_q_autotoc_md157}
\href{https://github.com/awslabs/aws-c-common/blob/master/.cbmc-batch/jobs/aws_array_list_copy/aws_array_list_copy_harness.c}{\texttt{ AWS-\/\+C-\/\+Common -\/ Array List Copy}}

\href{https://github.com/awslabs/s2n/blob/master/tests/cbmc/proofs/s2n_stuffer_erase_and_read_bytes/s2n_stuffer_erase_and_read_bytes_harness.c}{\texttt{ s2n\+: stuffer erase and read bytes}} 