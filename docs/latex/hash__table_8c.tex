\hypertarget{hash__table_8c}{}\doxysection{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/source/hash\+\_\+table.c File Reference}
\label{hash__table_8c}\index{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/source/hash\_table.c@{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/source/hash\_table.c}}
{\ttfamily \#include $<$aws/common/hash\+\_\+table.\+h$>$}\newline
{\ttfamily \#include $<$aws/common/math.\+h$>$}\newline
{\ttfamily \#include $<$aws/common/private/hash\+\_\+table\+\_\+impl.\+h$>$}\newline
{\ttfamily \#include $<$aws/common/string.\+h$>$}\newline
{\ttfamily \#include $<$limits.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$aws/common/private/lookup3.\+inl$>$}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static void \mbox{\hyperlink{hash__table_8c_a561e18750dd4238e34b9a4ebe413272d}{s\+\_\+suppress\+\_\+unused\+\_\+lookup3\+\_\+func\+\_\+warnings}} (void)
\item 
static uint64\+\_\+t \mbox{\hyperlink{hash__table_8c_a4742604a69a60e8cd2744c856f895122}{s\+\_\+hash\+\_\+for}} (struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$\mbox{\hyperlink{structstate}{state}}, const void $\ast$key)
\item 
static \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_a4ff62d8b2be59292bf3b6c8bc31af3f2}{s\+\_\+safe\+\_\+eq\+\_\+check}} (\mbox{\hyperlink{hash__table_8h_aa4c204703f44b4d6416c26fee7b6cc20}{aws\+\_\+hash\+\_\+callback\+\_\+eq\+\_\+fn}} $\ast$equals\+\_\+fn, const void $\ast$a, const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
static \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_a0aa46b3c406c3de80068eb1f64b36699}{s\+\_\+hash\+\_\+keys\+\_\+eq}} (struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$\mbox{\hyperlink{structstate}{state}}, const void $\ast$a, const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
static size\+\_\+t \mbox{\hyperlink{hash__table_8c_ae0c02d6f56e2810eb8eac36976fa76d6}{s\+\_\+index\+\_\+for}} (struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$map, struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} $\ast$entry)
\item 
size\+\_\+t \mbox{\hyperlink{hash__table_8c_a7c28b23d5bdbd23595fecf981d4198fc}{aws\+\_\+hash\+\_\+table\+\_\+get\+\_\+entry\+\_\+count}} (const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map)
\item 
static struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$ \mbox{\hyperlink{hash__table_8c_a002334628277b55444ce6201dc75b84d}{s\+\_\+alloc\+\_\+state}} (const struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$template)
\item 
static int \mbox{\hyperlink{hash__table_8c_ab5020efe920b50287f9ce9d6d7202d72}{s\+\_\+update\+\_\+template\+\_\+size}} (struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$template, size\+\_\+t expected\+\_\+elements)
\item 
int \mbox{\hyperlink{hash__table_8c_a4a7e06ea94db195017789baefb8c31d8}{aws\+\_\+hash\+\_\+table\+\_\+init}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map, struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$alloc, size\+\_\+t size, \mbox{\hyperlink{hash__table_8h_a9538a6cea5ae96678de8456865b2f18a}{aws\+\_\+hash\+\_\+fn}} $\ast$hash\+\_\+fn, \mbox{\hyperlink{hash__table_8h_aa4c204703f44b4d6416c26fee7b6cc20}{aws\+\_\+hash\+\_\+callback\+\_\+eq\+\_\+fn}} $\ast$equals\+\_\+fn, \mbox{\hyperlink{hash__table_8h_a5f8e4476b6d413463590d13536b6bdc0}{aws\+\_\+hash\+\_\+callback\+\_\+destroy\+\_\+fn}} $\ast$destroy\+\_\+key\+\_\+fn, \mbox{\hyperlink{hash__table_8h_a5f8e4476b6d413463590d13536b6bdc0}{aws\+\_\+hash\+\_\+callback\+\_\+destroy\+\_\+fn}} $\ast$destroy\+\_\+value\+\_\+fn)
\item 
void \mbox{\hyperlink{hash__table_8c_a04d9cf93fa302b35b28a1de03b910717}{aws\+\_\+hash\+\_\+table\+\_\+clean\+\_\+up}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map)
\item 
void \mbox{\hyperlink{hash__table_8c_a8acda923a9a3eb7cbdb1c936b89db777}{aws\+\_\+hash\+\_\+table\+\_\+swap}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} a, struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
void \mbox{\hyperlink{hash__table_8c_a442d9979faed0e8fa595803b49c999c7}{aws\+\_\+hash\+\_\+table\+\_\+move}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} to, struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} from)
\item 
static int \mbox{\hyperlink{hash__table_8c_a07357c5a65d1919cce9a144a84e3cb2a}{s\+\_\+find\+\_\+entry1}} (struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$\mbox{\hyperlink{structstate}{state}}, uint64\+\_\+t hash\+\_\+code, const void $\ast$key, struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} $\ast$$\ast$p\+\_\+entry, size\+\_\+t $\ast$p\+\_\+probe\+\_\+idx)
\item 
static int \mbox{\hyperlink{hash__table_8c_a759b1bb970808dd34206eff6a6e38ebc}{s\+\_\+find\+\_\+entry}} (struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$\mbox{\hyperlink{structstate}{state}}, uint64\+\_\+t hash\+\_\+code, const void $\ast$key, struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} $\ast$$\ast$p\+\_\+entry, size\+\_\+t $\ast$p\+\_\+probe\+\_\+idx)
\item 
int \mbox{\hyperlink{hash__table_8c_aa64beafd8485902db81ce78d6d3e4524}{aws\+\_\+hash\+\_\+table\+\_\+find}} (const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map, const void $\ast$key, struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$$\ast$p\+\_\+elem)
\item 
static struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} $\ast$ \mbox{\hyperlink{hash__table_8c_a563547acbf4174ed833d1612fa7b3681}{s\+\_\+emplace\+\_\+item}} (struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$\mbox{\hyperlink{structstate}{state}}, struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} entry, size\+\_\+t probe\+\_\+idx)
\item 
static int \mbox{\hyperlink{hash__table_8c_ae024373fee08d60715c9e1823802deea}{s\+\_\+expand\+\_\+table}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map)
\item 
int \mbox{\hyperlink{hash__table_8c_abb050fbade00d5902a7f448c2fe8a53c}{aws\+\_\+hash\+\_\+table\+\_\+create}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map, const void $\ast$key, struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$$\ast$p\+\_\+elem, int $\ast$was\+\_\+created)
\item 
\mbox{\hyperlink{crt_2aws-crt-cpp_2crt_2aws-c-common_2include_2aws_2common_2_exports_8h_a4d44553ff7ad58c9718deb08c64c49a6}{AWS\+\_\+\+COMMON\+\_\+\+API}} int \mbox{\hyperlink{hash__table_8c_a788acdfdb835b839f5f4b2e93bf0e14c}{aws\+\_\+hash\+\_\+table\+\_\+put}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map, const void $\ast$key, void $\ast$value, int $\ast$was\+\_\+created)
\item 
static size\+\_\+t \mbox{\hyperlink{hash__table_8c_a4f41dca3338ae7e3fa5bd8e24aeb2f8d}{s\+\_\+remove\+\_\+entry}} (struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$\mbox{\hyperlink{structstate}{state}}, struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} $\ast$entry)
\item 
int \mbox{\hyperlink{hash__table_8c_ab95ad2e4f6f0630861b91ea08b4b2244}{aws\+\_\+hash\+\_\+table\+\_\+remove}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map, const void $\ast$key, struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$p\+\_\+value, int $\ast$was\+\_\+present)
\item 
int \mbox{\hyperlink{hash__table_8c_a9637fcb9a2d525a1c492b8bdee105928}{aws\+\_\+hash\+\_\+table\+\_\+remove\+\_\+element}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map, struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$p\+\_\+value)
\item 
int \mbox{\hyperlink{hash__table_8c_af789dc91ca29e84c0c5e53f847d641c1}{aws\+\_\+hash\+\_\+table\+\_\+foreach}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map, int($\ast$callback)(void $\ast$context, struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$p\+Element), void $\ast$context)
\item 
\mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_acb99d71172b06589b416b843a982ee8d}{aws\+\_\+hash\+\_\+table\+\_\+eq}} (const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$a, const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}}, \mbox{\hyperlink{hash__table_8h_aa4c204703f44b4d6416c26fee7b6cc20}{aws\+\_\+hash\+\_\+callback\+\_\+eq\+\_\+fn}} $\ast$value\+\_\+eq)
\item 
static void \mbox{\hyperlink{hash__table_8c_ab0e8a83f32f397f9b4df4bb4dc235335}{s\+\_\+get\+\_\+next\+\_\+element}} (struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$iter, size\+\_\+t start\+\_\+slot)
\item 
struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} \mbox{\hyperlink{hash__table_8c_ab556a28dc6a88d729577c720209d3fe9}{aws\+\_\+hash\+\_\+iter\+\_\+begin}} (const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map)
\item 
\mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_a9fa88a2db73cd7a9fc8a4e14d1a152e2}{aws\+\_\+hash\+\_\+iter\+\_\+done}} (const struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$iter)
\item 
void \mbox{\hyperlink{hash__table_8c_a853111399f6f58127648575c09842982}{aws\+\_\+hash\+\_\+iter\+\_\+next}} (struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$iter)
\item 
void \mbox{\hyperlink{hash__table_8c_a15c1baf1b6e5c7e169752e555b7428c1}{aws\+\_\+hash\+\_\+iter\+\_\+delete}} (struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$iter, \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} destroy\+\_\+contents)
\item 
void \mbox{\hyperlink{hash__table_8c_ab6c0740854e63d3275a57552cc07bb7b}{aws\+\_\+hash\+\_\+table\+\_\+clear}} (struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map)
\item 
uint64\+\_\+t \mbox{\hyperlink{hash__table_8c_a3454a9def656e9ea4d501633cba37943}{aws\+\_\+hash\+\_\+c\+\_\+string}} (const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_ac011de571ff16ba220d2e0d757e4e8b0}{item}})
\item 
uint64\+\_\+t \mbox{\hyperlink{hash__table_8c_a259fc9a768dc687f62ac9a3155e955e3}{aws\+\_\+hash\+\_\+string}} (const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_ac011de571ff16ba220d2e0d757e4e8b0}{item}})
\item 
uint64\+\_\+t \mbox{\hyperlink{hash__table_8c_add8768797cf2f209bfb960d053cedd26}{aws\+\_\+hash\+\_\+byte\+\_\+cursor\+\_\+ptr}} (const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_ac011de571ff16ba220d2e0d757e4e8b0}{item}})
\item 
uint64\+\_\+t \mbox{\hyperlink{hash__table_8c_a720962da45153c414105a55910e4cff5}{aws\+\_\+hash\+\_\+ptr}} (const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_ac011de571ff16ba220d2e0d757e4e8b0}{item}})
\item 
uint64\+\_\+t \mbox{\hyperlink{hash__table_8c_ada608025c32c954bb64b061df2a9ccc4}{aws\+\_\+hash\+\_\+combine}} (uint64\+\_\+t item1, uint64\+\_\+t item2)
\item 
\mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_a247fd154b620628c837093744469feb8}{aws\+\_\+hash\+\_\+callback\+\_\+c\+\_\+str\+\_\+eq}} (const void $\ast$a, const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
\mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_a076b4d647b47bee67ad608b8c350d8df}{aws\+\_\+hash\+\_\+callback\+\_\+string\+\_\+eq}} (const void $\ast$a, const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
void \mbox{\hyperlink{hash__table_8c_a58b97ccc4d6a3ff8235a2a449c12c56b}{aws\+\_\+hash\+\_\+callback\+\_\+string\+\_\+destroy}} (void $\ast$a)
\item 
\mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_a4d9ea528c0f119a03ba088b04134a0c1}{aws\+\_\+ptr\+\_\+eq}} (const void $\ast$a, const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
\mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_aff4bf82035b05b9b8e976eb919ed6508}{aws\+\_\+hash\+\_\+table\+\_\+is\+\_\+valid}} (const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$map)
\item 
\mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_aeb6b02b5404af6dc40439723eb0aed96}{hash\+\_\+table\+\_\+state\+\_\+is\+\_\+valid}} (const struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$map)
\item 
\mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} \mbox{\hyperlink{hash__table_8c_a855920523cd1b94f984d6fee66f637cb}{aws\+\_\+hash\+\_\+iter\+\_\+is\+\_\+valid}} (const struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$iter)
\item 
int \mbox{\hyperlink{hash__table_8c_a25f43ce27f9e6fe672a4ba05390a2de8}{hash\+\_\+table\+\_\+state\+\_\+required\+\_\+bytes}} (size\+\_\+t size, size\+\_\+t $\ast$required\+\_\+bytes)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{hash__table_8c_add8768797cf2f209bfb960d053cedd26}\label{hash__table_8c_add8768797cf2f209bfb960d053cedd26}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_byte\_cursor\_ptr@{aws\_hash\_byte\_cursor\_ptr}}
\index{aws\_hash\_byte\_cursor\_ptr@{aws\_hash\_byte\_cursor\_ptr}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_byte\_cursor\_ptr()}{aws\_hash\_byte\_cursor\_ptr()}}
{\footnotesize\ttfamily uint64\+\_\+t aws\+\_\+hash\+\_\+byte\+\_\+cursor\+\_\+ptr (\begin{DoxyParamCaption}\item[{const void $\ast$}]{item }\end{DoxyParamCaption})}

Convenience hash function for struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}}. Hash is same as used on the string bytes by aws\+\_\+hash\+\_\+c\+\_\+string. \mbox{\Hypertarget{hash__table_8c_a3454a9def656e9ea4d501633cba37943}\label{hash__table_8c_a3454a9def656e9ea4d501633cba37943}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_c\_string@{aws\_hash\_c\_string}}
\index{aws\_hash\_c\_string@{aws\_hash\_c\_string}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_c\_string()}{aws\_hash\_c\_string()}}
{\footnotesize\ttfamily uint64\+\_\+t aws\+\_\+hash\+\_\+c\+\_\+string (\begin{DoxyParamCaption}\item[{const void $\ast$}]{item }\end{DoxyParamCaption})}

Convenience hash function for NULL-\/terminated C-\/strings \mbox{\Hypertarget{hash__table_8c_a247fd154b620628c837093744469feb8}\label{hash__table_8c_a247fd154b620628c837093744469feb8}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_callback\_c\_str\_eq@{aws\_hash\_callback\_c\_str\_eq}}
\index{aws\_hash\_callback\_c\_str\_eq@{aws\_hash\_callback\_c\_str\_eq}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_callback\_c\_str\_eq()}{aws\_hash\_callback\_c\_str\_eq()}}
{\footnotesize\ttfamily \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} aws\+\_\+hash\+\_\+callback\+\_\+c\+\_\+str\+\_\+eq (\begin{DoxyParamCaption}\item[{const void $\ast$}]{a,  }\item[{const void $\ast$}]{b }\end{DoxyParamCaption})}

Convenience eq callback for NULL-\/terminated C-\/strings \mbox{\Hypertarget{hash__table_8c_a58b97ccc4d6a3ff8235a2a449c12c56b}\label{hash__table_8c_a58b97ccc4d6a3ff8235a2a449c12c56b}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_callback\_string\_destroy@{aws\_hash\_callback\_string\_destroy}}
\index{aws\_hash\_callback\_string\_destroy@{aws\_hash\_callback\_string\_destroy}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_callback\_string\_destroy()}{aws\_hash\_callback\_string\_destroy()}}
{\footnotesize\ttfamily void aws\+\_\+hash\+\_\+callback\+\_\+string\+\_\+destroy (\begin{DoxyParamCaption}\item[{void $\ast$}]{a }\end{DoxyParamCaption})}

Convenience destroy callback for AWS strings \mbox{\Hypertarget{hash__table_8c_a076b4d647b47bee67ad608b8c350d8df}\label{hash__table_8c_a076b4d647b47bee67ad608b8c350d8df}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_callback\_string\_eq@{aws\_hash\_callback\_string\_eq}}
\index{aws\_hash\_callback\_string\_eq@{aws\_hash\_callback\_string\_eq}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_callback\_string\_eq()}{aws\_hash\_callback\_string\_eq()}}
{\footnotesize\ttfamily \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} aws\+\_\+hash\+\_\+callback\+\_\+string\+\_\+eq (\begin{DoxyParamCaption}\item[{const void $\ast$}]{a,  }\item[{const void $\ast$}]{b }\end{DoxyParamCaption})}

Convenience eq callback for AWS strings \mbox{\Hypertarget{hash__table_8c_ada608025c32c954bb64b061df2a9ccc4}\label{hash__table_8c_ada608025c32c954bb64b061df2a9ccc4}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_combine@{aws\_hash\_combine}}
\index{aws\_hash\_combine@{aws\_hash\_combine}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_combine()}{aws\_hash\_combine()}}
{\footnotesize\ttfamily uint64\+\_\+t aws\+\_\+hash\+\_\+combine (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{item1,  }\item[{uint64\+\_\+t}]{item2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{hash__table_8c_ab556a28dc6a88d729577c720209d3fe9}\label{hash__table_8c_ab556a28dc6a88d729577c720209d3fe9}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_iter\_begin@{aws\_hash\_iter\_begin}}
\index{aws\_hash\_iter\_begin@{aws\_hash\_iter\_begin}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_iter\_begin()}{aws\_hash\_iter\_begin()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} aws\+\_\+hash\+\_\+iter\+\_\+begin (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map }\end{DoxyParamCaption})}

Returns an iterator to be used for iterating through a hash table. Iterator will already point to the first element of the table it finds, which can be accessed as iter.\+element.

This function cannot fail, but if there are no elements in the table, the returned iterator will return true for aws\+\_\+hash\+\_\+iter\+\_\+done(\&iter). \mbox{\Hypertarget{hash__table_8c_a15c1baf1b6e5c7e169752e555b7428c1}\label{hash__table_8c_a15c1baf1b6e5c7e169752e555b7428c1}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_iter\_delete@{aws\_hash\_iter\_delete}}
\index{aws\_hash\_iter\_delete@{aws\_hash\_iter\_delete}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_iter\_delete()}{aws\_hash\_iter\_delete()}}
{\footnotesize\ttfamily void aws\+\_\+hash\+\_\+iter\+\_\+delete (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$}]{iter,  }\item[{\mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}}}]{destroy\+\_\+contents }\end{DoxyParamCaption})}

Deletes the element currently pointed-\/to by the hash iterator. After calling this method, the element member of the iterator should not be accessed until the next call to aws\+\_\+hash\+\_\+iter\+\_\+next.


\begin{DoxyParams}{Parameters}
{\em destroy\+\_\+contents} & If true, the destructors for the key and value will be called. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{hash__table_8c_a9fa88a2db73cd7a9fc8a4e14d1a152e2}\label{hash__table_8c_a9fa88a2db73cd7a9fc8a4e14d1a152e2}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_iter\_done@{aws\_hash\_iter\_done}}
\index{aws\_hash\_iter\_done@{aws\_hash\_iter\_done}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_iter\_done()}{aws\_hash\_iter\_done()}}
{\footnotesize\ttfamily \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} aws\+\_\+hash\+\_\+iter\+\_\+done (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$}]{iter }\end{DoxyParamCaption})}

Returns true if iterator is done iterating through table, false otherwise. If this is true, the iterator will not include an element of the table. \mbox{\Hypertarget{hash__table_8c_a855920523cd1b94f984d6fee66f637cb}\label{hash__table_8c_a855920523cd1b94f984d6fee66f637cb}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_iter\_is\_valid@{aws\_hash\_iter\_is\_valid}}
\index{aws\_hash\_iter\_is\_valid@{aws\_hash\_iter\_is\_valid}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_iter\_is\_valid()}{aws\_hash\_iter\_is\_valid()}}
{\footnotesize\ttfamily \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} aws\+\_\+hash\+\_\+iter\+\_\+is\+\_\+valid (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$}]{iter }\end{DoxyParamCaption})}

Given a pointer to a hash\+\_\+iter, checks that it is well-\/formed, with all data-\/structure invariants. \mbox{\Hypertarget{hash__table_8c_a853111399f6f58127648575c09842982}\label{hash__table_8c_a853111399f6f58127648575c09842982}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_iter\_next@{aws\_hash\_iter\_next}}
\index{aws\_hash\_iter\_next@{aws\_hash\_iter\_next}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_iter\_next()}{aws\_hash\_iter\_next()}}
{\footnotesize\ttfamily void aws\+\_\+hash\+\_\+iter\+\_\+next (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$}]{iter }\end{DoxyParamCaption})}

Updates iterator so that it points to next element of hash table.

This and the two previous functions are designed to be used together with the following idiom\+:

for (struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} iter = aws\+\_\+hash\+\_\+iter\+\_\+begin(\&map); !aws\+\_\+hash\+\_\+iter\+\_\+done(\&iter); aws\+\_\+hash\+\_\+iter\+\_\+next(\&iter)) \{ const key\+\_\+type key = $\ast$(const key\+\_\+type $\ast$)iter.\+element.\+key; value\+\_\+type value = $\ast$(value\+\_\+type $\ast$)iter.\+element.\+value; // etc. \}

Note that calling this on an iter which is \char`\"{}done\char`\"{} is idempotent\+: i.\+e. it will return another iter which is \char`\"{}done\char`\"{}. \mbox{\Hypertarget{hash__table_8c_a720962da45153c414105a55910e4cff5}\label{hash__table_8c_a720962da45153c414105a55910e4cff5}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_ptr@{aws\_hash\_ptr}}
\index{aws\_hash\_ptr@{aws\_hash\_ptr}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_ptr()}{aws\_hash\_ptr()}}
{\footnotesize\ttfamily uint64\+\_\+t aws\+\_\+hash\+\_\+ptr (\begin{DoxyParamCaption}\item[{const void $\ast$}]{item }\end{DoxyParamCaption})}

Convenience hash function which hashes the pointer value directly, without dereferencing. This can be used in cases where pointer identity is desired, or where a uintptr\+\_\+t is encoded into a const void $\ast$. \mbox{\Hypertarget{hash__table_8c_a259fc9a768dc687f62ac9a3155e955e3}\label{hash__table_8c_a259fc9a768dc687f62ac9a3155e955e3}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_string@{aws\_hash\_string}}
\index{aws\_hash\_string@{aws\_hash\_string}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_string()}{aws\_hash\_string()}}
{\footnotesize\ttfamily uint64\+\_\+t aws\+\_\+hash\+\_\+string (\begin{DoxyParamCaption}\item[{const void $\ast$}]{item }\end{DoxyParamCaption})}

Convenience hash function for struct aws\+\_\+strings. Hash is same as used on the string bytes by aws\+\_\+hash\+\_\+c\+\_\+string. \mbox{\Hypertarget{hash__table_8c_a04d9cf93fa302b35b28a1de03b910717}\label{hash__table_8c_a04d9cf93fa302b35b28a1de03b910717}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_clean\_up@{aws\_hash\_table\_clean\_up}}
\index{aws\_hash\_table\_clean\_up@{aws\_hash\_table\_clean\_up}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_clean\_up()}{aws\_hash\_table\_clean\_up()}}
{\footnotesize\ttfamily void aws\+\_\+hash\+\_\+table\+\_\+clean\+\_\+up (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map }\end{DoxyParamCaption})}

Deletes every element from map and frees all associated memory. destroy\+\_\+fn will be called for each element. aws\+\_\+hash\+\_\+table\+\_\+init must be called before reusing the hash table.

This method is idempotent. \mbox{\Hypertarget{hash__table_8c_ab6c0740854e63d3275a57552cc07bb7b}\label{hash__table_8c_ab6c0740854e63d3275a57552cc07bb7b}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_clear@{aws\_hash\_table\_clear}}
\index{aws\_hash\_table\_clear@{aws\_hash\_table\_clear}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_clear()}{aws\_hash\_table\_clear()}}
{\footnotesize\ttfamily void aws\+\_\+hash\+\_\+table\+\_\+clear (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map }\end{DoxyParamCaption})}

Removes every element from the hash map. destroy\+\_\+fn will be called for each element. \mbox{\Hypertarget{hash__table_8c_abb050fbade00d5902a7f448c2fe8a53c}\label{hash__table_8c_abb050fbade00d5902a7f448c2fe8a53c}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_create@{aws\_hash\_table\_create}}
\index{aws\_hash\_table\_create@{aws\_hash\_table\_create}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_create()}{aws\_hash\_table\_create()}}
{\footnotesize\ttfamily int aws\+\_\+hash\+\_\+table\+\_\+create (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map,  }\item[{const void $\ast$}]{key,  }\item[{struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$$\ast$}]{p\+\_\+elem,  }\item[{int $\ast$}]{was\+\_\+created }\end{DoxyParamCaption})}

Attempts to locate an element at key. If no such element was found, creates a new element, with value initialized to NULL. In either case, a pointer to the element is placed in $\ast$p\+\_\+elem.

If was\+\_\+created is non-\/\+NULL, $\ast$was\+\_\+created is set to 0 if an existing element was found, or 1 is a new element was created.

Returns AWS\+\_\+\+OP\+\_\+\+SUCCESS if an item was found or created. Raises AWS\+\_\+\+ERROR\+\_\+\+OOM if hash table expansion was required and memory allocation failed. \mbox{\Hypertarget{hash__table_8c_acb99d71172b06589b416b843a982ee8d}\label{hash__table_8c_acb99d71172b06589b416b843a982ee8d}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_eq@{aws\_hash\_table\_eq}}
\index{aws\_hash\_table\_eq@{aws\_hash\_table\_eq}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_eq()}{aws\_hash\_table\_eq()}}
{\footnotesize\ttfamily \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} aws\+\_\+hash\+\_\+table\+\_\+eq (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{b,  }\item[{\mbox{\hyperlink{hash__table_8h_aa4c204703f44b4d6416c26fee7b6cc20}{aws\+\_\+hash\+\_\+callback\+\_\+eq\+\_\+fn}} $\ast$}]{value\+\_\+eq }\end{DoxyParamCaption})}

Compares two hash tables for equality. Both hash tables must have equivalent key comparators; values will be compared using the comparator passed into this function. The key hash function does not need to be equivalent between the two hash tables. \mbox{\Hypertarget{hash__table_8c_aa64beafd8485902db81ce78d6d3e4524}\label{hash__table_8c_aa64beafd8485902db81ce78d6d3e4524}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_find@{aws\_hash\_table\_find}}
\index{aws\_hash\_table\_find@{aws\_hash\_table\_find}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_find()}{aws\_hash\_table\_find()}}
{\footnotesize\ttfamily int aws\+\_\+hash\+\_\+table\+\_\+find (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map,  }\item[{const void $\ast$}]{key,  }\item[{struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$$\ast$}]{p\+\_\+elem }\end{DoxyParamCaption})}

Attempts to locate an element at key. If the element is found, a pointer to the value is placed in $\ast$p\+\_\+elem; if it is not found, $\ast$p\+Elem is set to NULL. Either way, AWS\+\_\+\+OP\+\_\+\+SUCCESS is returned.

This method does not change the state of the hash table. Therefore, it is safe to call \+\_\+find from multiple threads on the same hash table, provided no mutating operations happen in parallel.

Calling code may update the value in the hash table by modifying $\ast$$\ast$p\+Elem after a successful find. However, this pointer is not guaranteed to remain usable after a subsequent call to \+\_\+put, \+\_\+delete, \+\_\+clear, or \+\_\+clean\+\_\+up. \mbox{\Hypertarget{hash__table_8c_af789dc91ca29e84c0c5e53f847d641c1}\label{hash__table_8c_af789dc91ca29e84c0c5e53f847d641c1}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_foreach@{aws\_hash\_table\_foreach}}
\index{aws\_hash\_table\_foreach@{aws\_hash\_table\_foreach}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_foreach()}{aws\_hash\_table\_foreach()}}
{\footnotesize\ttfamily int aws\+\_\+hash\+\_\+table\+\_\+foreach (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map,  }\item[{int($\ast$)(void $\ast$context, struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$p\+Element)}]{callback,  }\item[{void $\ast$}]{context }\end{DoxyParamCaption})}

\mbox{\Hypertarget{hash__table_8c_a7c28b23d5bdbd23595fecf981d4198fc}\label{hash__table_8c_a7c28b23d5bdbd23595fecf981d4198fc}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_get\_entry\_count@{aws\_hash\_table\_get\_entry\_count}}
\index{aws\_hash\_table\_get\_entry\_count@{aws\_hash\_table\_get\_entry\_count}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_get\_entry\_count()}{aws\_hash\_table\_get\_entry\_count()}}
{\footnotesize\ttfamily size\+\_\+t aws\+\_\+hash\+\_\+table\+\_\+get\+\_\+entry\+\_\+count (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map }\end{DoxyParamCaption})}

Returns the current number of entries in the table. \mbox{\Hypertarget{hash__table_8c_a4a7e06ea94db195017789baefb8c31d8}\label{hash__table_8c_a4a7e06ea94db195017789baefb8c31d8}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_init@{aws\_hash\_table\_init}}
\index{aws\_hash\_table\_init@{aws\_hash\_table\_init}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_init()}{aws\_hash\_table\_init()}}
{\footnotesize\ttfamily int aws\+\_\+hash\+\_\+table\+\_\+init (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map,  }\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{alloc,  }\item[{size\+\_\+t}]{size,  }\item[{\mbox{\hyperlink{hash__table_8h_a9538a6cea5ae96678de8456865b2f18a}{aws\+\_\+hash\+\_\+fn}} $\ast$}]{hash\+\_\+fn,  }\item[{\mbox{\hyperlink{hash__table_8h_aa4c204703f44b4d6416c26fee7b6cc20}{aws\+\_\+hash\+\_\+callback\+\_\+eq\+\_\+fn}} $\ast$}]{equals\+\_\+fn,  }\item[{\mbox{\hyperlink{hash__table_8h_a5f8e4476b6d413463590d13536b6bdc0}{aws\+\_\+hash\+\_\+callback\+\_\+destroy\+\_\+fn}} $\ast$}]{destroy\+\_\+key\+\_\+fn,  }\item[{\mbox{\hyperlink{hash__table_8h_a5f8e4476b6d413463590d13536b6bdc0}{aws\+\_\+hash\+\_\+callback\+\_\+destroy\+\_\+fn}} $\ast$}]{destroy\+\_\+value\+\_\+fn }\end{DoxyParamCaption})}

Initializes a hash map with initial capacity for \textquotesingle{}size\textquotesingle{} elements without resizing. Uses hash\+\_\+fn to compute the hash of each element. equals\+\_\+fn to compute equality of two keys. Whenever an element is removed without being returned, destroy\+\_\+key\+\_\+fn is run on the pointer to the key and destroy\+\_\+value\+\_\+fn is run on the pointer to the value. Either or both may be NULL if a callback is not desired in this case. \mbox{\Hypertarget{hash__table_8c_aff4bf82035b05b9b8e976eb919ed6508}\label{hash__table_8c_aff4bf82035b05b9b8e976eb919ed6508}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_is\_valid@{aws\_hash\_table\_is\_valid}}
\index{aws\_hash\_table\_is\_valid@{aws\_hash\_table\_is\_valid}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_is\_valid()}{aws\_hash\_table\_is\_valid()}}
{\footnotesize\ttfamily \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} aws\+\_\+hash\+\_\+table\+\_\+is\+\_\+valid (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map }\end{DoxyParamCaption})}

Best-\/effort check of \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} data-\/structure invariants Some invariants, such as that the number of entries is actually the same as the entry\+\_\+count field, would require a loop to check \mbox{\Hypertarget{hash__table_8c_a442d9979faed0e8fa595803b49c999c7}\label{hash__table_8c_a442d9979faed0e8fa595803b49c999c7}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_move@{aws\_hash\_table\_move}}
\index{aws\_hash\_table\_move@{aws\_hash\_table\_move}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_move()}{aws\_hash\_table\_move()}}
{\footnotesize\ttfamily void aws\+\_\+hash\+\_\+table\+\_\+move (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{to,  }\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{from }\end{DoxyParamCaption})}

Moves the hash table in \textquotesingle{}from\textquotesingle{} to \textquotesingle{}to\textquotesingle{}. After this move, \textquotesingle{}from\textquotesingle{} will be identical to the state of the original \textquotesingle{}to\textquotesingle{} hash table, and \textquotesingle{}to\textquotesingle{} will be in the same state as if it had been passed to aws\+\_\+hash\+\_\+table\+\_\+clean\+\_\+up (that is, it will have no memory allocated, and it will be safe to either discard it or call aws\+\_\+hash\+\_\+table\+\_\+clean\+\_\+up again).

Note that \textquotesingle{}to\textquotesingle{} will not be cleaned up. You should make sure that \textquotesingle{}to\textquotesingle{} is either uninitialized or cleaned up before moving a hashtable into it. \mbox{\Hypertarget{hash__table_8c_a788acdfdb835b839f5f4b2e93bf0e14c}\label{hash__table_8c_a788acdfdb835b839f5f4b2e93bf0e14c}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_put@{aws\_hash\_table\_put}}
\index{aws\_hash\_table\_put@{aws\_hash\_table\_put}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_put()}{aws\_hash\_table\_put()}}
{\footnotesize\ttfamily \mbox{\hyperlink{crt_2aws-crt-cpp_2crt_2aws-c-common_2include_2aws_2common_2_exports_8h_a4d44553ff7ad58c9718deb08c64c49a6}{AWS\+\_\+\+COMMON\+\_\+\+API}} int aws\+\_\+hash\+\_\+table\+\_\+put (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map,  }\item[{const void $\ast$}]{key,  }\item[{void $\ast$}]{value,  }\item[{int $\ast$}]{was\+\_\+created }\end{DoxyParamCaption})}

Inserts a new element at key, with the given value. If another element exists at that key, the old element will be overwritten; both old key and value objects will be destroyed.

If was\+\_\+created is non-\/\+NULL, $\ast$was\+\_\+created is set to 0 if an existing element was found, or 1 is a new element was created.

Returns AWS\+\_\+\+OP\+\_\+\+SUCCESS if an item was found or created. Raises AWS\+\_\+\+ERROR\+\_\+\+OOM if hash table expansion was required and memory \mbox{\Hypertarget{hash__table_8c_ab95ad2e4f6f0630861b91ea08b4b2244}\label{hash__table_8c_ab95ad2e4f6f0630861b91ea08b4b2244}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_remove@{aws\_hash\_table\_remove}}
\index{aws\_hash\_table\_remove@{aws\_hash\_table\_remove}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_remove()}{aws\_hash\_table\_remove()}}
{\footnotesize\ttfamily int aws\+\_\+hash\+\_\+table\+\_\+remove (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map,  }\item[{const void $\ast$}]{key,  }\item[{struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$}]{p\+\_\+value,  }\item[{int $\ast$}]{was\+\_\+present }\end{DoxyParamCaption})}

Removes element at key. Always returns AWS\+\_\+\+OP\+\_\+\+SUCCESS.

If p\+Value is non-\/\+NULL, the existing value (if any) is moved into ($\ast$value) before removing from the table, and destroy\+\_\+fn is {\itshape not} invoked. If p\+Value is NULL, then (if the element existed) destroy\+\_\+fn will be invoked on the element being removed.

If was\+\_\+present is non-\/\+NULL, it is set to 0 if the element was not present, or 1 if it was present (and is now removed). \mbox{\Hypertarget{hash__table_8c_a9637fcb9a2d525a1c492b8bdee105928}\label{hash__table_8c_a9637fcb9a2d525a1c492b8bdee105928}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_remove\_element@{aws\_hash\_table\_remove\_element}}
\index{aws\_hash\_table\_remove\_element@{aws\_hash\_table\_remove\_element}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_remove\_element()}{aws\_hash\_table\_remove\_element()}}
{\footnotesize\ttfamily int aws\+\_\+hash\+\_\+table\+\_\+remove\+\_\+element (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map,  }\item[{struct \mbox{\hyperlink{structaws__hash__element}{aws\+\_\+hash\+\_\+element}} $\ast$}]{p\+\_\+value }\end{DoxyParamCaption})}

Removes element already known (typically by find()).

p\+\_\+value should point to a valid element returned by create() or find().

NOTE\+: DO NOT call this method from inside of a aws\+\_\+hash\+\_\+table\+\_\+foreach callback, return AWS\+\_\+\+COMMON\+\_\+\+HASH\+\_\+\+TABLE\+\_\+\+ITER\+\_\+\+DELETE instead. \mbox{\Hypertarget{hash__table_8c_a8acda923a9a3eb7cbdb1c936b89db777}\label{hash__table_8c_a8acda923a9a3eb7cbdb1c936b89db777}} 
\index{hash\_table.c@{hash\_table.c}!aws\_hash\_table\_swap@{aws\_hash\_table\_swap}}
\index{aws\_hash\_table\_swap@{aws\_hash\_table\_swap}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_hash\_table\_swap()}{aws\_hash\_table\_swap()}}
{\footnotesize\ttfamily void aws\+\_\+hash\+\_\+table\+\_\+swap (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{a,  }\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{b }\end{DoxyParamCaption})}

Safely swaps two hash tables. Note that we swap the entirety of the hash table, including which allocator is associated.

Neither hash table is required to be initialized; if one or both is uninitialized, then the uninitialized state is also swapped. \mbox{\Hypertarget{hash__table_8c_a4d9ea528c0f119a03ba088b04134a0c1}\label{hash__table_8c_a4d9ea528c0f119a03ba088b04134a0c1}} 
\index{hash\_table.c@{hash\_table.c}!aws\_ptr\_eq@{aws\_ptr\_eq}}
\index{aws\_ptr\_eq@{aws\_ptr\_eq}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{aws\_ptr\_eq()}{aws\_ptr\_eq()}}
{\footnotesize\ttfamily \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} aws\+\_\+ptr\+\_\+eq (\begin{DoxyParamCaption}\item[{const void $\ast$}]{a,  }\item[{const void $\ast$}]{b }\end{DoxyParamCaption})}

Equality function which compares pointer equality. \mbox{\Hypertarget{hash__table_8c_aeb6b02b5404af6dc40439723eb0aed96}\label{hash__table_8c_aeb6b02b5404af6dc40439723eb0aed96}} 
\index{hash\_table.c@{hash\_table.c}!hash\_table\_state\_is\_valid@{hash\_table\_state\_is\_valid}}
\index{hash\_table\_state\_is\_valid@{hash\_table\_state\_is\_valid}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{hash\_table\_state\_is\_valid()}{hash\_table\_state\_is\_valid()}}
{\footnotesize\ttfamily \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} hash\+\_\+table\+\_\+state\+\_\+is\+\_\+valid (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{map }\end{DoxyParamCaption})}

Best-\/effort check of \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} data-\/structure invariants Some invariants, such as that the number of entries is actually the same as the entry\+\_\+count field, would require a loop to check \mbox{\Hypertarget{hash__table_8c_a25f43ce27f9e6fe672a4ba05390a2de8}\label{hash__table_8c_a25f43ce27f9e6fe672a4ba05390a2de8}} 
\index{hash\_table.c@{hash\_table.c}!hash\_table\_state\_required\_bytes@{hash\_table\_state\_required\_bytes}}
\index{hash\_table\_state\_required\_bytes@{hash\_table\_state\_required\_bytes}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{hash\_table\_state\_required\_bytes()}{hash\_table\_state\_required\_bytes()}}
{\footnotesize\ttfamily int hash\+\_\+table\+\_\+state\+\_\+required\+\_\+bytes (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size,  }\item[{size\+\_\+t $\ast$}]{required\+\_\+bytes }\end{DoxyParamCaption})}

Determine the total number of bytes needed for a hash-\/table with \char`\"{}size\char`\"{} slots. If the result would overflow a size\+\_\+t, return AWS\+\_\+\+OP\+\_\+\+ERR; otherwise, return AWS\+\_\+\+OP\+\_\+\+SUCCESS with the result in \char`\"{}required\+\_\+bytes\char`\"{}. \mbox{\Hypertarget{hash__table_8c_a002334628277b55444ce6201dc75b84d}\label{hash__table_8c_a002334628277b55444ce6201dc75b84d}} 
\index{hash\_table.c@{hash\_table.c}!s\_alloc\_state@{s\_alloc\_state}}
\index{s\_alloc\_state@{s\_alloc\_state}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_alloc\_state()}{s\_alloc\_state()}}
{\footnotesize\ttfamily static struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}}$\ast$ s\+\_\+alloc\+\_\+state (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{template }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{hash__table_8c_a563547acbf4174ed833d1612fa7b3681}\label{hash__table_8c_a563547acbf4174ed833d1612fa7b3681}} 
\index{hash\_table.c@{hash\_table.c}!s\_emplace\_item@{s\_emplace\_item}}
\index{s\_emplace\_item@{s\_emplace\_item}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_emplace\_item()}{s\_emplace\_item()}}
{\footnotesize\ttfamily static struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}}$\ast$ s\+\_\+emplace\+\_\+item (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{state,  }\item[{struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}}}]{entry,  }\item[{size\+\_\+t}]{probe\+\_\+idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Attempts to find a home for the given entry. If the entry was empty (i.\+e. hash-\/code of 0), then the function does nothing and returns NULL Otherwise, it emplaces the item, and returns a pointer to the newly emplaced entry. This function is only called after the hash-\/table has been expanded to fit the new element, so it should never fail. \mbox{\Hypertarget{hash__table_8c_ae024373fee08d60715c9e1823802deea}\label{hash__table_8c_ae024373fee08d60715c9e1823802deea}} 
\index{hash\_table.c@{hash\_table.c}!s\_expand\_table@{s\_expand\_table}}
\index{s\_expand\_table@{s\_expand\_table}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_expand\_table()}{s\_expand\_table()}}
{\footnotesize\ttfamily static int s\+\_\+expand\+\_\+table (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__table}{aws\+\_\+hash\+\_\+table}} $\ast$}]{map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{hash__table_8c_a759b1bb970808dd34206eff6a6e38ebc}\label{hash__table_8c_a759b1bb970808dd34206eff6a6e38ebc}} 
\index{hash\_table.c@{hash\_table.c}!s\_find\_entry@{s\_find\_entry}}
\index{s\_find\_entry@{s\_find\_entry}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_find\_entry()}{s\_find\_entry()}}
{\footnotesize\ttfamily static int s\+\_\+find\+\_\+entry (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{state,  }\item[{uint64\+\_\+t}]{hash\+\_\+code,  }\item[{const void $\ast$}]{key,  }\item[{struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} $\ast$$\ast$}]{p\+\_\+entry,  }\item[{size\+\_\+t $\ast$}]{p\+\_\+probe\+\_\+idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

\mbox{\Hypertarget{hash__table_8c_a07357c5a65d1919cce9a144a84e3cb2a}\label{hash__table_8c_a07357c5a65d1919cce9a144a84e3cb2a}} 
\index{hash\_table.c@{hash\_table.c}!s\_find\_entry1@{s\_find\_entry1}}
\index{s\_find\_entry1@{s\_find\_entry1}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_find\_entry1()}{s\_find\_entry1()}}
{\footnotesize\ttfamily static int s\+\_\+find\+\_\+entry1 (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{state,  }\item[{uint64\+\_\+t}]{hash\+\_\+code,  }\item[{const void $\ast$}]{key,  }\item[{struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} $\ast$$\ast$}]{p\+\_\+entry,  }\item[{size\+\_\+t $\ast$}]{p\+\_\+probe\+\_\+idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{hash__table_8c_ab0e8a83f32f397f9b4df4bb4dc235335}\label{hash__table_8c_ab0e8a83f32f397f9b4df4bb4dc235335}} 
\index{hash\_table.c@{hash\_table.c}!s\_get\_next\_element@{s\_get\_next\_element}}
\index{s\_get\_next\_element@{s\_get\_next\_element}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_get\_next\_element()}{s\_get\_next\_element()}}
{\footnotesize\ttfamily static void s\+\_\+get\+\_\+next\+\_\+element (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__hash__iter}{aws\+\_\+hash\+\_\+iter}} $\ast$}]{iter,  }\item[{size\+\_\+t}]{start\+\_\+slot }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Given an iterator, and a start slot, find the next available filled slot if it exists Otherwise, return an iter that will return true for \mbox{\hyperlink{hash__table_8c_a9fa88a2db73cd7a9fc8a4e14d1a152e2}{aws\+\_\+hash\+\_\+iter\+\_\+done()}}. Note that \mbox{\hyperlink{hash__table_8c_a855920523cd1b94f984d6fee66f637cb}{aws\+\_\+hash\+\_\+iter\+\_\+is\+\_\+valid()}} need not hold on entry to the function, since it can be called on a partially constructed iter from \mbox{\hyperlink{hash__table_8c_ab556a28dc6a88d729577c720209d3fe9}{aws\+\_\+hash\+\_\+iter\+\_\+begin()}}.

Note that calling this on an iterator which is \char`\"{}done\char`\"{} is idempotent\+: it will return another iterator which is \char`\"{}done\char`\"{}. \mbox{\Hypertarget{hash__table_8c_a4742604a69a60e8cd2744c856f895122}\label{hash__table_8c_a4742604a69a60e8cd2744c856f895122}} 
\index{hash\_table.c@{hash\_table.c}!s\_hash\_for@{s\_hash\_for}}
\index{s\_hash\_for@{s\_hash\_for}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_hash\_for()}{s\_hash\_for()}}
{\footnotesize\ttfamily static uint64\+\_\+t s\+\_\+hash\+\_\+for (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{state,  }\item[{const void $\ast$}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculate the hash for the given key. Ensures a reasonable semantics for null keys. Ensures that no object ever hashes to 0, which is the sentinal value for an empty hash element. \mbox{\Hypertarget{hash__table_8c_a0aa46b3c406c3de80068eb1f64b36699}\label{hash__table_8c_a0aa46b3c406c3de80068eb1f64b36699}} 
\index{hash\_table.c@{hash\_table.c}!s\_hash\_keys\_eq@{s\_hash\_keys\_eq}}
\index{s\_hash\_keys\_eq@{s\_hash\_keys\_eq}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_hash\_keys\_eq()}{s\_hash\_keys\_eq()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} s\+\_\+hash\+\_\+keys\+\_\+eq (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{state,  }\item[{const void $\ast$}]{a,  }\item[{const void $\ast$}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Check equality of two hash keys, with a reasonable semantics for null keys. \mbox{\Hypertarget{hash__table_8c_ae0c02d6f56e2810eb8eac36976fa76d6}\label{hash__table_8c_ae0c02d6f56e2810eb8eac36976fa76d6}} 
\index{hash\_table.c@{hash\_table.c}!s\_index\_for@{s\_index\_for}}
\index{s\_index\_for@{s\_index\_for}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_index\_for()}{s\_index\_for()}}
{\footnotesize\ttfamily static size\+\_\+t s\+\_\+index\+\_\+for (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{map,  }\item[{struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} $\ast$}]{entry }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{hash__table_8c_a4f41dca3338ae7e3fa5bd8e24aeb2f8d}\label{hash__table_8c_a4f41dca3338ae7e3fa5bd8e24aeb2f8d}} 
\index{hash\_table.c@{hash\_table.c}!s\_remove\_entry@{s\_remove\_entry}}
\index{s\_remove\_entry@{s\_remove\_entry}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_remove\_entry()}{s\_remove\_entry()}}
{\footnotesize\ttfamily static size\+\_\+t s\+\_\+remove\+\_\+entry (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{state,  }\item[{struct \mbox{\hyperlink{structhash__table__entry}{hash\+\_\+table\+\_\+entry}} $\ast$}]{entry }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{hash__table_8c_a4ff62d8b2be59292bf3b6c8bc31af3f2}\label{hash__table_8c_a4ff62d8b2be59292bf3b6c8bc31af3f2}} 
\index{hash\_table.c@{hash\_table.c}!s\_safe\_eq\_check@{s\_safe\_eq\_check}}
\index{s\_safe\_eq\_check@{s\_safe\_eq\_check}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_safe\_eq\_check()}{s\_safe\_eq\_check()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{preamble_8h_a1062901a7428fdd9c7f180f5e01ea056}{bool}} s\+\_\+safe\+\_\+eq\+\_\+check (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{hash__table_8h_aa4c204703f44b4d6416c26fee7b6cc20}{aws\+\_\+hash\+\_\+callback\+\_\+eq\+\_\+fn}} $\ast$}]{equals\+\_\+fn,  }\item[{const void $\ast$}]{a,  }\item[{const void $\ast$}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Check equality of two objects, with a reasonable semantics for null. \mbox{\Hypertarget{hash__table_8c_a561e18750dd4238e34b9a4ebe413272d}\label{hash__table_8c_a561e18750dd4238e34b9a4ebe413272d}} 
\index{hash\_table.c@{hash\_table.c}!s\_suppress\_unused\_lookup3\_func\_warnings@{s\_suppress\_unused\_lookup3\_func\_warnings}}
\index{s\_suppress\_unused\_lookup3\_func\_warnings@{s\_suppress\_unused\_lookup3\_func\_warnings}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_suppress\_unused\_lookup3\_func\_warnings()}{s\_suppress\_unused\_lookup3\_func\_warnings()}}
{\footnotesize\ttfamily static void s\+\_\+suppress\+\_\+unused\+\_\+lookup3\+\_\+func\+\_\+warnings (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Copyright Amazon.\+com, Inc. or its affiliates. All Rights Reserved. SPDX-\/\+License-\/\+Identifier\+: Apache-\/2.\+0. \mbox{\Hypertarget{hash__table_8c_ab5020efe920b50287f9ce9d6d7202d72}\label{hash__table_8c_ab5020efe920b50287f9ce9d6d7202d72}} 
\index{hash\_table.c@{hash\_table.c}!s\_update\_template\_size@{s\_update\_template\_size}}
\index{s\_update\_template\_size@{s\_update\_template\_size}!hash\_table.c@{hash\_table.c}}
\doxysubsubsection{\texorpdfstring{s\_update\_template\_size()}{s\_update\_template\_size()}}
{\footnotesize\ttfamily static int s\+\_\+update\+\_\+template\+\_\+size (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structhash__table__state}{hash\+\_\+table\+\_\+state}} $\ast$}]{template,  }\item[{size\+\_\+t}]{expected\+\_\+elements }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

