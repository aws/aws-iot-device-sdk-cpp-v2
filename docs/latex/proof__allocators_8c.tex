\hypertarget{proof__allocators_8c}{}\doxysection{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/verification/cbmc/sources/proof\+\_\+allocators.c File Reference}
\label{proof__allocators_8c}\index{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/verification/cbmc/sources/proof\_allocators.c@{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/verification/cbmc/sources/proof\_allocators.c}}
{\ttfamily \#include $<$aws/common/math.\+h$>$}\newline
{\ttfamily \#include $<$proof\+\_\+helpers/proof\+\_\+allocators.\+h$>$}\newline
{\ttfamily \#include $<$stdarg.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{proof__allocators_8c_a2018652bc4666fe36748e88f3ce3a001}{AWS\+\_\+\+ALIGN\+\_\+\+ROUND\+\_\+\+UP}}(value,  alignment)~(((value) + ((alignment)-\/1)) \& $\sim$((alignment)-\/1))
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static void $\ast$ \mbox{\hyperlink{proof__allocators_8c_a495bffebce723b2ebbc91c70d05ec0f1}{s\+\_\+can\+\_\+fail\+\_\+calloc\+\_\+allocator}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, size\+\_\+t num, size\+\_\+t size)
\item 
static void $\ast$ \mbox{\hyperlink{proof__allocators_8c_aee76a6692db0d68a34777e369345a6cd}{s\+\_\+can\+\_\+fail\+\_\+malloc\+\_\+allocator}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, size\+\_\+t size)
\item 
static void \mbox{\hyperlink{proof__allocators_8c_a2d3103bf7e77f83b431a9c5086e886b3}{s\+\_\+can\+\_\+fail\+\_\+free\+\_\+allocator}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, void $\ast$ptr)
\item 
static void $\ast$ \mbox{\hyperlink{proof__allocators_8c_a60a80681d444e975a11741f1725cb4ce}{s\+\_\+can\+\_\+fail\+\_\+realloc\+\_\+allocator}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, void $\ast$ptr, size\+\_\+t oldsize, size\+\_\+t newsize)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8c_aef817d036f3a738bc0a9421516367200}{bounded\+\_\+calloc}} (size\+\_\+t num, size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8c_ab3dbc7b96e0fac4e1caa23b4c365bd7c}{bounded\+\_\+malloc}} (size\+\_\+t size)
\item 
struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$ \mbox{\hyperlink{proof__allocators_8c_a7a9308e08c67eda215f3760da5b7b407}{can\+\_\+fail\+\_\+allocator}} ()
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8c_a1155485865621f39fac3967ce334123c}{can\+\_\+fail\+\_\+calloc}} (size\+\_\+t num, size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8c_aaa127ec3bf84bdf0e9274082aa3c7354}{can\+\_\+fail\+\_\+malloc}} (size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8c_a02f33782e5f8451ec09e3ea847a89368}{can\+\_\+fail\+\_\+realloc}} (void $\ast$ptr, size\+\_\+t newsize)
\item 
bool \mbox{\hyperlink{proof__allocators_8c_aff8b14190e01cf699a1fb9024ec5e77c}{aws\+\_\+allocator\+\_\+is\+\_\+valid}} (const struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$alloc)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8c_a128d6f252b6e3784caf47005033ee2c7}{aws\+\_\+mem\+\_\+acquire}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8c_abfff75642e6495447bed6ed9054fc11f}{aws\+\_\+mem\+\_\+calloc}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, size\+\_\+t num, size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{proof__allocators_8c_a60bb853519cb92f1baeef9d8ad4f72f1}{aws\+\_\+mem\+\_\+acquire\+\_\+many}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_ad43c3812e6d13e0518d9f8b8f463ffcf}{count}},...)
\item 
void \mbox{\hyperlink{proof__allocators_8c_ac655f22debddaf1b9d18935aee2cfafe}{aws\+\_\+mem\+\_\+release}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, void $\ast$ptr)
\item 
int \mbox{\hyperlink{proof__allocators_8c_aac151e9c85ddb43fdce0acd676c22fbf}{aws\+\_\+mem\+\_\+realloc}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, void $\ast$$\ast$ptr, size\+\_\+t oldsize, size\+\_\+t newsize)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} \mbox{\hyperlink{proof__allocators_8c_a3dc56e6ccdbadb0558f2432820c0a654}{s\+\_\+can\+\_\+fail\+\_\+allocator\+\_\+static}}
\end{DoxyCompactItemize}


\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{proof__allocators_8c_a2018652bc4666fe36748e88f3ce3a001}\label{proof__allocators_8c_a2018652bc4666fe36748e88f3ce3a001}} 
\index{proof\_allocators.c@{proof\_allocators.c}!AWS\_ALIGN\_ROUND\_UP@{AWS\_ALIGN\_ROUND\_UP}}
\index{AWS\_ALIGN\_ROUND\_UP@{AWS\_ALIGN\_ROUND\_UP}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{AWS\_ALIGN\_ROUND\_UP}{AWS\_ALIGN\_ROUND\_UP}}
{\footnotesize\ttfamily \#define AWS\+\_\+\+ALIGN\+\_\+\+ROUND\+\_\+\+UP(\begin{DoxyParamCaption}\item[{}]{value,  }\item[{}]{alignment }\end{DoxyParamCaption})~(((value) + ((alignment)-\/1)) \& $\sim$((alignment)-\/1))}



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{proof__allocators_8c_aff8b14190e01cf699a1fb9024ec5e77c}\label{proof__allocators_8c_aff8b14190e01cf699a1fb9024ec5e77c}} 
\index{proof\_allocators.c@{proof\_allocators.c}!aws\_allocator\_is\_valid@{aws\_allocator\_is\_valid}}
\index{aws\_allocator\_is\_valid@{aws\_allocator\_is\_valid}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{aws\_allocator\_is\_valid()}{aws\_allocator\_is\_valid()}}
{\footnotesize\ttfamily bool aws\+\_\+allocator\+\_\+is\+\_\+valid (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{alloc }\end{DoxyParamCaption})}

This assert will fail if code ever uses a different allocator than expected during a proof \mbox{\Hypertarget{proof__allocators_8c_a128d6f252b6e3784caf47005033ee2c7}\label{proof__allocators_8c_a128d6f252b6e3784caf47005033ee2c7}} 
\index{proof\_allocators.c@{proof\_allocators.c}!aws\_mem\_acquire@{aws\_mem\_acquire}}
\index{aws\_mem\_acquire@{aws\_mem\_acquire}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{aws\_mem\_acquire()}{aws\_mem\_acquire()}}
{\footnotesize\ttfamily void$\ast$ aws\+\_\+mem\+\_\+acquire (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

Returns at least {\ttfamily size} of memory ready for usage or returns NULL on failure. \mbox{\Hypertarget{proof__allocators_8c_a60bb853519cb92f1baeef9d8ad4f72f1}\label{proof__allocators_8c_a60bb853519cb92f1baeef9d8ad4f72f1}} 
\index{proof\_allocators.c@{proof\_allocators.c}!aws\_mem\_acquire\_many@{aws\_mem\_acquire\_many}}
\index{aws\_mem\_acquire\_many@{aws\_mem\_acquire\_many}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{aws\_mem\_acquire\_many()}{aws\_mem\_acquire\_many()}}
{\footnotesize\ttfamily void$\ast$ aws\+\_\+mem\+\_\+acquire\+\_\+many (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{size\+\_\+t}]{count,  }\item[{}]{... }\end{DoxyParamCaption})}

Allocates many chunks of bytes into a single block. Expects to be called with alternating void $\ast$$\ast$ (dest), size\+\_\+t (size). The first void $\ast$$\ast$ will be set to the root of the allocation. Alignment is assumed to be sizeof(intmax\+\_\+t).

This is useful for allocating structs using the pimpl pattern, as you may allocate the public object and impl object in the same contiguous block of memory.

Returns a pointer to the allocation. \mbox{\Hypertarget{proof__allocators_8c_abfff75642e6495447bed6ed9054fc11f}\label{proof__allocators_8c_abfff75642e6495447bed6ed9054fc11f}} 
\index{proof\_allocators.c@{proof\_allocators.c}!aws\_mem\_calloc@{aws\_mem\_calloc}}
\index{aws\_mem\_calloc@{aws\_mem\_calloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{aws\_mem\_calloc()}{aws\_mem\_calloc()}}
{\footnotesize\ttfamily void$\ast$ aws\+\_\+mem\+\_\+calloc (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{size\+\_\+t}]{num,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

Allocates a block of memory for an array of num elements, each of them size bytes long, and initializes all its bits to zero. Returns null on failure. \mbox{\Hypertarget{proof__allocators_8c_aac151e9c85ddb43fdce0acd676c22fbf}\label{proof__allocators_8c_aac151e9c85ddb43fdce0acd676c22fbf}} 
\index{proof\_allocators.c@{proof\_allocators.c}!aws\_mem\_realloc@{aws\_mem\_realloc}}
\index{aws\_mem\_realloc@{aws\_mem\_realloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{aws\_mem\_realloc()}{aws\_mem\_realloc()}}
{\footnotesize\ttfamily int aws\+\_\+mem\+\_\+realloc (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{void $\ast$$\ast$}]{ptr,  }\item[{size\+\_\+t}]{oldsize,  }\item[{size\+\_\+t}]{newsize }\end{DoxyParamCaption})}

\mbox{\Hypertarget{proof__allocators_8c_ac655f22debddaf1b9d18935aee2cfafe}\label{proof__allocators_8c_ac655f22debddaf1b9d18935aee2cfafe}} 
\index{proof\_allocators.c@{proof\_allocators.c}!aws\_mem\_release@{aws\_mem\_release}}
\index{aws\_mem\_release@{aws\_mem\_release}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{aws\_mem\_release()}{aws\_mem\_release()}}
{\footnotesize\ttfamily void aws\+\_\+mem\+\_\+release (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{void $\ast$}]{ptr }\end{DoxyParamCaption})}

Releases ptr back to whatever allocated it. Nothing happens if ptr is NULL. \mbox{\Hypertarget{proof__allocators_8c_aef817d036f3a738bc0a9421516367200}\label{proof__allocators_8c_aef817d036f3a738bc0a9421516367200}} 
\index{proof\_allocators.c@{proof\_allocators.c}!bounded\_calloc@{bounded\_calloc}}
\index{bounded\_calloc@{bounded\_calloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{bounded\_calloc()}{bounded\_calloc()}}
{\footnotesize\ttfamily void$\ast$ bounded\+\_\+calloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{num,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of calloc always succeeds, even if the requested size is larger than CBMC can internally represent. This function does a \+\_\+\+\_\+\+CPROVER\+\_\+assume(size \texorpdfstring{$<$}{<}= MAX\+\_\+\+MALLOC); before calling calloc, and hence will never return an invalid pointer. \mbox{\Hypertarget{proof__allocators_8c_ab3dbc7b96e0fac4e1caa23b4c365bd7c}\label{proof__allocators_8c_ab3dbc7b96e0fac4e1caa23b4c365bd7c}} 
\index{proof\_allocators.c@{proof\_allocators.c}!bounded\_malloc@{bounded\_malloc}}
\index{bounded\_malloc@{bounded\_malloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{bounded\_malloc()}{bounded\_malloc()}}
{\footnotesize\ttfamily void$\ast$ bounded\+\_\+malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of malloc always succeeds, even if the requested size is larger than CBMC can internally represent. This function does a \+\_\+\+\_\+\+CPROVER\+\_\+assume(size \texorpdfstring{$<$}{<}= MAX\+\_\+\+MALLOC); before calling malloc, and hence will never return an invalid pointer. \mbox{\Hypertarget{proof__allocators_8c_a7a9308e08c67eda215f3760da5b7b407}\label{proof__allocators_8c_a7a9308e08c67eda215f3760da5b7b407}} 
\index{proof\_allocators.c@{proof\_allocators.c}!can\_fail\_allocator@{can\_fail\_allocator}}
\index{can\_fail\_allocator@{can\_fail\_allocator}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{can\_fail\_allocator()}{can\_fail\_allocator()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}}$\ast$ can\+\_\+fail\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Implemenation of \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} specalized to allow CBMC to find as many bugs as possible \mbox{\Hypertarget{proof__allocators_8c_a1155485865621f39fac3967ce334123c}\label{proof__allocators_8c_a1155485865621f39fac3967ce334123c}} 
\index{proof\_allocators.c@{proof\_allocators.c}!can\_fail\_calloc@{can\_fail\_calloc}}
\index{can\_fail\_calloc@{can\_fail\_calloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{can\_fail\_calloc()}{can\_fail\_calloc()}}
{\footnotesize\ttfamily void$\ast$ can\+\_\+fail\+\_\+calloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{num,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of calloc never returns NULL, which can mask bugs in C programs. Thus function\+: 1) Deterministically returns NULL if more memory is requested than CBMC can represent 2) Nondeterminstically returns either valid memory or NULL otherwise \mbox{\Hypertarget{proof__allocators_8c_aaa127ec3bf84bdf0e9274082aa3c7354}\label{proof__allocators_8c_aaa127ec3bf84bdf0e9274082aa3c7354}} 
\index{proof\_allocators.c@{proof\_allocators.c}!can\_fail\_malloc@{can\_fail\_malloc}}
\index{can\_fail\_malloc@{can\_fail\_malloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{can\_fail\_malloc()}{can\_fail\_malloc()}}
{\footnotesize\ttfamily void$\ast$ can\+\_\+fail\+\_\+malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of malloc never returns NULL, which can mask bugs in C programs. Thus function\+: 1) Deterministically returns NULL if more memory is requested than CBMC can represent 2) Nondeterminstically returns either valid memory or NULL otherwise \mbox{\Hypertarget{proof__allocators_8c_a02f33782e5f8451ec09e3ea847a89368}\label{proof__allocators_8c_a02f33782e5f8451ec09e3ea847a89368}} 
\index{proof\_allocators.c@{proof\_allocators.c}!can\_fail\_realloc@{can\_fail\_realloc}}
\index{can\_fail\_realloc@{can\_fail\_realloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{can\_fail\_realloc()}{can\_fail\_realloc()}}
{\footnotesize\ttfamily void$\ast$ can\+\_\+fail\+\_\+realloc (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr,  }\item[{size\+\_\+t}]{newsize }\end{DoxyParamCaption})}

\href{https://en.cppreference.com/w/c/memory/realloc}{\texttt{ https\+://en.\+cppreference.\+com/w/c/memory/realloc}} If there is not enough memory, the old memory block is not freed and null pointer is returned.

If ptr is NULL, the behavior is the same as calling malloc(new\+\_\+size).

If new\+\_\+size is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-\/null pointer may be returned that may not be used to access storage). \mbox{\Hypertarget{proof__allocators_8c_a495bffebce723b2ebbc91c70d05ec0f1}\label{proof__allocators_8c_a495bffebce723b2ebbc91c70d05ec0f1}} 
\index{proof\_allocators.c@{proof\_allocators.c}!s\_can\_fail\_calloc\_allocator@{s\_can\_fail\_calloc\_allocator}}
\index{s\_can\_fail\_calloc\_allocator@{s\_can\_fail\_calloc\_allocator}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{s\_can\_fail\_calloc\_allocator()}{s\_can\_fail\_calloc\_allocator()}}
{\footnotesize\ttfamily static void$\ast$ s\+\_\+can\+\_\+fail\+\_\+calloc\+\_\+allocator (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{size\+\_\+t}]{num,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Copyright Amazon.\+com, Inc. or its affiliates. All Rights Reserved. SPDX-\/\+License-\/\+Identifier\+: Apache-\/2.\+0. Use the \mbox{\hyperlink{proof__allocators_8c_a1155485865621f39fac3967ce334123c}{can\+\_\+fail\+\_\+calloc()}} defined above to specalize allocation for finding bugs using CBMC \mbox{\Hypertarget{proof__allocators_8c_a2d3103bf7e77f83b431a9c5086e886b3}\label{proof__allocators_8c_a2d3103bf7e77f83b431a9c5086e886b3}} 
\index{proof\_allocators.c@{proof\_allocators.c}!s\_can\_fail\_free\_allocator@{s\_can\_fail\_free\_allocator}}
\index{s\_can\_fail\_free\_allocator@{s\_can\_fail\_free\_allocator}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{s\_can\_fail\_free\_allocator()}{s\_can\_fail\_free\_allocator()}}
{\footnotesize\ttfamily static void s\+\_\+can\+\_\+fail\+\_\+free\+\_\+allocator (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{void $\ast$}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Since we always allocate with \char`\"{}malloc()\char`\"{}, just free with \char`\"{}free()\char`\"{} \mbox{\Hypertarget{proof__allocators_8c_aee76a6692db0d68a34777e369345a6cd}\label{proof__allocators_8c_aee76a6692db0d68a34777e369345a6cd}} 
\index{proof\_allocators.c@{proof\_allocators.c}!s\_can\_fail\_malloc\_allocator@{s\_can\_fail\_malloc\_allocator}}
\index{s\_can\_fail\_malloc\_allocator@{s\_can\_fail\_malloc\_allocator}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{s\_can\_fail\_malloc\_allocator()}{s\_can\_fail\_malloc\_allocator()}}
{\footnotesize\ttfamily static void$\ast$ s\+\_\+can\+\_\+fail\+\_\+malloc\+\_\+allocator (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Use the \mbox{\hyperlink{proof__allocators_8c_aaa127ec3bf84bdf0e9274082aa3c7354}{can\+\_\+fail\+\_\+malloc()}} defined above to specalize allocation for finding bugs using CBMC \mbox{\Hypertarget{proof__allocators_8c_a60a80681d444e975a11741f1725cb4ce}\label{proof__allocators_8c_a60a80681d444e975a11741f1725cb4ce}} 
\index{proof\_allocators.c@{proof\_allocators.c}!s\_can\_fail\_realloc\_allocator@{s\_can\_fail\_realloc\_allocator}}
\index{s\_can\_fail\_realloc\_allocator@{s\_can\_fail\_realloc\_allocator}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{s\_can\_fail\_realloc\_allocator()}{s\_can\_fail\_realloc\_allocator()}}
{\footnotesize\ttfamily static void$\ast$ s\+\_\+can\+\_\+fail\+\_\+realloc\+\_\+allocator (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{void $\ast$}]{ptr,  }\item[{size\+\_\+t}]{oldsize,  }\item[{size\+\_\+t}]{newsize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Use the \mbox{\hyperlink{proof__allocators_8c_a02f33782e5f8451ec09e3ea847a89368}{can\+\_\+fail\+\_\+realloc()}} defined above to specalize allocation for finding bugs using CBMC 

\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{proof__allocators_8c_a3dc56e6ccdbadb0558f2432820c0a654}\label{proof__allocators_8c_a3dc56e6ccdbadb0558f2432820c0a654}} 
\index{proof\_allocators.c@{proof\_allocators.c}!s\_can\_fail\_allocator\_static@{s\_can\_fail\_allocator\_static}}
\index{s\_can\_fail\_allocator\_static@{s\_can\_fail\_allocator\_static}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{s\_can\_fail\_allocator\_static}{s\_can\_fail\_allocator\_static}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} s\+\_\+can\+\_\+fail\+\_\+allocator\+\_\+static\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{= \{}
\DoxyCodeLine{    .mem\_acquire = \mbox{\hyperlink{proof__allocators_8c_aee76a6692db0d68a34777e369345a6cd}{s\_can\_fail\_malloc\_allocator}},}
\DoxyCodeLine{    .mem\_release = \mbox{\hyperlink{proof__allocators_8c_a2d3103bf7e77f83b431a9c5086e886b3}{s\_can\_fail\_free\_allocator}},}
\DoxyCodeLine{    .mem\_realloc = \mbox{\hyperlink{proof__allocators_8c_a60a80681d444e975a11741f1725cb4ce}{s\_can\_fail\_realloc\_allocator}},}
\DoxyCodeLine{    .mem\_calloc = \mbox{\hyperlink{proof__allocators_8c_a495bffebce723b2ebbc91c70d05ec0f1}{s\_can\_fail\_calloc\_allocator}},}
\DoxyCodeLine{\}}

\end{DoxyCode}
