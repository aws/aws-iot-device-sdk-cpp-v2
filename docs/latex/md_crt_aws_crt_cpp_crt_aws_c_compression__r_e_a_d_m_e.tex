This is a cross-\/platform C99 implementation of compression algorithms such as gzip, and huffman encoding/decoding. Currently only huffman is implemented.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md185}{}\doxysection{License}\label{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md185}
This library is licensed under the Apache 2.\+0 License.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md186}{}\doxysection{Usage}\label{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md186}
This library has a strong dependency on \href{https://github.com/awslabs/aws-c-common}{\texttt{ aws-\/c-\/common}}. Please see that repository\textquotesingle{}s \href{https://github.com/awslabs/aws-c-common/blob/master/README.md}{\texttt{ README.\+md}} for information on how to install it.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md187}{}\doxysubsection{Huffman}\label{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md187}
The Huffman implemention in this library is designed around the concept of a generic \char`\"{}symbol coder\char`\"{} object, which defines how each symbol (value between 0 and 255) is encoded and decoded. This object looks like this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structaws__huffman__code}{aws\_huffman\_code}} (*aws\_huffman\_symbol\_encoder)(uint8\_t symbol, \textcolor{keywordtype}{void} *userdata);}
\DoxyCodeLine{\textcolor{keyword}{typedef} uint8\_t (*aws\_huffman\_symbol\_decoder)(uint32\_t bits, uint8\_t *symbol, \textcolor{keywordtype}{void} *userdata);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }\mbox{\hyperlink{structaws__huffman__symbol__coder}{aws\_huffman\_symbol\_coder}} \{}
\DoxyCodeLine{    aws\_huffman\_symbol\_encoder \mbox{\hyperlink{structaws__huffman__symbol__coder_a15964948e4ee352c8a8216d25605f43b}{encode}};}
\DoxyCodeLine{    aws\_huffman\_symbol\_decoder \mbox{\hyperlink{structaws__huffman__symbol__coder_a362a8a7480dfa30d2ea445d71e836055}{decode}};}
\DoxyCodeLine{    \textcolor{keywordtype}{void} *\mbox{\hyperlink{structaws__huffman__symbol__coder_a3dad6e8a1e66f2d22f669a23c3c586ec}{userdata}};}
\DoxyCodeLine{\};}

\end{DoxyCode}
 These callbacks may be implemented manually, or you may use the included Huffman coder generator to generate one from a table definition file. The generator expects to be called with the following arguments\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ aws-\/c-\/compression-\/huffman-\/generator path/to/table.def path/to/generated.c coder\_name}

\end{DoxyCode}


The table definition file should be in the following format\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/*           sym               bits   code len */}}
\DoxyCodeLine{\mbox{\hyperlink{testing_2compression_2huffman_8h_ad33f352c33f5b3fdce87fd856455a905}{HUFFMAN\_CODE}}(  0,      \textcolor{stringliteral}{"{}1100101110"{}}, 0x32e, 10)}
\DoxyCodeLine{\mbox{\hyperlink{testing_2compression_2huffman_8h_ad33f352c33f5b3fdce87fd856455a905}{HUFFMAN\_CODE}}(  1,      "{}1100101111"{}, 0x32f, 10)}
\DoxyCodeLine{\textcolor{comment}{/* ... */}}

\end{DoxyCode}
 The HUFFMAN\+\_\+\+CODE macro expects 4 arguments\+:
\begin{DoxyItemize}
\item sym\+: the symbol value \mbox{[}0-\/255\mbox{]}
\item bits\+: the bits representing the symbol in string form
\item code\+: the bits representing the symbol in numeric form
\item len\+: the number of bits used to represent the symbol
\end{DoxyItemize}

\begin{quote}
\#\#\#\# Note This file may also be {\ttfamily \#include}d in the following way to generate a static list of codes\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/* Provides the HUFFMAN\_CODE macro */}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <\mbox{\hyperlink{testing_2compression_2huffman_8h}{aws/testing/compression/huffman.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{static} \textcolor{keyword}{struct }\mbox{\hyperlink{structhuffman__test__code__point}{huffman\_test\_code\_point}} \mbox{\hyperlink{generator_8c_abed2c35818733bc0405f93692efa135a}{code\_points}}[] = \{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}test\_huffman\_static\_table.def"{}}}
\DoxyCodeLine{\};}

\end{DoxyCode}
 \end{quote}
This will emit a c file which exports a function with the following signiture\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct }\mbox{\hyperlink{structaws__huffman__symbol__coder}{aws\_huffman\_symbol\_coder}} *\{coder\_name\}\_get\_coder();}

\end{DoxyCode}
 Note that this function does not allocate, but maintains a static instance of the coder.

An example implementation of this file is provided in {\ttfamily tests/test\+\_\+huffman\+\_\+static\+\_\+table.\+def}.

To use the coder, forward declare that function, and pass the result as the second argument to {\ttfamily aws\+\_\+huffman\+\_\+encoder\+\_\+init} and {\ttfamily aws\+\_\+huffman\+\_\+decoder\+\_\+init}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct }\mbox{\hyperlink{structaws__huffman__encoder}{aws\_huffman\_encoder}} encoder;}
\DoxyCodeLine{\mbox{\hyperlink{compression_2huffman_8h_aef42048ee2ee54c445163ca4dfb05b84}{aws\_huffman\_encoder\_init}}(\&encoder, \{coder\_name\}\_get\_coder());}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }\mbox{\hyperlink{structaws__huffman__decoder}{aws\_huffman\_decoder}} decoder;}
\DoxyCodeLine{\mbox{\hyperlink{compression_2huffman_8h_acbe357203649d987303f9194d7cf2c7c}{aws\_huffman\_decoder\_init}}(\&decoder, \{coder\_name\}\_get\_coder())}

\end{DoxyCode}
\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md188}{}\doxysubsubsection{Encoding}\label{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md188}

\begin{DoxyCode}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{compression_2huffman_8h_abb6619ecad41953fa7c46a4577a9a6a7}{aws\_huffman\_encode}}(\textcolor{keyword}{struct} \mbox{\hyperlink{structaws__huffman__encoder}{aws\_huffman\_encoder}} *encoder, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *to\_encode, \textcolor{keywordtype}{size\_t} *\mbox{\hyperlink{iocp__event__loop_8c_ae809d5359ac030c60a30a8f0b2294b82}{length}}, uint8\_t *\mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}}, \textcolor{keywordtype}{size\_t} *output\_size);}

\end{DoxyCode}
 The encoder is built to support partial encoding. This means that if there isn\textquotesingle{}t enough space in {\ttfamily output}, the encoder will encode as much as possible, update {\ttfamily length} to indicate how much was consumed, {\ttfamily output\+\_\+size} won\textquotesingle{}t change, and {\ttfamily AWS\+\_\+\+ERROR\+\_\+\+SHORT\+\_\+\+BUFFER} will be raised. {\ttfamily aws\+\_\+huffman\+\_\+encode} may then be called again like the following pseudo-\/code\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} encode\_and\_send(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *to\_encode, \textcolor{keywordtype}{size\_t} size) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{while} (size > 0) \{}
\DoxyCodeLine{        uint8\_t \mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}}[some\_chunk\_size];}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} output\_size = \textcolor{keyword}{sizeof}(\mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}});}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} bytes\_read = size;}
\DoxyCodeLine{        \mbox{\hyperlink{compression_2huffman_8h_abb6619ecad41953fa7c46a4577a9a6a7}{aws\_huffman\_encode}}(encoder, to\_encode, \&bytes\_read, \mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}}, \&output\_size);}
\DoxyCodeLine{        \textcolor{comment}{/* AWS\_ERROR\_SHORT\_BUFFER was raised... */}}
\DoxyCodeLine{        send\_output\_to\_someone\_else(\mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}}, output\_size);}
\DoxyCodeLine{}
\DoxyCodeLine{        to\_encode += bytes\_read;}
\DoxyCodeLine{        size -\/= bytes\_read;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{comment}{/* Be sure to reset the encoder after use */}}
\DoxyCodeLine{    \mbox{\hyperlink{compression_2huffman_8h_a128c1ec79c02828844a9f28d6f52ff9a}{aws\_huffman\_encoder\_reset}}(encoder);}
\DoxyCodeLine{\}}

\end{DoxyCode}


{\ttfamily \mbox{\hyperlink{structaws__huffman__encoder}{aws\+\_\+huffman\+\_\+encoder}}} also has a {\ttfamily uint8\+\_\+t} field called {\ttfamily eos\+\_\+padding} that defines how any unwritten bits in the last byte of output are filled. The most significant bits will used. For example, if the last byte contains only 3 bits and {\ttfamily eos\+\_\+padding} is {\ttfamily 0b01010101}, {\ttfamily 01010} will be appended to the byte.\hypertarget{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md189}{}\doxysubsubsection{Decoding}\label{md_crt_aws_crt_cpp_crt_aws_c_compression__r_e_a_d_m_e_autotoc_md189}

\begin{DoxyCode}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{compression_2huffman_8h_a13f0c95fa9e1f8471f63a19fd402010f}{aws\_huffman\_decode}}(\textcolor{keyword}{struct} \mbox{\hyperlink{structaws__huffman__decoder}{aws\_huffman\_decoder}} *decoder, \textcolor{keyword}{const} uint8\_t *to\_decode, \textcolor{keywordtype}{size\_t} *\mbox{\hyperlink{iocp__event__loop_8c_ae809d5359ac030c60a30a8f0b2294b82}{length}}, \textcolor{keywordtype}{char} *\mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}}, \textcolor{keywordtype}{size\_t} *output\_size);}

\end{DoxyCode}
 The decoder is built to support partial encoding. This means that if there isn\textquotesingle{}t enough space in {\ttfamily output}, the decoder will decode as much as possible, update {\ttfamily length} to indicate how much was consumed, {\ttfamily output\+\_\+size} won\textquotesingle{}t change, and {\ttfamily AWS\+\_\+\+ERROR\+\_\+\+SHORT\+\_\+\+BUFFER} will be raised. {\ttfamily aws\+\_\+huffman\+\_\+decode} may then be called again like the following pseudo-\/code\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} decode\_and\_send(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *to\_decode, \textcolor{keywordtype}{size\_t} size) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{while} (size > 0) \{}
\DoxyCodeLine{        uint8\_t \mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}}[some\_chunk\_size];}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} output\_size = \textcolor{keyword}{sizeof}(\mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}});}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} bytes\_read = size;}
\DoxyCodeLine{        \mbox{\hyperlink{compression_2huffman_8h_a13f0c95fa9e1f8471f63a19fd402010f}{aws\_huffman\_decode}}(decoder, to\_decode, \&bytes\_read, \mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}}, \&output\_size);}
\DoxyCodeLine{        \textcolor{comment}{/* AWS\_ERROR\_SHORT\_BUFFER was raised... */}}
\DoxyCodeLine{        send\_output\_to\_someone\_else(\mbox{\hyperlink{log__formatter__test_8c_ae73289c5189c80c0661459b0f4743217}{output}}, output\_size);}
\DoxyCodeLine{}
\DoxyCodeLine{        to\_decode += bytes\_read;}
\DoxyCodeLine{        size -\/= bytes\_read;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{comment}{/* Be sure to reset the decoder after use */}}
\DoxyCodeLine{    \mbox{\hyperlink{compression_2huffman_8h_a34c1b6073a00cf0933968f7fb9e699bb}{aws\_huffman\_decoder\_reset}}(decoder);}
\DoxyCodeLine{\}}

\end{DoxyCode}


Upon completion of a decode, the most significant bits of {\ttfamily decoder-\/\texorpdfstring{$>$}{>}working\+\_\+bits} will contain the final bits of {\ttfamily to\+\_\+decode} that could not match a symbol. This is useful for verifying the padding bits of a stream. For example, to validate that a stream ends in all 1\textquotesingle{}s (like HPACK requires), you could do the following\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{assert_8h_a2c17f0f768532f761b99a8fee0c656f1}{AWS\_ASSERT}}(decoder-\/>working\_bits == UINT64\_MAX << (64 -\/ decoder-\/>num\_bits));}

\end{DoxyCode}
 