\hypertarget{s2n_2tests_2cbmc_2sources_2proof__allocators_8c}{}\doxysection{crt/aws-\/crt-\/cpp/crt/s2n/tests/cbmc/sources/proof\+\_\+allocators.c File Reference}
\label{s2n_2tests_2cbmc_2sources_2proof__allocators_8c}\index{crt/aws-\/crt-\/cpp/crt/s2n/tests/cbmc/sources/proof\_allocators.c@{crt/aws-\/crt-\/cpp/crt/s2n/tests/cbmc/sources/proof\_allocators.c}}
{\ttfamily \#include $<$cbmc\+\_\+proof/proof\+\_\+allocators.\+h$>$}\newline
{\ttfamily \#include $<$stdarg.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void $\ast$ \mbox{\hyperlink{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_aef817d036f3a738bc0a9421516367200}{bounded\+\_\+calloc}} (size\+\_\+t num, size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_ab3dbc7b96e0fac4e1caa23b4c365bd7c}{bounded\+\_\+malloc}} (size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_a1155485865621f39fac3967ce334123c}{can\+\_\+fail\+\_\+calloc}} (size\+\_\+t num, size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_aaa127ec3bf84bdf0e9274082aa3c7354}{can\+\_\+fail\+\_\+malloc}} (size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_a02f33782e5f8451ec09e3ea847a89368}{can\+\_\+fail\+\_\+realloc}} (void $\ast$ptr, size\+\_\+t newsize)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_aef817d036f3a738bc0a9421516367200}\label{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_aef817d036f3a738bc0a9421516367200}} 
\index{proof\_allocators.c@{proof\_allocators.c}!bounded\_calloc@{bounded\_calloc}}
\index{bounded\_calloc@{bounded\_calloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{bounded\_calloc()}{bounded\_calloc()}}
{\footnotesize\ttfamily void$\ast$ bounded\+\_\+calloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{num,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of calloc always succeeds, even if the requested size is larger than CBMC can internally represent. This function does a \+\_\+\+\_\+\+CPROVER\+\_\+assume(size \texorpdfstring{$<$}{<}= MAX\+\_\+\+MALLOC); before calling calloc, and hence will never return an invalid pointer. \mbox{\Hypertarget{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_ab3dbc7b96e0fac4e1caa23b4c365bd7c}\label{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_ab3dbc7b96e0fac4e1caa23b4c365bd7c}} 
\index{proof\_allocators.c@{proof\_allocators.c}!bounded\_malloc@{bounded\_malloc}}
\index{bounded\_malloc@{bounded\_malloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{bounded\_malloc()}{bounded\_malloc()}}
{\footnotesize\ttfamily void$\ast$ bounded\+\_\+malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of malloc always succeeds, even if the requested size is larger than CBMC can internally represent. This function does a \+\_\+\+\_\+\+CPROVER\+\_\+assume(size \texorpdfstring{$<$}{<}= MAX\+\_\+\+MALLOC); before calling malloc, and hence will never return an invalid pointer. \mbox{\Hypertarget{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_a1155485865621f39fac3967ce334123c}\label{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_a1155485865621f39fac3967ce334123c}} 
\index{proof\_allocators.c@{proof\_allocators.c}!can\_fail\_calloc@{can\_fail\_calloc}}
\index{can\_fail\_calloc@{can\_fail\_calloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{can\_fail\_calloc()}{can\_fail\_calloc()}}
{\footnotesize\ttfamily void$\ast$ can\+\_\+fail\+\_\+calloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{num,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of calloc never returns NULL, which can mask bugs in C programs. Thus function\+: 1) Deterministically returns NULL if more memory is requested than CBMC can represent 2) Nondeterminstically returns either valid memory or NULL otherwise \mbox{\Hypertarget{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_aaa127ec3bf84bdf0e9274082aa3c7354}\label{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_aaa127ec3bf84bdf0e9274082aa3c7354}} 
\index{proof\_allocators.c@{proof\_allocators.c}!can\_fail\_malloc@{can\_fail\_malloc}}
\index{can\_fail\_malloc@{can\_fail\_malloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{can\_fail\_malloc()}{can\_fail\_malloc()}}
{\footnotesize\ttfamily void$\ast$ can\+\_\+fail\+\_\+malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

CBMC model of malloc never returns NULL, which can mask bugs in C programs. Thus function\+: 1) Deterministically returns NULL if more memory is requested than CBMC can represent 2) Nondeterminstically returns either valid memory or NULL otherwise \mbox{\Hypertarget{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_a02f33782e5f8451ec09e3ea847a89368}\label{s2n_2tests_2cbmc_2sources_2proof__allocators_8c_a02f33782e5f8451ec09e3ea847a89368}} 
\index{proof\_allocators.c@{proof\_allocators.c}!can\_fail\_realloc@{can\_fail\_realloc}}
\index{can\_fail\_realloc@{can\_fail\_realloc}!proof\_allocators.c@{proof\_allocators.c}}
\doxysubsubsection{\texorpdfstring{can\_fail\_realloc()}{can\_fail\_realloc()}}
{\footnotesize\ttfamily void$\ast$ can\+\_\+fail\+\_\+realloc (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr,  }\item[{size\+\_\+t}]{newsize }\end{DoxyParamCaption})}

\href{https://en.cppreference.com/w/c/memory/realloc}{\texttt{ https\+://en.\+cppreference.\+com/w/c/memory/realloc}} If there is not enough memory, the old memory block is not freed and null pointer is returned.

If ptr is NULL, the behavior is the same as calling malloc(new\+\_\+size).

If new\+\_\+size is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-\/null pointer may be returned that may not be used to access storage). 