\hypertarget{source_2string_8c}{}\doxysection{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/source/string.c File Reference}
\label{source_2string_8c}\index{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/source/string.c@{crt/aws-\/crt-\/cpp/crt/aws-\/c-\/common/source/string.c}}
{\ttfamily \#include $<$aws/common/string.\+h$>$}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$ \mbox{\hyperlink{source_2string_8c_af0855e6106f8073c9865924475792281}{aws\+\_\+string\+\_\+new\+\_\+from\+\_\+c\+\_\+str}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, const char $\ast$c\+\_\+str)
\item 
struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$ \mbox{\hyperlink{source_2string_8c_ada083f5511da699ce2085d1caa517510}{aws\+\_\+string\+\_\+new\+\_\+from\+\_\+array}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, const uint8\+\_\+t $\ast$bytes, size\+\_\+t \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a0f1e4ab31fd4f3ca4329091911f1f1af}{len}})
\item 
struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$ \mbox{\hyperlink{source_2string_8c_a5a90f290d7ad36c6fed178473cb9bbdf}{aws\+\_\+string\+\_\+new\+\_\+from\+\_\+string}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str)
\item 
struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$ \mbox{\hyperlink{source_2string_8c_ae04df8ebd930a3275c3828c63b3887d9}{aws\+\_\+string\+\_\+new\+\_\+from\+\_\+cursor}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cursor)
\item 
struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$ \mbox{\hyperlink{source_2string_8c_aa2a95aa7d29abbf3abd7c0500783c4d8}{aws\+\_\+string\+\_\+new\+\_\+from\+\_\+buf}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}})
\item 
void \mbox{\hyperlink{source_2string_8c_ac1fc72f37526d0c191ee75b1dd68191d}{aws\+\_\+string\+\_\+destroy}} (struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str)
\item 
void \mbox{\hyperlink{source_2string_8c_a4461d6b505e246d8ac5d95af7563b215}{aws\+\_\+string\+\_\+destroy\+\_\+secure}} (struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str)
\item 
int \mbox{\hyperlink{source_2string_8c_abc7253736dbd3d90a0c06dc382563aab}{aws\+\_\+string\+\_\+compare}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$a, const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
int \mbox{\hyperlink{source_2string_8c_ab73eb5874e9f264eb0e3003d9bdac2e0}{aws\+\_\+array\+\_\+list\+\_\+comparator\+\_\+string}} (const void $\ast$a, const void $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
bool \mbox{\hyperlink{source_2string_8c_acc5a6735850ebf003dfcaa42ce1fd708}{aws\+\_\+string\+\_\+eq}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$a, const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
bool \mbox{\hyperlink{source_2string_8c_a48d5f19cf430fc0cc37acb5c052639c9}{aws\+\_\+string\+\_\+eq\+\_\+ignore\+\_\+case}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$a, const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1a175e87536301df98c805ac0636ad7c}{b}})
\item 
bool \mbox{\hyperlink{source_2string_8c_aadf12a433cb0fff3156a3861bde462e4}{aws\+\_\+string\+\_\+eq\+\_\+byte\+\_\+cursor}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cur)
\item 
bool \mbox{\hyperlink{source_2string_8c_ab46a52ce5bb1165cae8c730af6a4f6bf}{aws\+\_\+string\+\_\+eq\+\_\+byte\+\_\+cursor\+\_\+ignore\+\_\+case}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str, const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$cur)
\item 
bool \mbox{\hyperlink{source_2string_8c_a47f620f60a5f7aa8c1da1f9019a8a98c}{aws\+\_\+string\+\_\+eq\+\_\+byte\+\_\+buf}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str, const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}})
\item 
bool \mbox{\hyperlink{source_2string_8c_a093bb119037b8a552ac56d7442912ef6}{aws\+\_\+string\+\_\+eq\+\_\+byte\+\_\+buf\+\_\+ignore\+\_\+case}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str, const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}})
\item 
bool \mbox{\hyperlink{source_2string_8c_aa9177d5420e6f2ecbc0cf9e738f249d2}{aws\+\_\+string\+\_\+eq\+\_\+c\+\_\+str}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str, const char $\ast$c\+\_\+str)
\item 
bool \mbox{\hyperlink{source_2string_8c_a41b584f8c5538801d8c0745d99d34409}{aws\+\_\+string\+\_\+eq\+\_\+c\+\_\+str\+\_\+ignore\+\_\+case}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str, const char $\ast$c\+\_\+str)
\item 
bool \mbox{\hyperlink{source_2string_8c_a9446ead30d21df51324f4245cf925d7d}{aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+from\+\_\+whole\+\_\+string}} (struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} \mbox{\hyperlink{aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h_a1fe855c208bc17a51a4d34fefdb2d5b1}{buf}}, const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}} src)
\item 
struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} \mbox{\hyperlink{source_2string_8c_ab71ef8128d27208fa6fda5079574789a}{aws\+\_\+byte\+\_\+cursor\+\_\+from\+\_\+string}} (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$src)
\item 
struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$ \mbox{\hyperlink{source_2string_8c_abd09baea12a33e30658a3d42576da944}{aws\+\_\+string\+\_\+clone\+\_\+or\+\_\+reuse}} (struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$allocator, const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$str)
\item 
int \mbox{\hyperlink{source_2string_8c_a69b4d9a94578c0c3259cf632237b30fe}{aws\+\_\+secure\+\_\+strlen}} (const char $\ast$str, size\+\_\+t max\+\_\+read\+\_\+len, size\+\_\+t $\ast$str\+\_\+len)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{source_2string_8c_ab73eb5874e9f264eb0e3003d9bdac2e0}\label{source_2string_8c_ab73eb5874e9f264eb0e3003d9bdac2e0}} 
\index{string.c@{string.c}!aws\_array\_list\_comparator\_string@{aws\_array\_list\_comparator\_string}}
\index{aws\_array\_list\_comparator\_string@{aws\_array\_list\_comparator\_string}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_array\_list\_comparator\_string()}{aws\_array\_list\_comparator\_string()}}
{\footnotesize\ttfamily int aws\+\_\+array\+\_\+list\+\_\+comparator\+\_\+string (\begin{DoxyParamCaption}\item[{const void $\ast$}]{a,  }\item[{const void $\ast$}]{b }\end{DoxyParamCaption})}

A convenience function for sorting lists of (const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$) elements. This can be used as a comparator for aws\+\_\+array\+\_\+list\+\_\+sort. It is just a simple wrapper around aws\+\_\+string\+\_\+compare. \mbox{\Hypertarget{source_2string_8c_a9446ead30d21df51324f4245cf925d7d}\label{source_2string_8c_a9446ead30d21df51324f4245cf925d7d}} 
\index{string.c@{string.c}!aws\_byte\_buf\_write\_from\_whole\_string@{aws\_byte\_buf\_write\_from\_whole\_string}}
\index{aws\_byte\_buf\_write\_from\_whole\_string@{aws\_byte\_buf\_write\_from\_whole\_string}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_buf\_write\_from\_whole\_string()}{aws\_byte\_buf\_write\_from\_whole\_string()}}
{\footnotesize\ttfamily bool aws\+\_\+byte\+\_\+buf\+\_\+write\+\_\+from\+\_\+whole\+\_\+string (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{buf,  }\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$\mbox{\hyperlink{macros_8h_a9bb2dfa7c751efe1673e3f9c89eff17c}{AWS\+\_\+\+RESTRICT}}}]{src }\end{DoxyParamCaption})}

Copies all bytes from string to buf.

On success, returns true and updates the buf pointer/length accordingly. If there is insufficient space in the buf, returns false, leaving the buf unchanged. \mbox{\Hypertarget{source_2string_8c_ab71ef8128d27208fa6fda5079574789a}\label{source_2string_8c_ab71ef8128d27208fa6fda5079574789a}} 
\index{string.c@{string.c}!aws\_byte\_cursor\_from\_string@{aws\_byte\_cursor\_from\_string}}
\index{aws\_byte\_cursor\_from\_string@{aws\_byte\_cursor\_from\_string}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_byte\_cursor\_from\_string()}{aws\_byte\_cursor\_from\_string()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} aws\+\_\+byte\+\_\+cursor\+\_\+from\+\_\+string (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{src }\end{DoxyParamCaption})}

Creates an \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} from an existing string. \mbox{\Hypertarget{source_2string_8c_a69b4d9a94578c0c3259cf632237b30fe}\label{source_2string_8c_a69b4d9a94578c0c3259cf632237b30fe}} 
\index{string.c@{string.c}!aws\_secure\_strlen@{aws\_secure\_strlen}}
\index{aws\_secure\_strlen@{aws\_secure\_strlen}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_secure\_strlen()}{aws\_secure\_strlen()}}
{\footnotesize\ttfamily int aws\+\_\+secure\+\_\+strlen (\begin{DoxyParamCaption}\item[{const char $\ast$}]{str,  }\item[{size\+\_\+t}]{max\+\_\+read\+\_\+len,  }\item[{size\+\_\+t $\ast$}]{str\+\_\+len }\end{DoxyParamCaption})}

\mbox{\Hypertarget{source_2string_8c_abd09baea12a33e30658a3d42576da944}\label{source_2string_8c_abd09baea12a33e30658a3d42576da944}} 
\index{string.c@{string.c}!aws\_string\_clone\_or\_reuse@{aws\_string\_clone\_or\_reuse}}
\index{aws\_string\_clone\_or\_reuse@{aws\_string\_clone\_or\_reuse}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_clone\_or\_reuse()}{aws\_string\_clone\_or\_reuse()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}}$\ast$ aws\+\_\+string\+\_\+clone\+\_\+or\+\_\+reuse (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str }\end{DoxyParamCaption})}

If the string was dynamically allocated, clones it. If the string was statically allocated (i.\+e. has no allocator), returns the original string. \mbox{\Hypertarget{source_2string_8c_abc7253736dbd3d90a0c06dc382563aab}\label{source_2string_8c_abc7253736dbd3d90a0c06dc382563aab}} 
\index{string.c@{string.c}!aws\_string\_compare@{aws\_string\_compare}}
\index{aws\_string\_compare@{aws\_string\_compare}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_compare()}{aws\_string\_compare()}}
{\footnotesize\ttfamily int aws\+\_\+string\+\_\+compare (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{b }\end{DoxyParamCaption})}

Compares lexicographical ordering of two strings. This is a binary byte-\/by-\/byte comparison, treating bytes as unsigned integers. It is suitable for either textual or binary data and is unaware of unicode or any other byte encoding. If both strings are identical in the bytes of the shorter string, then the longer string is lexicographically after the shorter.

Returns a positive number if string a \texorpdfstring{$>$}{>} string b. (i.\+e., string a is lexicographically after string b.) Returns zero if string a = string b. Returns negative number if string a \texorpdfstring{$<$}{<} string b. \mbox{\Hypertarget{source_2string_8c_ac1fc72f37526d0c191ee75b1dd68191d}\label{source_2string_8c_ac1fc72f37526d0c191ee75b1dd68191d}} 
\index{string.c@{string.c}!aws\_string\_destroy@{aws\_string\_destroy}}
\index{aws\_string\_destroy@{aws\_string\_destroy}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_destroy()}{aws\_string\_destroy()}}
{\footnotesize\ttfamily void aws\+\_\+string\+\_\+destroy (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str }\end{DoxyParamCaption})}

Deallocate string. \mbox{\Hypertarget{source_2string_8c_a4461d6b505e246d8ac5d95af7563b215}\label{source_2string_8c_a4461d6b505e246d8ac5d95af7563b215}} 
\index{string.c@{string.c}!aws\_string\_destroy\_secure@{aws\_string\_destroy\_secure}}
\index{aws\_string\_destroy\_secure@{aws\_string\_destroy\_secure}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_destroy\_secure()}{aws\_string\_destroy\_secure()}}
{\footnotesize\ttfamily void aws\+\_\+string\+\_\+destroy\+\_\+secure (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str }\end{DoxyParamCaption})}

Zeroes out the data bytes of string and then deallocates the memory. Not safe to run on a string created with AWS\+\_\+\+STATIC\+\_\+\+STRING\+\_\+\+FROM\+\_\+\+LITERAL. \mbox{\Hypertarget{source_2string_8c_acc5a6735850ebf003dfcaa42ce1fd708}\label{source_2string_8c_acc5a6735850ebf003dfcaa42ce1fd708}} 
\index{string.c@{string.c}!aws\_string\_eq@{aws\_string\_eq}}
\index{aws\_string\_eq@{aws\_string\_eq}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_eq()}{aws\_string\_eq()}}
{\footnotesize\ttfamily bool aws\+\_\+string\+\_\+eq (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{b }\end{DoxyParamCaption})}

Returns true if bytes of string are the same, false otherwise. \mbox{\Hypertarget{source_2string_8c_a47f620f60a5f7aa8c1da1f9019a8a98c}\label{source_2string_8c_a47f620f60a5f7aa8c1da1f9019a8a98c}} 
\index{string.c@{string.c}!aws\_string\_eq\_byte\_buf@{aws\_string\_eq\_byte\_buf}}
\index{aws\_string\_eq\_byte\_buf@{aws\_string\_eq\_byte\_buf}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_eq\_byte\_buf()}{aws\_string\_eq\_byte\_buf()}}
{\footnotesize\ttfamily bool aws\+\_\+string\+\_\+eq\+\_\+byte\+\_\+buf (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str,  }\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf }\end{DoxyParamCaption})}

Returns true if bytes of string and buffer are the same, false otherwise. \mbox{\Hypertarget{source_2string_8c_a093bb119037b8a552ac56d7442912ef6}\label{source_2string_8c_a093bb119037b8a552ac56d7442912ef6}} 
\index{string.c@{string.c}!aws\_string\_eq\_byte\_buf\_ignore\_case@{aws\_string\_eq\_byte\_buf\_ignore\_case}}
\index{aws\_string\_eq\_byte\_buf\_ignore\_case@{aws\_string\_eq\_byte\_buf\_ignore\_case}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_eq\_byte\_buf\_ignore\_case()}{aws\_string\_eq\_byte\_buf\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+string\+\_\+eq\+\_\+byte\+\_\+buf\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str,  }\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf }\end{DoxyParamCaption})}

Returns true if bytes of string and buffer are equivalent, using a case-\/insensitive comparison. \mbox{\Hypertarget{source_2string_8c_aadf12a433cb0fff3156a3861bde462e4}\label{source_2string_8c_aadf12a433cb0fff3156a3861bde462e4}} 
\index{string.c@{string.c}!aws\_string\_eq\_byte\_cursor@{aws\_string\_eq\_byte\_cursor}}
\index{aws\_string\_eq\_byte\_cursor@{aws\_string\_eq\_byte\_cursor}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_eq\_byte\_cursor()}{aws\_string\_eq\_byte\_cursor()}}
{\footnotesize\ttfamily bool aws\+\_\+string\+\_\+eq\+\_\+byte\+\_\+cursor (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cur }\end{DoxyParamCaption})}

Returns true if bytes of string and cursor are the same, false otherwise. \mbox{\Hypertarget{source_2string_8c_ab46a52ce5bb1165cae8c730af6a4f6bf}\label{source_2string_8c_ab46a52ce5bb1165cae8c730af6a4f6bf}} 
\index{string.c@{string.c}!aws\_string\_eq\_byte\_cursor\_ignore\_case@{aws\_string\_eq\_byte\_cursor\_ignore\_case}}
\index{aws\_string\_eq\_byte\_cursor\_ignore\_case@{aws\_string\_eq\_byte\_cursor\_ignore\_case}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_eq\_byte\_cursor\_ignore\_case()}{aws\_string\_eq\_byte\_cursor\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+string\+\_\+eq\+\_\+byte\+\_\+cursor\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cur }\end{DoxyParamCaption})}

Returns true if bytes of string and cursor are equivalent, using a case-\/insensitive comparison. \mbox{\Hypertarget{source_2string_8c_aa9177d5420e6f2ecbc0cf9e738f249d2}\label{source_2string_8c_aa9177d5420e6f2ecbc0cf9e738f249d2}} 
\index{string.c@{string.c}!aws\_string\_eq\_c\_str@{aws\_string\_eq\_c\_str}}
\index{aws\_string\_eq\_c\_str@{aws\_string\_eq\_c\_str}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_eq\_c\_str()}{aws\_string\_eq\_c\_str()}}
{\footnotesize\ttfamily bool aws\+\_\+string\+\_\+eq\+\_\+c\+\_\+str (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str,  }\item[{const char $\ast$}]{c\+\_\+str }\end{DoxyParamCaption})}

\mbox{\Hypertarget{source_2string_8c_a41b584f8c5538801d8c0745d99d34409}\label{source_2string_8c_a41b584f8c5538801d8c0745d99d34409}} 
\index{string.c@{string.c}!aws\_string\_eq\_c\_str\_ignore\_case@{aws\_string\_eq\_c\_str\_ignore\_case}}
\index{aws\_string\_eq\_c\_str\_ignore\_case@{aws\_string\_eq\_c\_str\_ignore\_case}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_eq\_c\_str\_ignore\_case()}{aws\_string\_eq\_c\_str\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+string\+\_\+eq\+\_\+c\+\_\+str\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str,  }\item[{const char $\ast$}]{c\+\_\+str }\end{DoxyParamCaption})}

Returns true if bytes of strings are equivalent, using a case-\/insensitive comparison. \mbox{\Hypertarget{source_2string_8c_a48d5f19cf430fc0cc37acb5c052639c9}\label{source_2string_8c_a48d5f19cf430fc0cc37acb5c052639c9}} 
\index{string.c@{string.c}!aws\_string\_eq\_ignore\_case@{aws\_string\_eq\_ignore\_case}}
\index{aws\_string\_eq\_ignore\_case@{aws\_string\_eq\_ignore\_case}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_eq\_ignore\_case()}{aws\_string\_eq\_ignore\_case()}}
{\footnotesize\ttfamily bool aws\+\_\+string\+\_\+eq\+\_\+ignore\+\_\+case (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{a,  }\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{b }\end{DoxyParamCaption})}

Returns true if bytes of string are equivalent, using a case-\/insensitive comparison. \mbox{\Hypertarget{source_2string_8c_ada083f5511da699ce2085d1caa517510}\label{source_2string_8c_ada083f5511da699ce2085d1caa517510}} 
\index{string.c@{string.c}!aws\_string\_new\_from\_array@{aws\_string\_new\_from\_array}}
\index{aws\_string\_new\_from\_array@{aws\_string\_new\_from\_array}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_new\_from\_array()}{aws\_string\_new\_from\_array()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}}$\ast$ aws\+\_\+string\+\_\+new\+\_\+from\+\_\+array (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$}]{bytes,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}

Allocate a new string with the same contents as array. \mbox{\Hypertarget{source_2string_8c_aa2a95aa7d29abbf3abd7c0500783c4d8}\label{source_2string_8c_aa2a95aa7d29abbf3abd7c0500783c4d8}} 
\index{string.c@{string.c}!aws\_string\_new\_from\_buf@{aws\_string\_new\_from\_buf}}
\index{aws\_string\_new\_from\_buf@{aws\_string\_new\_from\_buf}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_new\_from\_buf()}{aws\_string\_new\_from\_buf()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}}$\ast$ aws\+\_\+string\+\_\+new\+\_\+from\+\_\+buf (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{const struct \mbox{\hyperlink{structaws__byte__buf}{aws\+\_\+byte\+\_\+buf}} $\ast$}]{buf }\end{DoxyParamCaption})}

Allocate a new string with the same contents as buf. \mbox{\Hypertarget{source_2string_8c_af0855e6106f8073c9865924475792281}\label{source_2string_8c_af0855e6106f8073c9865924475792281}} 
\index{string.c@{string.c}!aws\_string\_new\_from\_c\_str@{aws\_string\_new\_from\_c\_str}}
\index{aws\_string\_new\_from\_c\_str@{aws\_string\_new\_from\_c\_str}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_new\_from\_c\_str()}{aws\_string\_new\_from\_c\_str()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}}$\ast$ aws\+\_\+string\+\_\+new\+\_\+from\+\_\+c\+\_\+str (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{const char $\ast$}]{c\+\_\+str }\end{DoxyParamCaption})}

Copyright Amazon.\+com, Inc. or its affiliates. All Rights Reserved. SPDX-\/\+License-\/\+Identifier\+: Apache-\/2.\+0. \mbox{\Hypertarget{source_2string_8c_ae04df8ebd930a3275c3828c63b3887d9}\label{source_2string_8c_ae04df8ebd930a3275c3828c63b3887d9}} 
\index{string.c@{string.c}!aws\_string\_new\_from\_cursor@{aws\_string\_new\_from\_cursor}}
\index{aws\_string\_new\_from\_cursor@{aws\_string\_new\_from\_cursor}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_new\_from\_cursor()}{aws\_string\_new\_from\_cursor()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}}$\ast$ aws\+\_\+string\+\_\+new\+\_\+from\+\_\+cursor (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{const struct \mbox{\hyperlink{structaws__byte__cursor}{aws\+\_\+byte\+\_\+cursor}} $\ast$}]{cursor }\end{DoxyParamCaption})}

Allocate a new string with the same contents as cursor. \mbox{\Hypertarget{source_2string_8c_a5a90f290d7ad36c6fed178473cb9bbdf}\label{source_2string_8c_a5a90f290d7ad36c6fed178473cb9bbdf}} 
\index{string.c@{string.c}!aws\_string\_new\_from\_string@{aws\_string\_new\_from\_string}}
\index{aws\_string\_new\_from\_string@{aws\_string\_new\_from\_string}!string.c@{string.c}}
\doxysubsubsection{\texorpdfstring{aws\_string\_new\_from\_string()}{aws\_string\_new\_from\_string()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}}$\ast$ aws\+\_\+string\+\_\+new\+\_\+from\+\_\+string (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structaws__allocator}{aws\+\_\+allocator}} $\ast$}]{allocator,  }\item[{const struct \mbox{\hyperlink{structaws__string}{aws\+\_\+string}} $\ast$}]{str }\end{DoxyParamCaption})}

Allocate a new string with the same contents as another string. 