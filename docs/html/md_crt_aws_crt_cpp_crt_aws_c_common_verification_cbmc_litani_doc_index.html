<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AWS IoT Device SDK C++ v2: index</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AWS IoT Device SDK C++ v2<span id="projectnumber">&#160;1.14.0</span>
   </div>
   <div id="projectbrief">AWS IoT Device SDK C++ v2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">index </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >&lt;header id="title"&gt; </p><h1>AWS Build Accumulator</h1>
<p  id="subtitle"></p>
<p >Litani Command-line reference</p>
<p >&lt;/header&gt;</p>
<p >AWS Build Accumulator is a suite of tools that collect build jobs from multiple sources before executing them concurrently. Users access AWS Build Accumulator through <code>litani</code>, the command-line interface. This document serves as a reference for using <code>litani</code> and integrating it into your project.</p>
<p ><code>litani</code> allows you to use multiple build systems in the same project, providing a backend that each build system emits jobs to. Once all jobs have been enqueued, <code>litani</code> executes them all as a single unified build graph. <code>litani</code> also provides platform-independent job control (timeouts and control of return codes), as well as grouping of job artifacts into stages.</p>
<p ><a href="https://github.com/awslabs/aws-build-accumulator">Source code repository</a></p>
<h2><a class="anchor" id="autotoc_md91"></a>
Overview</h2>
<p >Consider the following Makefile: </p><pre class="fragment">foo.out: foo.in
    timeout 90 my_command $^ &gt; $@; if [ $? -eq 10 ]; then exit 0; fi
</pre><p> <code>foo.out</code> is built from <code>foo.in</code> using <code>my_command</code>. We want to kill <code>my_command</code> if it runs for more than 90 seconds, and we're also expecting that <code>my_command</code> may exit with a return code of 10; we don't consider that to be an error, so we exit the subshell with 0 in that case.</p>
<p >The timeout and error escaping in this command are unportable. We can replace it with an invocation to <code>litani</code> as follows: </p><pre class="fragment">foo.out: foo.in
    litani add-job                \
      --command "my_command $^"   \
      --inputs $^                 \
      --outputs $@                \
      --timeout 90                \
      --ok-returns 10             \
      --pipeline-name my_command  \
      --ci-stage build            \
      --stdout-file $@
</pre><p> To actually run this, write the following shell script: </p><pre class="fragment">#!/bin/sh

litani init --project my_project
make foo.out
litani run-build
</pre><p> Running <code>make</code> doesn't actually run the job; rather, it runs <code>litani</code>, which saves the job for later. You can run <code>litani add-job</code> as many times as you like after running <code>litani init</code>; all these jobs are cached and turned into a dependency graph using the arguments to <code>--inputs</code> and <code>--outputs</code>. Running <code>litani run-build</code> runs all cached build jobs together, in parallel if possible.</p>
<p ><code>litani</code> continuously updates a <code>run.json</code> file while the <code>run-build</code> command is running, showing progress of each job as well as recording the return codes, timeout information, and stdout/stderr of each job. This file is documented below and is designed to be easy to render into a dashboard, for example in HTML.</p>
<h2><a class="anchor" id="autotoc_md92"></a>
Motivation</h2>
<p >While the platform-independent job-control features are a nice bonus, <code>litani</code>'s real value is in serving as a backend for executing a graph of build tasks that are added from heterogeneous sources. In a complex software project, different parts of the project can use incompatible build systems. To build the entire project, one must either run all build systems in parallel&mdash;potentially overcommitting on concurrency and introducing nondeterminism when some of the targets overlap&mdash;or run each build system serially, wasting time.</p>
<p ><code>litani</code> makes it possible for jobs that are specified in different build systems to depend on each other. It also obviates the need to force different parts of the project to use a unified build syntax, if that is unnatural for some reason. If some parts of the build tree are specified in Make, with others specified in CMake, then <code>litani</code> allows developers working on each part of the codebase to use the build system that makes sense to them, while <code>litani</code> builds the entire tree in the background.</p>
<h2><a class="anchor" id="autotoc_md93"></a>
Subtool Reference</h2>
<p ><code>litani</code> consists of three user-facing commands:</p>
<ul>
<li><code>litani init</code>&mdash;create a new run</li>
<li><code>litani add-job</code>&mdash;add a job to the run</li>
<li><code>litani run-build</code>&mdash;run all jobs in the run in dependency order</li>
</ul>
<p >You use <code>litani</code> by invoking all three of these commands. You firstly initialize a run; add at least one job to the run; and then build the run, which invokes all the jobs in dependency order.</p>
<p >&lt;object
  type="image/svg+xml"
  data="litani-flow.svg"
  alt="Flow of using litani: first litani init, then one or more invocations of litani add-job, and finally litani run-build"
  id="litani-flow"&gt; Flow of using litani: first litani init, then one or more invocations of litani add-job, and finally litani run-build &lt;/object&gt; </p>
<p ><code>litani</code> writes all data associated with the run to a single directory; the directory for each run is unique. <code>litani</code>'s data format is versioned with <a href="https://semver.org/">semantic versioning</a>. <code>litani --version</code> prints the data format version and exits. The current version is 1.0.0.</p>
<h3><a class="anchor" id="autotoc_md94"></a>
&lt;tt&gt;litani init&lt;/tt&gt;</h3>
<p ><code>litani [-v] init [-h] --project-name NAME</code></p>
<p >Create a new run for jobs to be added to. <code>litani</code> output from subsequent commands, as well as job artifacts and output files, will be written to a directory associated with this run.</p>
<p ><code>-v, --verbose</code> </p>
<p >Verbose output. In particular, print the name of the directory to which all output files and artifacts for this run will be written to. </p>
<p ><code>--project-name NAME</code> </p>
<p >Associate this run to a "project". A project is a collection of runs. The name of the project will be included in the JSON output for the run. </p>
<h3><a class="anchor" id="autotoc_md95"></a>
&lt;tt&gt;litani add-job&lt;/tt&gt;</h3>
<pre class="fragment">litani [-v] add-job --command CMD
                    [--inputs F [F ...]]
                    [--outputs F [F ...]]
                    --pipeline-name P --ci-stage S
                    [-h] [--cwd DIR] [--timeout N] [--timeout-ok]
                    [--timeout-ignore] [--ignore-returns RC [RC ...]]
                    [--ok-returns RC [RC ...]]
                    [--interleave-stdout-stderr]
                    [--stdout-file FILE] [--stderr-file FILE]
                    [--description DESC] [--tags TAG [TAG ...]]
</pre><p> Describe one of the jobs to be run when <code>litani run-build</code> is invoked. A <em>job</em> is a command that depends on inputs emits outputs. The command is invoked when the jobs that emit each of this job's inputs have successfully executed. Inputs and outputs can be files, but they don't have to be; <code>litani</code> doesn't actually check whether the files were written, just whether the job completed successfully.</p>
<h4><a class="anchor" id="autotoc_md96"></a>
describing the build graph:</h4>
<p ><code>--command CMD</code> </p>
<p >The command to run once all dependencies are satisfied. <code>CMD</code> is parsed as a single string and invoked using a subshell. </p>
<p ><code>--inputs F [F ...]</code> </p>
<p >List of inputs that this job depends on. </p>
<p ><code>--outputs F [F ...]</code> </p>
<p >List of outputs that this job generates. </p>
<h4><a class="anchor" id="autotoc_md97"></a>
job control:</h4>
<p ><code>--pipeline-name P</code> </p>
<p >Which pipeline this job is a member of. </p>
<p ><code>--ci-stage &lt;build|test|report&gt;</code> </p>
<p >Which CI stage this job is a member of. </p>
<p ><code>--cwd DIR</code> </p>
<p >Directory that the command should execute in. </p>
<p ><code>--timeout N</code> </p>
<p >How long the job should be allowed to run for. If the timeout is reached, the command will be terminated and the job will exit unsuccessfully, blocking any dependant jobs from running, unless <code>--timeout-ok</code> or <code>--timeout-ignore</code> are passed. </p>
<p ><code>--timeout-ok</code> </p>
<p >If the command times out, it will be terminated, but the job will be considered successful. The pipeline that this job is part of will also be considered successful. </p>
<p ><code>--timeout-ignore</code> </p>
<p >If the command times out, it will be terminated, but this will not block dependent jobs from running. Nevertheless, the pipeline that this job is part of will be considered to have failed. This option is useful when you wish to run dependant jobs even after this job has timed out, but still want to indicate an overall failure. </p>
<p ><code>--ignore-returns RC [RC ...]</code> </p>
<p >If the exits with one of the specified return codes, it will not block dependent jobs from running. Nevertheless, the pipeline that this job is part of will be considered to have failed. This option is useful when you wish to run dependant jobs even after the command exited with an abnormal status, but still want to indicate an overall failure. For example, you may wish to generate a report as a dependant job; the report must still be generated if this job fails. </p>
<p ><code>--ok-returns RC [RC ...]</code> </p>
<p >If the command exits with one of the specified return codes, the job will still be considered successful. </p>
<p ><code>--interleave-stdout-stderr</code> </p>
<p >Simulate <code>2&gt;&amp;1 &gt;...</code> </p>
<p ><code>--stdout-file FILE</code> </p>
<p >Write the command's stdout to <code>FILE</code>. Note that even if this option is not passed, <code>litani</code> will not print the command's stdout to the terminal, but will save any output to the JSON file for the run. </p>
<p ><code>--stderr-file FILE</code> </p>
<p >Write the command's stderr to <code>FILE</code>. Note that even if this option is not passed, <code>litani</code> will not print the command's stderr to the terminal, but will save any output to the JSON file for the run. </p>
<h4><a class="anchor" id="autotoc_md98"></a>
misc:</h4>
<p ><code>--description DESC</code> </p>
<p >A human-readable string to describe the job. This will be printed to terminal when the job is run, and can also be used in reports. <code>litani</code> does not interpret the description, but will include it in the JSON report for the run. </p>
<p ><code>--tags TAG [TAG ...]</code> </p>
<p >A list of tags for this job. <code>litani</code> does not interpret tags, but will include them all in the JSON report for the run. </p>
<h3><a class="anchor" id="autotoc_md99"></a>
&lt;tt&gt;litani run-build&lt;/tt&gt;</h3>
<pre class="fragment">litani run-build [-h] [-n] [-j N] [-o F]
                 [--pipelines P [P ...] |
                  --ci-stage &lt;build|test|report&gt;]
</pre><p> Create a new run for jobs to be added to. <code>litani</code> output from subsequent commands, as well as job artifacts and output files, will be written to a directory associated with this run.</p>
<p ><code>-j N, --parallel N</code> </p>
<p >Run at most <code>N</code> jobs in parallel. 0 means infinity, the default is based on the number of cores on your system. </p>
<p ><code>-n, --dry-run</code> </p>
<p >Don't actually run the commands in each job, just pretend that they succeeded. </p>
<p ><code>-o F, --out-file F</code> </p>
<p >Periodically write a JSON file describing the run so far to <code>F</code>. <code>litani</code> already writes such a file to the run directory created by <code>litani init</code>; this flag specifies an additional, more easily-accessible file to write to. </p>
<p ><code>-p P [P ...], --pipelines P [P ...]</code> </p>
<p >Only run the jobs that are associated with the pipeline <code>P</code>. This allows you to run a subset of the jobs from start to finish. </p>
<p ><code>-s &lt;build|test|report&gt;, --ci-stage &lt;build|test|report&gt;</code> </p>
<p >Only run the jobs that are part of the CI stage <code>S</code>. This allows you to run all jobs up to and including a particular stage. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
