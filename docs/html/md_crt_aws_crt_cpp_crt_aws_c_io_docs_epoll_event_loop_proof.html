<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AWS IoT Device SDK C++ v2: VCC Proof Signoff</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AWS IoT Device SDK C++ v2<span id="projectnumber">&#160;1.14.0</span>
   </div>
   <div id="projectbrief">AWS IoT Device SDK C++ v2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">VCC Proof Signoff </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Verification tool: VCC (code-level proof)</p>
<p >Proofs: <code>tests/vcc/</code></p>
<p >Implementation: Linux event loop (<code><a class="el" href="epoll__event__loop_8c.html">source/linux/epoll_event_loop.c</a></code>)</p>
<p >Specification / Properties (<code>preamble.h</code>):</p><ul>
<li><em>Memory safety</em>: the implementation only accesses valid memory.</li>
<li><em>Thread safety</em>: threads only update objects that they own.</li>
<li><em>Functional correctness</em>: sequential task and event callback execution in the presence of multiple client threads. The proofs verify that:<ul>
<li>The scheduler for task execution is thread-local to the event loop thread (so is sequential since no other threads read or write directly to the scheduler). Tasks move from client threads to the event loop via properly-synchronized ownership transfers, using locking.</li>
<li>Subscribe/notify for event execution is properly-synchronized via epoll.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md145"></a>
Assumptions</h1>
<p >Generally, we assume well-behaved clients; the correctness of underlying primitives (memory allocation, AWS C Common library, syscalls); and, minor assumptions due to limitations in VCC. More precisely, the proofs assume:</p>
<ul>
<li>Well-behaved client: all client threads use the event loop API in a manner that adheres to the specification. A badly-behaved client can invalidate the proven properties. For example, a client that reads, writes, or frees a task struct object that is scheduled on the event loop is racy and no longer thread safe. The specification given in <code>preamble.h</code> forbids this behavior (the ownership of the task struct changes as a result of the schedule function) but we cannot, in general, enforce this behavior since we do not verify client code.</li>
<li>Thread safety of the allocator functions <code>aws_mem_{calloc,release}</code>. This is important in the case where a client uses a custom allocator.</li>
<li>Memory safety and function contracts for the following AWS C Common functions: <pre class="fragment">aws_atomic_compare_exchange_ptr
aws_atomic_{init, load, store}_{int, ptr}
aws_linked_list_{init, pop_front, swap_contents}
aws_mutex_{lock, unlock}
aws_raise_error
aws_task_init
aws_task_scheduler_schedule_{now, future}
aws_task_scheduler_{init, run_all, clean_up, cancel_tasks, has_tasks}
aws_thread_{init, current_thread_id, launch, join, clean_up, thread_id_equal}
</pre> and similarly for the AWS C-IO functions: <pre class="fragment">aws_event_loop_{init_base, clean_up_base}
aws_open_nonblocking_posix_pipe
</pre> and similarly for the system calls: <pre class="fragment">close
epoll_{ctl, wait, create}
eventfd
read, write
</pre> The contracts are given in the <code>preamble.h</code> and proof files. The contracts are assumed, not proven. The memory safety of the AWS C Common linked list functions have been proven in CBMC.</li>
<li>Thread safety of the epoll syscalls <code>epoll_{ctl, wait}</code>. We additionally assume that the <code>ctl</code> (subscribe) and <code>wait</code> syscalls induce "happens
    before" so that the litmus test (See Appendix) is data-race free and therefore properly-synchronizes event subscribe/notify.</li>
<li>Minor assumptions due to limitations of the VCC tool.<ul>
<li>In <code>s_is_on_callers_thread</code> we assume the loaded value from the atomic var <code>running_thread_id</code> is thread-local and either <code>NULL</code> or the address of the owner of the event loop. We cannot make this an object invariant because the access is atomic. We manually validate that this assumption is reasonable.</li>
<li>In <code>s_run</code> we do not model the ownership transfer of the event loop from the client thread to the freshly-launched event loop thread. We manually validate that this assumption is reasonable.</li>
</ul>
</li>
<li>The Sequentially Consistent Data Race Free (SC-DRF) guarantee required by the C11 standard: if a program is race-free and contains no non-SC atomic operations, then it has only SC semantics [Note 12, N1570]. We rely on SC-DRF to justify the use of VCC's SC memory model. We manually validate that the event loop implementation contains no non-SC atomic operations. Validation is required for pre-C11 compilers.</li>
</ul>
<h1><a class="anchor" id="autotoc_md146"></a>
Simplifications</h1>
<ul>
<li>Omit modeling of hash-table <code>local_data</code> in event loop.</li>
<li>The log functions <code>AWS_LOGF_{...}</code> are no-ops (hash-defined out).</li>
<li>Allocator functions are hash-defined to malloc/free.</li>
<li>In <code>s_destroy</code>, we (re-)take the <code><a class="el" href="structepoll__loop.html">epoll_loop</a></code> pointer after stop and wait have been called. This has no semantic change to the program but is necessary for the proof.</li>
<li>Workarounds for VCC frontend (no semantic diff, but changes to syntax) <pre class="fragment">// Function pointer declarations
// For example, the following
typedef int(aws_io_clock_fn)(uint64_t *timestamp);
// is replaced with
typedef int(* aws_io_clock_fn_ptr)(uint64_t *timestamp);

// Array and struct literal initializers
// For example, the following
int pipe_fds[2] = {0};
// is replaced with
int pipe_fds[2]; pipe_fds[0] = 0; pipe_fds[1] = 0;
</pre> </li>
</ul>
<h1><a class="anchor" id="autotoc_md147"></a>
Trusted computing base</h1>
<ul>
<li>Soundness of verification tools: VCC, Boogie, Z3</li>
<li>C Compiler, because the verification is at the C code-level and the properties proved may not be preserved by compilation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md148"></a>
References</h1>
<p >[N1570] ISO/IEC. Programming languages â€“ C. International standard 9899:201x, 2011</p>
<h1><a class="anchor" id="autotoc_md149"></a>
Appendix</h1>
<p >Assumption on "happens before" induced by <code>epoll_{ctl/wait}</code>. Informally, we need "message-passing" to hold so that the shared data passed from T1-to-T2 is guaranteed not-to-race. </p><pre class="fragment">    // Initially *data == 0 (non-atomic location)
    // T1
    *data = 1;
    epoll_ctl(...); // register event

    // T2
    if (1 == epoll_wait(...)) { // receive event
        r0 = *data; // guaranteed that r0==1
    }
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
