<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AWS IoT Device SDK C++ v2: crt/aws-crt-cpp/crt/aws-c-common/source/byte_buf.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AWS IoT Device SDK C++ v2<span id="projectnumber">&#160;1.14.0</span>
   </div>
   <div id="projectbrief">AWS IoT Device SDK C++ v2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_affb495f978f3575eca2eeb81eb7736b.html">crt</a></li><li class="navelem"><a class="el" href="dir_eb065311872385a3a1227a6ede2c108c.html">aws-crt-cpp</a></li><li class="navelem"><a class="el" href="dir_c68d83f7493c97e50c45ec06f21e3081.html">crt</a></li><li class="navelem"><a class="el" href="dir_fab3a90bc3065fb2d7dcf327c1e16d97.html">aws-c-common</a></li><li class="navelem"><a class="el" href="dir_942ba0e0f995b77b354a106627731e0f.html">source</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">byte_buf.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="byte__buf_8h_source.html">aws/common/byte_buf.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="private_2byte__buf_8h_source.html">aws/common/private/byte_buf.h</a>&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adf8ed14982cd1aa9e83c924ebb5856ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#adf8ed14982cd1aa9e83c924ebb5856ae">aws_byte_buf_init</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, struct <a class="el" href="structaws__allocator.html">aws_allocator</a> *<a class="el" href="socket__test_8c.html#a130cc941753892421e3f70bdee1049d1">allocator</a>, size_t capacity)</td></tr>
<tr class="separator:adf8ed14982cd1aa9e83c924ebb5856ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaa669dd210b0cf9820deca75c9a686"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#afcaa669dd210b0cf9820deca75c9a686">aws_byte_buf_init_copy</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *dest, struct <a class="el" href="structaws__allocator.html">aws_allocator</a> *<a class="el" href="socket__test_8c.html#a130cc941753892421e3f70bdee1049d1">allocator</a>, const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *src)</td></tr>
<tr class="separator:afcaa669dd210b0cf9820deca75c9a686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07926449452596f7b4750430607a9277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a07926449452596f7b4750430607a9277">aws_byte_buf_is_valid</a> (const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="separator:a07926449452596f7b4750430607a9277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a58a8d6758717dcdbf2ed031d44d68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a6a58a8d6758717dcdbf2ed031d44d68c">aws_byte_cursor_is_valid</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *cursor)</td></tr>
<tr class="separator:a6a58a8d6758717dcdbf2ed031d44d68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba38e9db5164e21174386de288aa1c7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#aba38e9db5164e21174386de288aa1c7d">aws_byte_buf_reset</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, <a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> zero_contents)</td></tr>
<tr class="separator:aba38e9db5164e21174386de288aa1c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbddfbd5ccda972a6630cd841fec7b21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#acbddfbd5ccda972a6630cd841fec7b21">aws_byte_buf_clean_up</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="separator:acbddfbd5ccda972a6630cd841fec7b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0a2e070ce4e156bc636c9873eb4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ac1d0a2e070ce4e156bc636c9873eb4ad">aws_byte_buf_secure_zero</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="separator:ac1d0a2e070ce4e156bc636c9873eb4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4e4659a9a46d1014b10424a87b8286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a9f4e4659a9a46d1014b10424a87b8286">aws_byte_buf_clean_up_secure</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="separator:a9f4e4659a9a46d1014b10424a87b8286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2246da0ca31f44fc92d4ebc9fa16cb45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a2246da0ca31f44fc92d4ebc9fa16cb45">aws_byte_buf_eq</a> (const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const a, const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>)</td></tr>
<tr class="separator:a2246da0ca31f44fc92d4ebc9fa16cb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23180f5c686096e7f2902e147635aeb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a23180f5c686096e7f2902e147635aeb1">aws_byte_buf_eq_ignore_case</a> (const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const a, const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>)</td></tr>
<tr class="separator:a23180f5c686096e7f2902e147635aeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d84517a8dd0c4ab2b3b17c108814c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ab9d84517a8dd0c4ab2b3b17c108814c4">aws_byte_buf_eq_c_str</a> (const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *const c_str)</td></tr>
<tr class="separator:ab9d84517a8dd0c4ab2b3b17c108814c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e8f1e9a122054ada8a3e867aa9a6f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#af2e8f1e9a122054ada8a3e867aa9a6f8">aws_byte_buf_eq_c_str_ignore_case</a> (const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const char *const c_str)</td></tr>
<tr class="separator:af2e8f1e9a122054ada8a3e867aa9a6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0e7102270fffc97b9d7da4d0a38bd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#add0e7102270fffc97b9d7da4d0a38bd7">aws_byte_buf_init_copy_from_cursor</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *dest, struct <a class="el" href="structaws__allocator.html">aws_allocator</a> *<a class="el" href="socket__test_8c.html#a130cc941753892421e3f70bdee1049d1">allocator</a>, struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> src)</td></tr>
<tr class="separator:add0e7102270fffc97b9d7da4d0a38bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5490e5293c67b8f0a82342ea81c917"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#aac5490e5293c67b8f0a82342ea81c917">aws_byte_buf_init_cache_and_update_cursors</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *dest, struct <a class="el" href="structaws__allocator.html">aws_allocator</a> *<a class="el" href="socket__test_8c.html#a130cc941753892421e3f70bdee1049d1">allocator</a>,...)</td></tr>
<tr class="separator:aac5490e5293c67b8f0a82342ea81c917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8500b18cf261cffbd69dec5f4dd698c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a8500b18cf261cffbd69dec5f4dd698c1">aws_byte_cursor_next_split</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> input_str, char split_on, struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> substr)</td></tr>
<tr class="separator:a8500b18cf261cffbd69dec5f4dd698c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49db4870532ddfadf616887d3fb2fed5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a49db4870532ddfadf616887d3fb2fed5">aws_byte_cursor_split_on_char_n</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> input_str, char split_on, size_t n, struct <a class="el" href="structaws__array__list.html">aws_array_list</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> <a class="el" href="log__formatter__test_8c.html#ae73289c5189c80c0661459b0f4743217">output</a>)</td></tr>
<tr class="separator:a49db4870532ddfadf616887d3fb2fed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ebbd786227e59a3aba25b8abe43d6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ac6ebbd786227e59a3aba25b8abe43d6e">aws_byte_cursor_split_on_char</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> input_str, char split_on, struct <a class="el" href="structaws__array__list.html">aws_array_list</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> <a class="el" href="log__formatter__test_8c.html#ae73289c5189c80c0661459b0f4743217">output</a>)</td></tr>
<tr class="separator:ac6ebbd786227e59a3aba25b8abe43d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8034dfb48cf116946a092436e409bf9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a8034dfb48cf116946a092436e409bf9a">aws_byte_cursor_find_exact</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> input_str, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> to_find, struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *first_find)</td></tr>
<tr class="separator:a8034dfb48cf116946a092436e409bf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed7bf940089a3adfb6e44ab70203156"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a6ed7bf940089a3adfb6e44ab70203156">aws_byte_buf_cat</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *dest, size_t number_of_args,...)</td></tr>
<tr class="separator:a6ed7bf940089a3adfb6e44ab70203156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac432a626706052a527c1349fb8cbd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a6ac432a626706052a527c1349fb8cbd4">aws_byte_cursor_eq</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *a, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>)</td></tr>
<tr class="separator:a6ac432a626706052a527c1349fb8cbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509e25ff72150c5f4f4a40e48432c402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a509e25ff72150c5f4f4a40e48432c402">aws_byte_cursor_eq_ignore_case</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *a, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>)</td></tr>
<tr class="separator:a509e25ff72150c5f4f4a40e48432c402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e2f9f9e603d6d21aceba0cccb77bb9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#af9e2f9f9e603d6d21aceba0cccb77bb9">AWS_STATIC_ASSERT</a> (<a class="el" href="macros_8h.html#a7b837cfd09e209fa32b1129f8bc9c431">AWS_ARRAY_SIZE</a>(<a class="el" href="byte__buf_8c.html#a44397e404df152393bd3201025f462ef">s_tolower_table</a>)==256)</td></tr>
<tr class="separator:af9e2f9f9e603d6d21aceba0cccb77bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fe4a204cae799ed595d635d9979590"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#af1fe4a204cae799ed595d635d9979590">aws_lookup_table_to_lower_get</a> (void)</td></tr>
<tr class="separator:af1fe4a204cae799ed595d635d9979590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7140a0d5f0196940bcf1d62f4679f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ad7140a0d5f0196940bcf1d62f4679f33">aws_array_eq_ignore_case</a> (const void *const array_a, const size_t len_a, const void *const array_b, const size_t len_b)</td></tr>
<tr class="separator:ad7140a0d5f0196940bcf1d62f4679f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60206f73448db770f5f66a54cf72b5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#aa60206f73448db770f5f66a54cf72b5a">aws_array_eq</a> (const void *const array_a, const size_t len_a, const void *const array_b, const size_t len_b)</td></tr>
<tr class="separator:aa60206f73448db770f5f66a54cf72b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab764fa5e408f601deef8f78aa969a92c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ab764fa5e408f601deef8f78aa969a92c">aws_array_eq_c_str_ignore_case</a> (const void *const array, const size_t array_len, const char *const c_str)</td></tr>
<tr class="separator:ab764fa5e408f601deef8f78aa969a92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173ae70dc07148c93669d9bf695ab9bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a173ae70dc07148c93669d9bf695ab9bd">aws_array_eq_c_str</a> (const void *const array, const size_t array_len, const char *const c_str)</td></tr>
<tr class="separator:a173ae70dc07148c93669d9bf695ab9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b52ce0371e324b33ec2006fe3207fa"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ab2b52ce0371e324b33ec2006fe3207fa">aws_hash_array_ignore_case</a> (const void *array, const size_t <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a0f1e4ab31fd4f3ca4329091911f1f1af">len</a>)</td></tr>
<tr class="separator:ab2b52ce0371e324b33ec2006fe3207fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb583d1f274a5863b152cee4749bcc9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a2bb583d1f274a5863b152cee4749bcc9">aws_hash_byte_cursor_ptr_ignore_case</a> (const void *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#ac011de571ff16ba220d2e0d757e4e8b0">item</a>)</td></tr>
<tr class="separator:a2bb583d1f274a5863b152cee4749bcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a7dc00c06d8a4abe69a9680934336a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a31a7dc00c06d8a4abe69a9680934336a">aws_byte_cursor_eq_byte_buf</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const a, const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>)</td></tr>
<tr class="separator:a31a7dc00c06d8a4abe69a9680934336a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6952e4ba3307e2a05d5edadc0d92cee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a6952e4ba3307e2a05d5edadc0d92cee0">aws_byte_cursor_eq_byte_buf_ignore_case</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const a, const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>)</td></tr>
<tr class="separator:a6952e4ba3307e2a05d5edadc0d92cee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410ca19b956f672343dfa71c2f534abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a410ca19b956f672343dfa71c2f534abe">aws_byte_cursor_eq_c_str</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const cursor, const char *const c_str)</td></tr>
<tr class="separator:a410ca19b956f672343dfa71c2f534abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd816b132e73605793c8a7b848997b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#afbd816b132e73605793c8a7b848997b1">aws_byte_cursor_eq_c_str_ignore_case</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const cursor, const char *const c_str)</td></tr>
<tr class="separator:afbd816b132e73605793c8a7b848997b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3ab456a1b70a558da8e18e2724a948"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#acd3ab456a1b70a558da8e18e2724a948">aws_byte_buf_append</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *to, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *from)</td></tr>
<tr class="separator:acd3ab456a1b70a558da8e18e2724a948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448b75fae26a0e95e178ac9629482e6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a448b75fae26a0e95e178ac9629482e6f">aws_byte_buf_append_with_lookup</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> to, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> from, const uint8_t *lookup_table)</td></tr>
<tr class="separator:a448b75fae26a0e95e178ac9629482e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec56ee1008054c5a0aee809cc324e330"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#aec56ee1008054c5a0aee809cc324e330">s_aws_byte_buf_append_dynamic</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *to, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *from, <a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> clear_released_memory)</td></tr>
<tr class="separator:aec56ee1008054c5a0aee809cc324e330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a34b2d690f402d6f1eb78da880d43d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ab4a34b2d690f402d6f1eb78da880d43d">aws_byte_buf_append_dynamic</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *to, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *from)</td></tr>
<tr class="separator:ab4a34b2d690f402d6f1eb78da880d43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208d9f01f769fbc2440aa7d98019e639"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a208d9f01f769fbc2440aa7d98019e639">aws_byte_buf_append_dynamic_secure</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *to, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *from)</td></tr>
<tr class="separator:a208d9f01f769fbc2440aa7d98019e639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af92432cfe7cc34703f62e15cc3283b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a8af92432cfe7cc34703f62e15cc3283b">s_aws_byte_buf_append_byte_dynamic</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *buffer, uint8_t value, <a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> clear_released_memory)</td></tr>
<tr class="separator:a8af92432cfe7cc34703f62e15cc3283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba06d49ab6e673130c3205c666e37c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a7ba06d49ab6e673130c3205c666e37c9">aws_byte_buf_append_byte_dynamic</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *buffer, uint8_t value)</td></tr>
<tr class="separator:a7ba06d49ab6e673130c3205c666e37c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64062c246870c740b40a7b847f75bad3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a64062c246870c740b40a7b847f75bad3">aws_byte_buf_append_byte_dynamic_secure</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *buffer, uint8_t value)</td></tr>
<tr class="separator:a64062c246870c740b40a7b847f75bad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af900ec5d14c51db19a58383ecdaecbe3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#af900ec5d14c51db19a58383ecdaecbe3">aws_byte_buf_reserve</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *buffer, size_t requested_capacity)</td></tr>
<tr class="separator:af900ec5d14c51db19a58383ecdaecbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cb440263d7afb68ae6a88ca92d98cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a73cb440263d7afb68ae6a88ca92d98cf">aws_byte_buf_reserve_relative</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *buffer, size_t additional_length)</td></tr>
<tr class="separator:a73cb440263d7afb68ae6a88ca92d98cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701ea769d956a8b45bb3bf3108e9ba60"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a701ea769d956a8b45bb3bf3108e9ba60">aws_byte_cursor_right_trim_pred</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *source, <a class="el" href="byte__buf_8h.html#ace0fa67cb735decc07988bf215701e22">aws_byte_predicate_fn</a> *predicate)</td></tr>
<tr class="separator:a701ea769d956a8b45bb3bf3108e9ba60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af052c1f50ed8119107b216d1623526ce"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#af052c1f50ed8119107b216d1623526ce">aws_byte_cursor_left_trim_pred</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *source, <a class="el" href="byte__buf_8h.html#ace0fa67cb735decc07988bf215701e22">aws_byte_predicate_fn</a> *predicate)</td></tr>
<tr class="separator:af052c1f50ed8119107b216d1623526ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a6efa66bf2efa66dd764c5b120129a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a14a6efa66bf2efa66dd764c5b120129a">aws_byte_cursor_trim_pred</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *source, <a class="el" href="byte__buf_8h.html#ace0fa67cb735decc07988bf215701e22">aws_byte_predicate_fn</a> *predicate)</td></tr>
<tr class="separator:a14a6efa66bf2efa66dd764c5b120129a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0582daf1e0324e84c2eeddadbae49b76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a0582daf1e0324e84c2eeddadbae49b76">aws_byte_cursor_satisfies_pred</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *source, <a class="el" href="byte__buf_8h.html#ace0fa67cb735decc07988bf215701e22">aws_byte_predicate_fn</a> *predicate)</td></tr>
<tr class="separator:a0582daf1e0324e84c2eeddadbae49b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c04f9cc728fb734ef9bc26432d177a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a36c04f9cc728fb734ef9bc26432d177a">aws_byte_cursor_compare_lexical</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *lhs, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *rhs)</td></tr>
<tr class="separator:a36c04f9cc728fb734ef9bc26432d177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf26003c9712b9d16e334aaef9888d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#abcf26003c9712b9d16e334aaef9888d1">aws_byte_cursor_compare_lookup</a> (const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *lhs, const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *rhs, const uint8_t *lookup_table)</td></tr>
<tr class="separator:abcf26003c9712b9d16e334aaef9888d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9635250be1b7cc705444b15a4ee959"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a2a9635250be1b7cc705444b15a4ee959">aws_byte_buf_from_c_str</a> (const char *c_str)</td></tr>
<tr class="separator:a2a9635250be1b7cc705444b15a4ee959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20059771adc23906f5e01f881ed4e14a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a20059771adc23906f5e01f881ed4e14a">aws_byte_buf_from_array</a> (const void *bytes, size_t <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a0f1e4ab31fd4f3ca4329091911f1f1af">len</a>)</td></tr>
<tr class="separator:a20059771adc23906f5e01f881ed4e14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e35c2ba3ed311c07ea04d6afdcc5e9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#aa1e35c2ba3ed311c07ea04d6afdcc5e9">aws_byte_buf_from_empty_array</a> (const void *bytes, size_t capacity)</td></tr>
<tr class="separator:aa1e35c2ba3ed311c07ea04d6afdcc5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad880888d05132a33f4301d706a39abe2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ad880888d05132a33f4301d706a39abe2">aws_byte_cursor_from_buf</a> (const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="separator:ad880888d05132a33f4301d706a39abe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb17ec562f4309e8d00717c9a6b9091"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a1eb17ec562f4309e8d00717c9a6b9091">aws_byte_cursor_from_c_str</a> (const char *c_str)</td></tr>
<tr class="separator:a1eb17ec562f4309e8d00717c9a6b9091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af2b9b3bd6c53ad69de9f506590edf0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a3af2b9b3bd6c53ad69de9f506590edf0">aws_byte_cursor_from_array</a> (const void *const bytes, const size_t <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a0f1e4ab31fd4f3ca4329091911f1f1af">len</a>)</td></tr>
<tr class="separator:a3af2b9b3bd6c53ad69de9f506590edf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877b6197e84a8a1671549cda787236d7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a877b6197e84a8a1671549cda787236d7">aws_nospec_mask</a> (size_t <a class="el" href="connection__state__test_8c.html#a3f42f10d93f6edb91d7d3f6edad25921">index</a>, size_t bound)</td></tr>
<tr class="separator:a877b6197e84a8a1671549cda787236d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e79909e24bdfce3bb0e3331886dcd3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a71e79909e24bdfce3bb0e3331886dcd3">aws_byte_cursor_advance</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const cursor, const size_t <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a0f1e4ab31fd4f3ca4329091911f1f1af">len</a>)</td></tr>
<tr class="separator:a71e79909e24bdfce3bb0e3331886dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3528b29474a2962bf2c4c231e6abea"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a6b3528b29474a2962bf2c4c231e6abea">aws_byte_cursor_advance_nospec</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const cursor, size_t <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a0f1e4ab31fd4f3ca4329091911f1f1af">len</a>)</td></tr>
<tr class="separator:a6b3528b29474a2962bf2c4c231e6abea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667d2681ddc208ee6c9145d93366c41d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a667d2681ddc208ee6c9145d93366c41d">aws_byte_cursor_read</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> cur, void *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> dest, const size_t <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a0f1e4ab31fd4f3ca4329091911f1f1af">len</a>)</td></tr>
<tr class="separator:a667d2681ddc208ee6c9145d93366c41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16de03a2ca7561f966a77e8c22e1877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#af16de03a2ca7561f966a77e8c22e1877">aws_byte_cursor_read_and_fill_buffer</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> cur, struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> dest)</td></tr>
<tr class="separator:af16de03a2ca7561f966a77e8c22e1877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571e1fa5c7a551535358f724dd40c7cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a571e1fa5c7a551535358f724dd40c7cb">aws_byte_cursor_read_u8</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> cur, uint8_t *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> var)</td></tr>
<tr class="separator:a571e1fa5c7a551535358f724dd40c7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8053828c7196b06a93ae486a5e996c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#aa8053828c7196b06a93ae486a5e996c7">aws_byte_cursor_read_be16</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *cur, uint16_t *var)</td></tr>
<tr class="separator:aa8053828c7196b06a93ae486a5e996c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaca6f258268874e503eb1672eff64b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#afeaca6f258268874e503eb1672eff64b">aws_byte_cursor_read_be24</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *cur, uint32_t *var)</td></tr>
<tr class="separator:afeaca6f258268874e503eb1672eff64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1da6b78bf530fdc1536abd48e4ef084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#aa1da6b78bf530fdc1536abd48e4ef084">aws_byte_cursor_read_be32</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *cur, uint32_t *var)</td></tr>
<tr class="separator:aa1da6b78bf530fdc1536abd48e4ef084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33db95c91d74113e776e269b29b75d24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a33db95c91d74113e776e269b29b75d24">aws_byte_cursor_read_float_be32</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *cur, float *var)</td></tr>
<tr class="separator:a33db95c91d74113e776e269b29b75d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b8d2d5abfa40c7d5da0d87889bb50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a08b8d2d5abfa40c7d5da0d87889bb50c">aws_byte_cursor_read_float_be64</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *cur, double *var)</td></tr>
<tr class="separator:a08b8d2d5abfa40c7d5da0d87889bb50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ebd0319d386143460aebd349870761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a60ebd0319d386143460aebd349870761">aws_byte_cursor_read_be64</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *cur, uint64_t *var)</td></tr>
<tr class="separator:a60ebd0319d386143460aebd349870761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7741579301dfe24b74938c1e34f0729"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#af7741579301dfe24b74938c1e34f0729">AWS_STATIC_ASSERT</a> (<a class="el" href="macros_8h.html#a7b837cfd09e209fa32b1129f8bc9c431">AWS_ARRAY_SIZE</a>(<a class="el" href="byte__buf_8c.html#a153765cf45f5be0abaeb4b946bb3e816">s_hex_to_num_table</a>)==256)</td></tr>
<tr class="separator:af7741579301dfe24b74938c1e34f0729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2393c6ee6236ff1b1adc0bfc9424257"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ad2393c6ee6236ff1b1adc0bfc9424257">aws_lookup_table_hex_to_num_get</a> (void)</td></tr>
<tr class="separator:ad2393c6ee6236ff1b1adc0bfc9424257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4686c6333f36ab47caa3032c4f5cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#aba4686c6333f36ab47caa3032c4f5cd0">aws_byte_cursor_read_hex_u8</a> (struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *cur, uint8_t *var)</td></tr>
<tr class="separator:aba4686c6333f36ab47caa3032c4f5cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f9a5b942f8bd53e13037e65cd88d87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a69f9a5b942f8bd53e13037e65cd88d87">aws_byte_buf_advance</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> buffer, struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> <a class="el" href="log__formatter__test_8c.html#ae73289c5189c80c0661459b0f4743217">output</a>, const size_t <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a0f1e4ab31fd4f3ca4329091911f1f1af">len</a>)</td></tr>
<tr class="separator:a69f9a5b942f8bd53e13037e65cd88d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eb15960520d84856f48e4cfe44e41c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ad5eb15960520d84856f48e4cfe44e41c">aws_byte_buf_write</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const uint8_t *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> src, size_t <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a0f1e4ab31fd4f3ca4329091911f1f1af">len</a>)</td></tr>
<tr class="separator:ad5eb15960520d84856f48e4cfe44e41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee727a2ce9e82fe553908fe7fa69799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a9ee727a2ce9e82fe553908fe7fa69799">aws_byte_buf_write_from_whole_buffer</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> src)</td></tr>
<tr class="separator:a9ee727a2ce9e82fe553908fe7fa69799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96b20ca3aa078b8c4437be04d9eb673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ae96b20ca3aa078b8c4437be04d9eb673">aws_byte_buf_write_from_whole_cursor</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> src)</td></tr>
<tr class="separator:ae96b20ca3aa078b8c4437be04d9eb673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b9ae8e8822d3a05daf3fc5eb513aef"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a85b9ae8e8822d3a05daf3fc5eb513aef">aws_byte_buf_write_to_capacity</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *advancing_cursor)</td></tr>
<tr class="separator:a85b9ae8e8822d3a05daf3fc5eb513aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f47337cb3ec100c5473ab188c3eb05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ad4f47337cb3ec100c5473ab188c3eb05">aws_byte_buf_write_u8</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a> <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, uint8_t c)</td></tr>
<tr class="separator:ad4f47337cb3ec100c5473ab188c3eb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ddba7196eb554b19184ab12129fb4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a21ddba7196eb554b19184ab12129fb4b">aws_byte_buf_write_u8_n</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, uint8_t c, size_t <a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#ad43c3812e6d13e0518d9f8b8f463ffcf">count</a>)</td></tr>
<tr class="separator:a21ddba7196eb554b19184ab12129fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91870598496fcac2bf5d77ad6a998b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a91870598496fcac2bf5d77ad6a998b7e">aws_byte_buf_write_be16</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, uint16_t x)</td></tr>
<tr class="separator:a91870598496fcac2bf5d77ad6a998b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf380cf62e596ce34aaceabcf7996d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#abf380cf62e596ce34aaceabcf7996d9c">aws_byte_buf_write_be24</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, uint32_t x)</td></tr>
<tr class="separator:abf380cf62e596ce34aaceabcf7996d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fd5bb13722894ccbfb6a39ed03e660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a81fd5bb13722894ccbfb6a39ed03e660">aws_byte_buf_write_be32</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, uint32_t x)</td></tr>
<tr class="separator:a81fd5bb13722894ccbfb6a39ed03e660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b9731ae303c500db1ca2420bf4f622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a40b9731ae303c500db1ca2420bf4f622">aws_byte_buf_write_float_be32</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, float x)</td></tr>
<tr class="separator:a40b9731ae303c500db1ca2420bf4f622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ea0bdff141303034776d462a902e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a7f5ea0bdff141303034776d462a902e0">aws_byte_buf_write_be64</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, uint64_t x)</td></tr>
<tr class="separator:a7f5ea0bdff141303034776d462a902e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac0cfa18673d619707634bcbd7c460e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#afac0cfa18673d619707634bcbd7c460e">aws_byte_buf_write_float_be64</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, double x)</td></tr>
<tr class="separator:afac0cfa18673d619707634bcbd7c460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ca07fbf29e7b255dadc32d72fccc1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a42ca07fbf29e7b255dadc32d72fccc1b">aws_byte_buf_append_and_update</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *to, struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *from_and_update)</td></tr>
<tr class="separator:a42ca07fbf29e7b255dadc32d72fccc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f3b8863e45d8b2c415567d865a7c74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ab8f3b8863e45d8b2c415567d865a7c74">aws_byte_buf_append_null_terminator</a> (struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="aws-crt-cpp_2crt_2aws-c-auth_2include_2aws_2auth_2external_2c_j_s_o_n_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="separator:ab8f3b8863e45d8b2c415567d865a7c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f48987b0892ebe2e376a6547ef6fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ad0f48987b0892ebe2e376a6547ef6fa0">aws_isalnum</a> (uint8_t ch)</td></tr>
<tr class="separator:ad0f48987b0892ebe2e376a6547ef6fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa4205568acb1986c0bf61a1795c7ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a3aa4205568acb1986c0bf61a1795c7ac">aws_isalpha</a> (uint8_t ch)</td></tr>
<tr class="separator:a3aa4205568acb1986c0bf61a1795c7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193948a51fc6548d8de1bc5da56ea9c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a193948a51fc6548d8de1bc5da56ea9c0">aws_isdigit</a> (uint8_t ch)</td></tr>
<tr class="separator:a193948a51fc6548d8de1bc5da56ea9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35764ea0c22877bb13898dbf1b930c98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a35764ea0c22877bb13898dbf1b930c98">aws_isxdigit</a> (uint8_t ch)</td></tr>
<tr class="separator:a35764ea0c22877bb13898dbf1b930c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f620e2ee444abb2b32ce93be3085d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#ab7f620e2ee444abb2b32ce93be3085d4">aws_isspace</a> (uint8_t ch)</td></tr>
<tr class="separator:ab7f620e2ee444abb2b32ce93be3085d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a44397e404df152393bd3201025f462ef"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a44397e404df152393bd3201025f462ef">s_tolower_table</a> []</td></tr>
<tr class="separator:a44397e404df152393bd3201025f462ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153765cf45f5be0abaeb4b946bb3e816"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#a153765cf45f5be0abaeb4b946bb3e816">s_hex_to_num_table</a> []</td></tr>
<tr class="separator:a153765cf45f5be0abaeb4b946bb3e816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf3d480fa71f545a92518909855bab2"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="byte__buf_8c.html#acdf3d480fa71f545a92518909855bab2">s_null_terminator_cursor</a> = <a class="el" href="byte__buf_8h.html#a25bb15426b081484f79b35669fc81b90">AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL</a>(&quot;\0&quot;)</td></tr>
<tr class="separator:acdf3d480fa71f545a92518909855bab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa60206f73448db770f5f66a54cf72b5a" name="aa60206f73448db770f5f66a54cf72b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60206f73448db770f5f66a54cf72b5a">&#9670;&nbsp;</a></span>aws_array_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_array_eq </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>array_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>array_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare two arrays. Return whether their contents are equivalent. NULL may be passed as the array pointer if its length is declared to be 0. </p>

</div>
</div>
<a id="a173ae70dc07148c93669d9bf695ab9bd" name="a173ae70dc07148c93669d9bf695ab9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173ae70dc07148c93669d9bf695ab9bd">&#9670;&nbsp;</a></span>aws_array_eq_c_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_array_eq_c_str </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>c_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare an array and a null-terminated string. Returns true if their contents are equivalent. The array should NOT contain a null-terminator, or the comparison will always return false. NULL may be passed as the array pointer if its length is declared to be 0. </p>

</div>
</div>
<a id="ab764fa5e408f601deef8f78aa969a92c" name="ab764fa5e408f601deef8f78aa969a92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab764fa5e408f601deef8f78aa969a92c">&#9670;&nbsp;</a></span>aws_array_eq_c_str_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_array_eq_c_str_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>c_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform a case-insensitive string comparison of an array and a null-terminated string. Return whether their contents are equivalent. The array should NOT contain a null-terminator, or the comparison will always return false. NULL may be passed as the array pointer if its length is declared to be 0. The "C" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too. </p>

</div>
</div>
<a id="ad7140a0d5f0196940bcf1d62f4679f33" name="ad7140a0d5f0196940bcf1d62f4679f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7140a0d5f0196940bcf1d62f4679f33">&#9670;&nbsp;</a></span>aws_array_eq_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_array_eq_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>array_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>array_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform a case-insensitive string comparison of two arrays. Return whether their contents are equivalent. NULL may be passed as the array pointer if its length is declared to be 0. The "C" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too. </p>

</div>
</div>
<a id="a69f9a5b942f8bd53e13037e65cd88d87" name="a69f9a5b942f8bd53e13037e65cd88d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f9a5b942f8bd53e13037e65cd88d87">&#9670;&nbsp;</a></span>aws_byte_buf_advance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_advance </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const <a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Appends a sub-buffer to the specified buffer.</p>
<p >If the buffer has at least &lsquo;len&rsquo; bytes remaining (buffer-&gt;capacity - buffer-&gt;len &gt;= len), then buffer-&gt;len is incremented by len, and an <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> is assigned to *output corresponding to the last len bytes of the input buffer. The <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> at *output will have a null allocator, a zero initial length, and a capacity of 'len'. The function then returns true.</p>
<p >If there is insufficient space, then this function nulls all fields in *output and returns false. </p>

</div>
</div>
<a id="acd3ab456a1b70a558da8e18e2724a948" name="acd3ab456a1b70a558da8e18e2724a948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3ab456a1b70a558da8e18e2724a948">&#9670;&nbsp;</a></span>aws_byte_buf_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies from to to. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. dest-&gt;len will contain the amount of data actually copied to dest.</p>
<p >from and to may be the same buffer, permitting copying a buffer into itself. </p>

</div>
</div>
<a id="a42ca07fbf29e7b255dadc32d72fccc1b" name="a42ca07fbf29e7b255dadc32d72fccc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ca07fbf29e7b255dadc32d72fccc1b">&#9670;&nbsp;</a></span>aws_byte_buf_append_and_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_append_and_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>from_and_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy contents of cursor to buffer, then update cursor to reference the memory stored in the buffer. If buffer is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned.</p>
<p >The cursor is permitted to reference memory from earlier in the buffer. </p>

</div>
</div>
<a id="a7ba06d49ab6e673130c3205c666e37c9" name="a7ba06d49ab6e673130c3205c666e37c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba06d49ab6e673130c3205c666e37c9">&#9670;&nbsp;</a></span>aws_byte_buf_append_byte_dynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_append_byte_dynamic </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies a single byte into <code>to</code>. If <code>to</code> is too small, the buffer will be grown appropriately and the old contents copied over, before the byte is appended.</p>
<p >If the grow fails (overflow or OOM), then an error will be returned. </p>

</div>
</div>
<a id="a64062c246870c740b40a7b847f75bad3" name="a64062c246870c740b40a7b847f75bad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64062c246870c740b40a7b847f75bad3">&#9670;&nbsp;</a></span>aws_byte_buf_append_byte_dynamic_secure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_append_byte_dynamic_secure </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies a single byte into <code>to</code>. If <code>to</code> is too small, the buffer will be grown appropriately and the old contents copied over, before the byte is appended.</p>
<p >If the grow fails (overflow or OOM), then an error will be returned.</p>
<p >If the buffer is grown, the old buffer will be securely cleared before getting freed. </p>

</div>
</div>
<a id="ab4a34b2d690f402d6f1eb78da880d43d" name="ab4a34b2d690f402d6f1eb78da880d43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a34b2d690f402d6f1eb78da880d43d">&#9670;&nbsp;</a></span>aws_byte_buf_append_dynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_append_dynamic </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies from to to. If to is too small, the buffer will be grown appropriately and the old contents copied to, before the new contents are appended.</p>
<p >If the grow fails (overflow or OOM), then an error will be returned.</p>
<p >from and to may be the same buffer, permitting copying a buffer into itself. </p>

</div>
</div>
<a id="a208d9f01f769fbc2440aa7d98019e639" name="a208d9f01f769fbc2440aa7d98019e639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208d9f01f769fbc2440aa7d98019e639">&#9670;&nbsp;</a></span>aws_byte_buf_append_dynamic_secure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_append_dynamic_secure </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies <code>from</code> to <code>to</code>. If <code>to</code> is too small, the buffer will be grown appropriately and the old contents copied over, before the new contents are appended.</p>
<p >If the grow fails (overflow or OOM), then an error will be returned.</p>
<p >If the buffer is grown, the old buffer will be securely cleared before getting freed.</p>
<p ><code>from</code> and <code>to</code> may be the same buffer, permitting copying a buffer into itself. </p>

</div>
</div>
<a id="ab8f3b8863e45d8b2c415567d865a7c74" name="ab8f3b8863e45d8b2c415567d865a7c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f3b8863e45d8b2c415567d865a7c74">&#9670;&nbsp;</a></span>aws_byte_buf_append_null_terminator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_append_null_terminator </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Appends '\0' at the end of the buffer. </p>

</div>
</div>
<a id="a448b75fae26a0e95e178ac9629482e6f" name="a448b75fae26a0e95e178ac9629482e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448b75fae26a0e95e178ac9629482e6f">&#9670;&nbsp;</a></span>aws_byte_buf_append_with_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_append_with_lookup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>lookup_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies from to to while converting bytes via the passed in lookup table. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. to-&gt;len will contain its original size plus the amount of data actually copied to to.</p>
<p >from and to should not be the same buffer (overlap is not handled) lookup_table must be at least 256 bytes </p>

</div>
</div>
<a id="a6ed7bf940089a3adfb6e44ab70203156" name="a6ed7bf940089a3adfb6e44ab70203156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed7bf940089a3adfb6e44ab70203156">&#9670;&nbsp;</a></span>aws_byte_buf_cat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_cat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Concatenates a variable number of struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> * into destination. Number of args must be greater than 1. If dest is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. dest-&gt;len will contain the amount of data actually copied to dest. </p>

</div>
</div>
<a id="acbddfbd5ccda972a6630cd841fec7b21" name="acbddfbd5ccda972a6630cd841fec7b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbddfbd5ccda972a6630cd841fec7b21">&#9670;&nbsp;</a></span>aws_byte_buf_clean_up()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aws_byte_buf_clean_up </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f4e4659a9a46d1014b10424a87b8286" name="a9f4e4659a9a46d1014b10424a87b8286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4e4659a9a46d1014b10424a87b8286">&#9670;&nbsp;</a></span>aws_byte_buf_clean_up_secure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aws_byte_buf_clean_up_secure </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Equivalent to calling aws_byte_buf_secure_zero and then aws_byte_buf_clean_up on the buffer. </p>

</div>
</div>
<a id="a2246da0ca31f44fc92d4ebc9fa16cb45" name="a2246da0ca31f44fc92d4ebc9fa16cb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2246da0ca31f44fc92d4ebc9fa16cb45">&#9670;&nbsp;</a></span>aws_byte_buf_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_eq </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare two <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> structures. Return whether their contents are equivalent. </p>

</div>
</div>
<a id="ab9d84517a8dd0c4ab2b3b17c108814c4" name="ab9d84517a8dd0c4ab2b3b17c108814c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d84517a8dd0c4ab2b3b17c108814c4">&#9670;&nbsp;</a></span>aws_byte_buf_eq_c_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_eq_c_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>c_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare an <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> and a null-terminated string. Returns true if their contents are equivalent. The buffer should NOT contain a null-terminator, or the comparison will always return false. </p>

</div>
</div>
<a id="af2e8f1e9a122054ada8a3e867aa9a6f8" name="af2e8f1e9a122054ada8a3e867aa9a6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e8f1e9a122054ada8a3e867aa9a6f8">&#9670;&nbsp;</a></span>aws_byte_buf_eq_c_str_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_eq_c_str_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>c_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform a case-insensitive string comparison of an <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> and a null-terminated string. Return whether their contents are equivalent. The buffer should NOT contain a null-terminator, or the comparison will always return false. The "C" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too. </p>

</div>
</div>
<a id="a23180f5c686096e7f2902e147635aeb1" name="a23180f5c686096e7f2902e147635aeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23180f5c686096e7f2902e147635aeb1">&#9670;&nbsp;</a></span>aws_byte_buf_eq_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_eq_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform a case-insensitive string comparison of two <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> structures. Return whether their contents are equivalent. The "C" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too. </p>

</div>
</div>
<a id="a20059771adc23906f5e01f881ed4e14a" name="a20059771adc23906f5e01f881ed4e14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20059771adc23906f5e01f881ed4e14a">&#9670;&nbsp;</a></span>aws_byte_buf_from_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> aws_byte_buf_from_array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a9635250be1b7cc705444b15a4ee959" name="a2a9635250be1b7cc705444b15a4ee959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9635250be1b7cc705444b15a4ee959">&#9670;&nbsp;</a></span>aws_byte_buf_from_c_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> aws_byte_buf_from_c_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>c_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >For creating a byte buffer from a null-terminated string literal. </p>

</div>
</div>
<a id="aa1e35c2ba3ed311c07ea04d6afdcc5e9" name="aa1e35c2ba3ed311c07ea04d6afdcc5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e35c2ba3ed311c07ea04d6afdcc5e9">&#9670;&nbsp;</a></span>aws_byte_buf_from_empty_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> aws_byte_buf_from_empty_array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf8ed14982cd1aa9e83c924ebb5856ae" name="adf8ed14982cd1aa9e83c924ebb5856ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8ed14982cd1aa9e83c924ebb5856ae">&#9670;&nbsp;</a></span>aws_byte_buf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__allocator.html">aws_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. SPDX-License-Identifier: Apache-2.0. </p>

</div>
</div>
<a id="aac5490e5293c67b8f0a82342ea81c917" name="aac5490e5293c67b8f0a82342ea81c917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5490e5293c67b8f0a82342ea81c917">&#9670;&nbsp;</a></span>aws_byte_buf_init_cache_and_update_cursors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_init_cache_and_update_cursors </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__allocator.html">aws_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Init buffer with contents of multiple cursors, and update cursors to reference the memory stored in the buffer. Each cursor arg must be an <code>struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *</code>. NULL must be passed as the final arg. NOTE: Do not append/grow/resize buffers initialized this way, or the cursors will end up referencing invalid memory. Returns AWS_OP_SUCCESS in case of success. AWS_OP_ERR is returned if memory can't be allocated or the total cursor length exceeds SIZE_MAX. </p>

</div>
</div>
<a id="afcaa669dd210b0cf9820deca75c9a686" name="afcaa669dd210b0cf9820deca75c9a686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcaa669dd210b0cf9820deca75c9a686">&#9670;&nbsp;</a></span>aws_byte_buf_init_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_init_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__allocator.html">aws_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initializes an <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> structure base on another valid one. Requires: *src and *allocator are valid objects. Ensures: *dest is a valid <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> with a new backing array dest-&gt;buffer which is a copy of the elements from src-&gt;buffer. </p>

</div>
</div>
<a id="add0e7102270fffc97b9d7da4d0a38bd7" name="add0e7102270fffc97b9d7da4d0a38bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0e7102270fffc97b9d7da4d0a38bd7">&#9670;&nbsp;</a></span>aws_byte_buf_init_copy_from_cursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_init_copy_from_cursor </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__allocator.html">aws_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies src buffer into dest and sets the correct len and capacity. A new memory zone is allocated for dest-&gt;buffer. When dest is no longer needed it will have to be cleaned-up using aws_byte_buf_clean_up(dest). Dest capacity and len will be equal to the src len. Allocator of the dest will be identical with parameter allocator. If src buffer is null the dest will have a null buffer with a len and a capacity of 0 Returns AWS_OP_SUCCESS in case of success or AWS_OP_ERR when memory can't be allocated. </p>

</div>
</div>
<a id="a07926449452596f7b4750430607a9277" name="a07926449452596f7b4750430607a9277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07926449452596f7b4750430607a9277">&#9670;&nbsp;</a></span>aws_byte_buf_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_is_valid </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Evaluates the set of properties that define the shape of all valid <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> structures. It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion). </p>

</div>
</div>
<a id="af900ec5d14c51db19a58383ecdaecbe3" name="af900ec5d14c51db19a58383ecdaecbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af900ec5d14c51db19a58383ecdaecbe3">&#9670;&nbsp;</a></span>aws_byte_buf_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_reserve </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>requested_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attempts to increase the capacity of a buffer to the requested capacity</p>
<p >If the the buffer's capacity is currently larger than the request capacity, the function does nothing (no shrink is performed). </p>

</div>
</div>
<a id="a73cb440263d7afb68ae6a88ca92d98cf" name="a73cb440263d7afb68ae6a88ca92d98cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cb440263d7afb68ae6a88ca92d98cf">&#9670;&nbsp;</a></span>aws_byte_buf_reserve_relative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_buf_reserve_relative </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>additional_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Convenience function that attempts to increase the capacity of a buffer relative to the current length.</p>
<p >aws_byte_buf_reserve_relative(buf, x) ~~ aws_byte_buf_reserve(buf, buf-&gt;len + x) </p>

</div>
</div>
<a id="aba38e9db5164e21174386de288aa1c7d" name="aba38e9db5164e21174386de288aa1c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba38e9db5164e21174386de288aa1c7d">&#9670;&nbsp;</a></span>aws_byte_buf_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aws_byte_buf_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>zero_contents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Resets the len of the buffer to 0, but does not free the memory. The buffer can then be reused. Optionally zeroes the contents, if the "zero_contents" flag is true. </p>

</div>
</div>
<a id="ac1d0a2e070ce4e156bc636c9873eb4ad" name="ac1d0a2e070ce4e156bc636c9873eb4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d0a2e070ce4e156bc636c9873eb4ad">&#9670;&nbsp;</a></span>aws_byte_buf_secure_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aws_byte_buf_secure_zero </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets all bytes of buffer to zero and resets len to zero. </p>

</div>
</div>
<a id="ad5eb15960520d84856f48e4cfe44e41c" name="ad5eb15960520d84856f48e4cfe44e41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eb15960520d84856f48e4cfe44e41c">&#9670;&nbsp;</a></span>aws_byte_buf_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write specified number of bytes from array to byte buffer.</p>
<p >On success, returns true and updates the buffer length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged. </p>

</div>
</div>
<a id="a91870598496fcac2bf5d77ad6a998b7e" name="a91870598496fcac2bf5d77ad6a998b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91870598496fcac2bf5d77ad6a998b7e">&#9670;&nbsp;</a></span>aws_byte_buf_write_be16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_be16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Writes a 16-bit integer in network byte order (big endian) to buffer.</p>
<p >On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="abf380cf62e596ce34aaceabcf7996d9c" name="abf380cf62e596ce34aaceabcf7996d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf380cf62e596ce34aaceabcf7996d9c">&#9670;&nbsp;</a></span>aws_byte_buf_write_be24()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_be24 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Writes low 24-bits (3 bytes) of an unsigned integer in network byte order (big endian) to buffer. Ex: If x is 0x00AABBCC then {0xAA, 0xBB, 0xCC} is written to buffer.</p>
<p >On success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, or x's value cannot fit in 3 bytes, returns false, leaving the buffer unchanged. </p>

</div>
</div>
<a id="a81fd5bb13722894ccbfb6a39ed03e660" name="a81fd5bb13722894ccbfb6a39ed03e660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fd5bb13722894ccbfb6a39ed03e660">&#9670;&nbsp;</a></span>aws_byte_buf_write_be32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_be32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Writes a 32-bit integer in network byte order (big endian) to buffer.</p>
<p >On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="a7f5ea0bdff141303034776d462a902e0" name="a7f5ea0bdff141303034776d462a902e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5ea0bdff141303034776d462a902e0">&#9670;&nbsp;</a></span>aws_byte_buf_write_be64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_be64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Writes a 64-bit integer in network byte order (big endian) to buffer.</p>
<p >On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="a40b9731ae303c500db1ca2420bf4f622" name="a40b9731ae303c500db1ca2420bf4f622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b9731ae303c500db1ca2420bf4f622">&#9670;&nbsp;</a></span>aws_byte_buf_write_float_be32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_float_be32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Writes a 32-bit float in network byte order (big endian) to buffer.</p>
<p >On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="afac0cfa18673d619707634bcbd7c460e" name="afac0cfa18673d619707634bcbd7c460e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac0cfa18673d619707634bcbd7c460e">&#9670;&nbsp;</a></span>aws_byte_buf_write_float_be64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_float_be64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Writes a 64-bit float in network byte order (big endian) to buffer.</p>
<p >On success, returns true and updates the cursor /length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="a9ee727a2ce9e82fe553908fe7fa69799" name="a9ee727a2ce9e82fe553908fe7fa69799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee727a2ce9e82fe553908fe7fa69799">&#9670;&nbsp;</a></span>aws_byte_buf_write_from_whole_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_from_whole_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies all bytes from buffer to buffer.</p>
<p >On success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged. </p>

</div>
</div>
<a id="ae96b20ca3aa078b8c4437be04d9eb673" name="ae96b20ca3aa078b8c4437be04d9eb673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96b20ca3aa078b8c4437be04d9eb673">&#9670;&nbsp;</a></span>aws_byte_buf_write_from_whole_cursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_from_whole_cursor </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies all bytes from buffer to buffer.</p>
<p >On success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged. </p>

</div>
</div>
<a id="a85b9ae8e8822d3a05daf3fc5eb513aef" name="a85b9ae8e8822d3a05daf3fc5eb513aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b9ae8e8822d3a05daf3fc5eb513aef">&#9670;&nbsp;</a></span>aws_byte_buf_write_to_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> aws_byte_buf_write_to_capacity </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>advancing_cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Without increasing buf's capacity, write as much as possible from advancing_cursor into buf.</p>
<p >buf's len is updated accordingly. advancing_cursor is advanced so it contains the remaining unwritten parts. Returns the section of advancing_cursor which was written.</p>
<p >This function cannot fail. If buf is full (len == capacity) or advancing_len has 0 length, then buf and advancing_cursor are not altered and a cursor with 0 length is returned.</p>
<p >Example: Given a buf with 2 bytes of space available and advancing_cursor with contents "abc". "ab" will be written to buf and buf-&gt;len will increase 2 and become equal to buf-&gt;capacity. advancing_cursor will advance so its contents become the unwritten "c". The returned cursor's contents will be the "ab" from the original advancing_cursor. </p>

</div>
</div>
<a id="ad4f47337cb3ec100c5473ab188c3eb05" name="ad4f47337cb3ec100c5473ab188c3eb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f47337cb3ec100c5473ab188c3eb05">&#9670;&nbsp;</a></span>aws_byte_buf_write_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_u8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies one byte to buffer.</p>
<p >On success, returns true and updates the cursor /length accordingly.</p>
<p >If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="a21ddba7196eb554b19184ab12129fb4b" name="a21ddba7196eb554b19184ab12129fb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ddba7196eb554b19184ab12129fb4b">&#9670;&nbsp;</a></span>aws_byte_buf_write_u8_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_buf_write_u8_n </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Writes one byte repeatedly to buffer (like memset)</p>
<p >If there is insufficient space in the buffer, returns false, leaving the buffer unchanged. </p>

</div>
</div>
<a id="a71e79909e24bdfce3bb0e3331886dcd3" name="a71e79909e24bdfce3bb0e3331886dcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e79909e24bdfce3bb0e3331886dcd3">&#9670;&nbsp;</a></span>aws_byte_cursor_advance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> aws_byte_cursor_advance </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tests if the given <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> has at least len bytes remaining. If so, *buf is advanced by len bytes (incrementing -&gt;ptr and decrementing -&gt;len), and an <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> referring to the first len bytes of the original *buf is returned. Otherwise, an <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> with -&gt;ptr = NULL, -&gt;len = 0 is returned.</p>
<p >Note that if len is above (SIZE_MAX / 2), this function will also treat it as a buffer overflow, and return NULL without changing *buf. </p>

</div>
</div>
<a id="a6b3528b29474a2962bf2c4c231e6abea" name="a6b3528b29474a2962bf2c4c231e6abea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3528b29474a2962bf2c4c231e6abea">&#9670;&nbsp;</a></span>aws_byte_cursor_advance_nospec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> aws_byte_cursor_advance_nospec </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Behaves identically to aws_byte_cursor_advance, but avoids speculative execution potentially reading out-of-bounds pointers (by returning an empty ptr in such speculated paths).</p>
<p >This should generally be done when using an untrusted or data-dependent value for 'len', to avoid speculating into a path where cursor-&gt;ptr points outside the true ptr length. </p>

</div>
</div>
<a id="a36c04f9cc728fb734ef9bc26432d177a" name="a36c04f9cc728fb734ef9bc26432d177a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c04f9cc728fb734ef9bc26432d177a">&#9670;&nbsp;</a></span>aws_byte_cursor_compare_lexical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_cursor_compare_lexical </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Lexical (byte value) comparison of two byte cursors </p>

</div>
</div>
<a id="abcf26003c9712b9d16e334aaef9888d1" name="abcf26003c9712b9d16e334aaef9888d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf26003c9712b9d16e334aaef9888d1">&#9670;&nbsp;</a></span>aws_byte_cursor_compare_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_cursor_compare_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>lookup_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Lexical (byte value) comparison of two byte cursors where the raw values are sent through a lookup table first </p>

</div>
</div>
<a id="a6ac432a626706052a527c1349fb8cbd4" name="a6ac432a626706052a527c1349fb8cbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac432a626706052a527c1349fb8cbd4">&#9670;&nbsp;</a></span>aws_byte_cursor_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_eq </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare two <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> structures. Return whether their contents are equivalent. </p>

</div>
</div>
<a id="a31a7dc00c06d8a4abe69a9680934336a" name="a31a7dc00c06d8a4abe69a9680934336a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a7dc00c06d8a4abe69a9680934336a">&#9670;&nbsp;</a></span>aws_byte_cursor_eq_byte_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_eq_byte_buf </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare an <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> and an <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a>. Return whether their contents are equivalent. </p>

</div>
</div>
<a id="a6952e4ba3307e2a05d5edadc0d92cee0" name="a6952e4ba3307e2a05d5edadc0d92cee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6952e4ba3307e2a05d5edadc0d92cee0">&#9670;&nbsp;</a></span>aws_byte_cursor_eq_byte_buf_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_eq_byte_buf_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform a case-insensitive string comparison of an <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> and an <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a>. Return whether their contents are equivalent. The "C" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too. </p>

</div>
</div>
<a id="a410ca19b956f672343dfa71c2f534abe" name="a410ca19b956f672343dfa71c2f534abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410ca19b956f672343dfa71c2f534abe">&#9670;&nbsp;</a></span>aws_byte_cursor_eq_c_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_eq_c_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>c_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare an <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> and a null-terminated string. Returns true if their contents are equivalent. The cursor should NOT contain a null-terminator, or the comparison will always return false. </p>

</div>
</div>
<a id="afbd816b132e73605793c8a7b848997b1" name="afbd816b132e73605793c8a7b848997b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd816b132e73605793c8a7b848997b1">&#9670;&nbsp;</a></span>aws_byte_cursor_eq_c_str_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_eq_c_str_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *const&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>c_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform a case-insensitive string comparison of an <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> and a null-terminated string. Return whether their contents are equivalent. The cursor should NOT contain a null-terminator, or the comparison will always return false. The "C" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too. </p>

</div>
</div>
<a id="a509e25ff72150c5f4f4a40e48432c402" name="a509e25ff72150c5f4f4a40e48432c402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509e25ff72150c5f4f4a40e48432c402">&#9670;&nbsp;</a></span>aws_byte_cursor_eq_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_eq_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform a case-insensitive string comparison of two <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> structures. Return whether their contents are equivalent. The "C" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too. </p>

</div>
</div>
<a id="a8034dfb48cf116946a092436e409bf9a" name="a8034dfb48cf116946a092436e409bf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8034dfb48cf116946a092436e409bf9a">&#9670;&nbsp;</a></span>aws_byte_cursor_find_exact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_cursor_find_exact </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>input_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>to_find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>first_find</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Search for an exact byte match inside a cursor. The first match will be returned. Returns AWS_OP_SUCCESS on successful match and first_find will be set to the offset in input_str, and length will be the remaining length from input_str past the returned offset. If the match was not found, AWS_OP_ERR will be returned and AWS_ERROR_STRING_MATCH_NOT_FOUND will be raised. </p>

</div>
</div>
<a id="a3af2b9b3bd6c53ad69de9f506590edf0" name="a3af2b9b3bd6c53ad69de9f506590edf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af2b9b3bd6c53ad69de9f506590edf0">&#9670;&nbsp;</a></span>aws_byte_cursor_from_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> aws_byte_cursor_from_array </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad880888d05132a33f4301d706a39abe2" name="ad880888d05132a33f4301d706a39abe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad880888d05132a33f4301d706a39abe2">&#9670;&nbsp;</a></span>aws_byte_cursor_from_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> aws_byte_cursor_from_buf </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *const&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eb17ec562f4309e8d00717c9a6b9091" name="a1eb17ec562f4309e8d00717c9a6b9091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb17ec562f4309e8d00717c9a6b9091">&#9670;&nbsp;</a></span>aws_byte_cursor_from_c_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> aws_byte_cursor_from_c_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>c_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a58a8d6758717dcdbf2ed031d44d68c" name="a6a58a8d6758717dcdbf2ed031d44d68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a58a8d6758717dcdbf2ed031d44d68c">&#9670;&nbsp;</a></span>aws_byte_cursor_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_is_valid </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Evaluates the set of properties that define the shape of all valid <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> structures. It is also a cheap check, in the sense it runs in constant time (i.e., no loops or recursion). </p>

</div>
</div>
<a id="af052c1f50ed8119107b216d1623526ce" name="af052c1f50ed8119107b216d1623526ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af052c1f50ed8119107b216d1623526ce">&#9670;&nbsp;</a></span>aws_byte_cursor_left_trim_pred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> aws_byte_cursor_left_trim_pred </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="byte__buf_8h.html#ace0fa67cb735decc07988bf215701e22">aws_byte_predicate_fn</a> *&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Shrinks a byte cursor from the left for as long as the supplied predicate is true </p>

</div>
</div>
<a id="a8500b18cf261cffbd69dec5f4dd698c1" name="a8500b18cf261cffbd69dec5f4dd698c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8500b18cf261cffbd69dec5f4dd698c1">&#9670;&nbsp;</a></span>aws_byte_cursor_next_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_next_split </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>input_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>split_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >No copies, no buffer allocations. Iterates over input_str, and returns the next substring between split_on instances.</p>
<p >Edge case rules are as follows: If the input is an empty string, an empty cursor will be the one entry returned. If the input begins with split_on, an empty cursor will be the first entry returned. If the input has two adjacent split_on tokens, an empty cursor will be returned. If the input ends with split_on, an empty cursor will be returned last.</p>
<p >It is the user's responsibility zero-initialize substr before the first call.</p>
<p >It is the user's responsibility to make sure the input buffer stays in memory long enough to use the results. </p>

</div>
</div>
<a id="a667d2681ddc208ee6c9145d93366c41d" name="a667d2681ddc208ee6c9145d93366c41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667d2681ddc208ee6c9145d93366c41d">&#9670;&nbsp;</a></span>aws_byte_cursor_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads specified length of data from byte cursor and copies it to the destination array.</p>
<p >On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="af16de03a2ca7561f966a77e8c22e1877" name="af16de03a2ca7561f966a77e8c22e1877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16de03a2ca7561f966a77e8c22e1877">&#9670;&nbsp;</a></span>aws_byte_cursor_read_and_fill_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read_and_fill_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads as many bytes from cursor as size of buffer, and copies them to buffer.</p>
<p >On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="aa8053828c7196b06a93ae486a5e996c7" name="aa8053828c7196b06a93ae486a5e996c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8053828c7196b06a93ae486a5e996c7">&#9670;&nbsp;</a></span>aws_byte_cursor_read_be16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read_be16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads a 16-bit value in network byte order from cur, and places it in host byte order into var.</p>
<p >On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="afeaca6f258268874e503eb1672eff64b" name="afeaca6f258268874e503eb1672eff64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaca6f258268874e503eb1672eff64b">&#9670;&nbsp;</a></span>aws_byte_cursor_read_be24()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read_be24 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads an unsigned 24-bit value (3 bytes) in network byte order from cur, and places it in host byte order into 32-bit var. Ex: if cur's next 3 bytes are {0xAA, 0xBB, 0xCC}, then var becomes 0x00AABBCC.</p>
<p >On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="aa1da6b78bf530fdc1536abd48e4ef084" name="aa1da6b78bf530fdc1536abd48e4ef084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1da6b78bf530fdc1536abd48e4ef084">&#9670;&nbsp;</a></span>aws_byte_cursor_read_be32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read_be32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads a 32-bit value in network byte order from cur, and places it in host byte order into var.</p>
<p >On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="a60ebd0319d386143460aebd349870761" name="a60ebd0319d386143460aebd349870761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ebd0319d386143460aebd349870761">&#9670;&nbsp;</a></span>aws_byte_cursor_read_be64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read_be64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads a 64-bit value in network byte order from cur, and places it in host byte order into var.</p>
<p >On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="a33db95c91d74113e776e269b29b75d24" name="a33db95c91d74113e776e269b29b75d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33db95c91d74113e776e269b29b75d24">&#9670;&nbsp;</a></span>aws_byte_cursor_read_float_be32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read_float_be32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads a 32-bit value in network byte order from cur, and places it in host byte order into var.</p>
<p >On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="a08b8d2d5abfa40c7d5da0d87889bb50c" name="a08b8d2d5abfa40c7d5da0d87889bb50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b8d2d5abfa40c7d5da0d87889bb50c">&#9670;&nbsp;</a></span>aws_byte_cursor_read_float_be64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read_float_be64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads a 64-bit value in network byte order from cur, and places it in host byte order into var.</p>
<p >On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="aba4686c6333f36ab47caa3032c4f5cd0" name="aba4686c6333f36ab47caa3032c4f5cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4686c6333f36ab47caa3032c4f5cd0">&#9670;&nbsp;</a></span>aws_byte_cursor_read_hex_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read_hex_u8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads 2 hex characters from ASCII/UTF-8 text to produce an 8-bit number. Accepts both lowercase 'a'-'f' and uppercase 'A'-'F'. For example: "0F" produces 15.</p>
<p >On success, returns true and advances the cursor by 2. If there is insufficient space in the cursor or an invalid character is encountered, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="a571e1fa5c7a551535358f724dd40c7cb" name="a571e1fa5c7a551535358f724dd40c7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571e1fa5c7a551535358f724dd40c7cb">&#9670;&nbsp;</a></span>aws_byte_cursor_read_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_read_u8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads a single byte from cursor, placing it in *var.</p>
<p >On success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged. </p>

</div>
</div>
<a id="a701ea769d956a8b45bb3bf3108e9ba60" name="a701ea769d956a8b45bb3bf3108e9ba60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701ea769d956a8b45bb3bf3108e9ba60">&#9670;&nbsp;</a></span>aws_byte_cursor_right_trim_pred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> aws_byte_cursor_right_trim_pred </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="byte__buf_8h.html#ace0fa67cb735decc07988bf215701e22">aws_byte_predicate_fn</a> *&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Shrinks a byte cursor from the right for as long as the supplied predicate is true </p>

</div>
</div>
<a id="a0582daf1e0324e84c2eeddadbae49b76" name="a0582daf1e0324e84c2eeddadbae49b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0582daf1e0324e84c2eeddadbae49b76">&#9670;&nbsp;</a></span>aws_byte_cursor_satisfies_pred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_byte_cursor_satisfies_pred </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="byte__buf_8h.html#ace0fa67cb735decc07988bf215701e22">aws_byte_predicate_fn</a> *&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true if the byte cursor's range of bytes all satisfy the predicate </p>

</div>
</div>
<a id="ac6ebbd786227e59a3aba25b8abe43d6e" name="ac6ebbd786227e59a3aba25b8abe43d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ebbd786227e59a3aba25b8abe43d6e">&#9670;&nbsp;</a></span>aws_byte_cursor_split_on_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_cursor_split_on_char </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>input_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>split_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__array__list.html">aws_array_list</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >No copies, no buffer allocations. Fills in output with a list of <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> instances where buffer is an offset into the input_str and len is the length of that string in the original buffer.</p>
<p >Edge case rules are as follows: if the input begins with split_on, an empty cursor will be the first entry in output. if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output. if the input ends with split_on, an empty cursor will be appended to the output.</p>
<p >It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from output is your most likely guess for the upper bound of the number of elements resulting from the split.</p>
<p >The type that will be stored in output is struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> (you'll need this for the item size param).</p>
<p >It is the user's responsibility to make sure the input buffer stays in memory long enough to use the results. </p>

</div>
</div>
<a id="a49db4870532ddfadf616887d3fb2fed5" name="a49db4870532ddfadf616887d3fb2fed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49db4870532ddfadf616887d3fb2fed5">&#9670;&nbsp;</a></span>aws_byte_cursor_split_on_char_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aws_byte_cursor_split_on_char_n </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>input_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>split_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaws__array__list.html">aws_array_list</a> *<a class="el" href="macros_8h.html#a9bb2dfa7c751efe1673e3f9c89eff17c">AWS_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >No copies, no buffer allocations. Fills in output with a list of <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> instances where buffer is an offset into the input_str and len is the length of that string in the original buffer. N is the max number of splits, if this value is zero, it will add all splits to the output.</p>
<p >Edge case rules are as follows: if the input begins with split_on, an empty cursor will be the first entry in output if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output. if the input ends with split_on, an empty cursor will be appended to the output.</p>
<p >It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from output is your most likely guess for the upper bound of the number of elements resulting from the split.</p>
<p >If the output array is not large enough, input_str will be updated to point to the first character after the last processed split_on instance.</p>
<p >The type that will be stored in output is struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> (you'll need this for the item size param).</p>
<p >It is the user's responsibility to make sure the input buffer stays in memory long enough to use the results. </p>

</div>
</div>
<a id="a14a6efa66bf2efa66dd764c5b120129a" name="a14a6efa66bf2efa66dd764c5b120129a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a6efa66bf2efa66dd764c5b120129a">&#9670;&nbsp;</a></span>aws_byte_cursor_trim_pred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> aws_byte_cursor_trim_pred </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="byte__buf_8h.html#ace0fa67cb735decc07988bf215701e22">aws_byte_predicate_fn</a> *&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Shrinks a byte cursor from both sides for as long as the supplied predicate is true </p>

</div>
</div>
<a id="ab2b52ce0371e324b33ec2006fe3207fa" name="ab2b52ce0371e324b33ec2006fe3207fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b52ce0371e324b33ec2006fe3207fa">&#9670;&nbsp;</a></span>aws_hash_array_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t aws_hash_array_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Case-insensitive hash function for array containing ASCII or UTF-8 text. </p>

</div>
</div>
<a id="a2bb583d1f274a5863b152cee4749bcc9" name="a2bb583d1f274a5863b152cee4749bcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb583d1f274a5863b152cee4749bcc9">&#9670;&nbsp;</a></span>aws_hash_byte_cursor_ptr_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t aws_hash_byte_cursor_ptr_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Case-insensitive hash function for aws_byte_cursors stored in an <a class="el" href="structaws__hash__table.html">aws_hash_table</a>. For case-sensitive hashing, use <a class="el" href="hash__table_8h.html#a54682fd811203b400867b9cb64c42acd">aws_hash_byte_cursor_ptr()</a>. </p>

</div>
</div>
<a id="ad0f48987b0892ebe2e376a6547ef6fa0" name="ad0f48987b0892ebe2e376a6547ef6fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f48987b0892ebe2e376a6547ef6fa0">&#9670;&nbsp;</a></span>aws_isalnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_isalnum </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Like isalnum(), but ignores C locale. Returns true if ch has the value of ASCII/UTF-8: 'a'-'z', 'A'-'Z', or '0'-'9'. </p>

</div>
</div>
<a id="a3aa4205568acb1986c0bf61a1795c7ac" name="a3aa4205568acb1986c0bf61a1795c7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa4205568acb1986c0bf61a1795c7ac">&#9670;&nbsp;</a></span>aws_isalpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_isalpha </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Like isalpha(), but ignores C locale. Returns true if ch has the value of ASCII/UTF-8: 'a'-'z' or 'A'-'Z'. </p>

</div>
</div>
<a id="a193948a51fc6548d8de1bc5da56ea9c0" name="a193948a51fc6548d8de1bc5da56ea9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193948a51fc6548d8de1bc5da56ea9c0">&#9670;&nbsp;</a></span>aws_isdigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_isdigit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Like isdigit(). Returns true if ch has the value of ASCII/UTF-8: '0'-'9'.</p>
<p >Note: C's built-in isdigit() is also supposed to ignore the C locale, but cppreference.com claims "some implementations (e.g. Microsoft in 1252 codepage)
may classify additional single-byte characters as digits" </p>

</div>
</div>
<a id="ab7f620e2ee444abb2b32ce93be3085d4" name="ab7f620e2ee444abb2b32ce93be3085d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f620e2ee444abb2b32ce93be3085d4">&#9670;&nbsp;</a></span>aws_isspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_isspace </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Like isspace(), but ignores C locale. Return true if ch has the value of ASCII/UTF-8: space (0x20), form feed (0x0C), line feed (0x0A), carriage return (0x0D), horizontal tab (0x09), or vertical tab (0x0B). </p>

</div>
</div>
<a id="a35764ea0c22877bb13898dbf1b930c98" name="a35764ea0c22877bb13898dbf1b930c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35764ea0c22877bb13898dbf1b930c98">&#9670;&nbsp;</a></span>aws_isxdigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> aws_isxdigit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Like isxdigit(). Returns true if ch has the value of ASCII/UTF-8: '0'-'9', 'a'-'f', or 'A'-'F'.</p>
<p >Note: C's built-in isxdigit() is also supposed to ignore the C locale, but cppreference.com claims "some implementations (e.g. Microsoft in 1252 codepage)
may classify additional single-byte characters as digits" </p>

</div>
</div>
<a id="ad2393c6ee6236ff1b1adc0bfc9424257" name="ad2393c6ee6236ff1b1adc0bfc9424257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2393c6ee6236ff1b1adc0bfc9424257">&#9670;&nbsp;</a></span>aws_lookup_table_hex_to_num_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* aws_lookup_table_hex_to_num_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns lookup table to go from ASCII/UTF-8 hex character to a number (0-15). Non-hex characters map to 255. Valid examples: '0' -&gt; 0 'F' -&gt; 15 'f' -&gt; 15 Invalid examples: ' ' -&gt; 255 'Z' -&gt; 255 '\0' -&gt; 255 </p>

</div>
</div>
<a id="af1fe4a204cae799ed595d635d9979590" name="af1fe4a204cae799ed595d635d9979590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1fe4a204cae799ed595d635d9979590">&#9670;&nbsp;</a></span>aws_lookup_table_to_lower_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* aws_lookup_table_to_lower_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a lookup table for bytes that is the identity transformation with the exception of uppercase ascii characters getting replaced with lowercase characters. Used in caseless comparisons. </p>

</div>
</div>
<a id="a877b6197e84a8a1671549cda787236d7" name="a877b6197e84a8a1671549cda787236d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877b6197e84a8a1671549cda787236d7">&#9670;&nbsp;</a></span>aws_nospec_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t aws_nospec_mask </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If index &gt;= bound, bound &gt; (SIZE_MAX / 2), or index &gt; (SIZE_MAX / 2), returns 0. Otherwise, returns UINTPTR_MAX. This function is designed to return the correct value even under CPU speculation conditions, and is intended to be used for SPECTRE mitigation purposes. </p>

</div>
</div>
<a id="af7741579301dfe24b74938c1e34f0729" name="af7741579301dfe24b74938c1e34f0729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7741579301dfe24b74938c1e34f0729">&#9670;&nbsp;</a></span>AWS_STATIC_ASSERT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AWS_STATIC_ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="macros_8h.html#a7b837cfd09e209fa32b1129f8bc9c431">AWS_ARRAY_SIZE</a>(<a class="el" href="byte__buf_8c.html#a153765cf45f5be0abaeb4b946bb3e816">s_hex_to_num_table</a>)&#160;</td>
          <td class="paramname"> = <code>=256</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9e2f9f9e603d6d21aceba0cccb77bb9" name="af9e2f9f9e603d6d21aceba0cccb77bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e2f9f9e603d6d21aceba0cccb77bb9">&#9670;&nbsp;</a></span>AWS_STATIC_ASSERT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AWS_STATIC_ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="macros_8h.html#a7b837cfd09e209fa32b1129f8bc9c431">AWS_ARRAY_SIZE</a>(<a class="el" href="byte__buf_8c.html#a44397e404df152393bd3201025f462ef">s_tolower_table</a>)&#160;</td>
          <td class="paramname"> = <code>=256</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8af92432cfe7cc34703f62e15cc3283b" name="a8af92432cfe7cc34703f62e15cc3283b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af92432cfe7cc34703f62e15cc3283b">&#9670;&nbsp;</a></span>s_aws_byte_buf_append_byte_dynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int s_aws_byte_buf_append_byte_dynamic </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>clear_released_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec56ee1008054c5a0aee809cc324e330" name="aec56ee1008054c5a0aee809cc324e330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec56ee1008054c5a0aee809cc324e330">&#9670;&nbsp;</a></span>s_aws_byte_buf_append_dynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int s_aws_byte_buf_append_dynamic </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaws__byte__buf.html">aws_byte_buf</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="preamble_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>clear_released_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a153765cf45f5be0abaeb4b946bb3e816" name="a153765cf45f5be0abaeb4b946bb3e816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153765cf45f5be0abaeb4b946bb3e816">&#9670;&nbsp;</a></span>s_hex_to_num_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t s_hex_to_num_table[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    255, 255,</div>
<div class="line">    </div>
<div class="line">    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    </div>
<div class="line">    0xA, 0xB, 0xC, 0xD, 0xE, 0xF,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    255, 255, 255,</div>
<div class="line">    </div>
<div class="line">    0xa, 0xb, 0xc, 0xd, 0xe, 0xf,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acdf3d480fa71f545a92518909855bab2" name="acdf3d480fa71f545a92518909855bab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf3d480fa71f545a92518909855bab2">&#9670;&nbsp;</a></span>s_null_terminator_cursor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaws__byte__cursor.html">aws_byte_cursor</a> s_null_terminator_cursor = <a class="el" href="byte__buf_8h.html#a25bb15426b081484f79b35669fc81b90">AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL</a>(&quot;\0&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44397e404df152393bd3201025f462ef" name="a44397e404df152393bd3201025f462ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44397e404df152393bd3201025f462ef">&#9670;&nbsp;</a></span>s_tolower_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t s_tolower_table[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,</div>
<div class="line">    22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,</div>
<div class="line">    44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  <span class="charliteral">&#39;a&#39;</span>,</div>
<div class="line">    <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;f&#39;</span>, <span class="charliteral">&#39;g&#39;</span>, <span class="charliteral">&#39;h&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;j&#39;</span>, <span class="charliteral">&#39;k&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;p&#39;</span>, <span class="charliteral">&#39;q&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;w&#39;</span>,</div>
<div class="line">    <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;z&#39;</span>, 91,  92,  93,  94,  95,  96,  <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;f&#39;</span>, <span class="charliteral">&#39;g&#39;</span>, <span class="charliteral">&#39;h&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;j&#39;</span>, <span class="charliteral">&#39;k&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;m&#39;</span>,</div>
<div class="line">    <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;p&#39;</span>, <span class="charliteral">&#39;q&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;w&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;z&#39;</span>, 123, 124, 125, 126, 127, 128, 129, 130, 131,</div>
<div class="line">    132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,</div>
<div class="line">    154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,</div>
<div class="line">    176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,</div>
<div class="line">    198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,</div>
<div class="line">    220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,</div>
<div class="line">    242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
