<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AWS IoT Device SDK C++ v2: AWS-C-IO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AWS IoT Device SDK C++ v2<span id="projectnumber">&#160;1.14.0</span>
   </div>
   <div id="projectbrief">AWS IoT Device SDK C++ v2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">AWS-C-IO </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >This is a module for the AWS SDK for C. It handles all IO and TLS work for application protocols.</p>
<p >aws-c-io is an event driven framework for implementing application protocols. It is built on top of cross-platform abstractions that allow you as a developer to think only about the state machine and API for your protocols. A typical use-case would be to write something like Http on top of asynchronous-io with TLS already baked in. All of the platform and security concerns are already handled for you.</p>
<p >It is designed to be light-weight, fast, portable, and flexible for multiple domain use-cases such as: embedded, server, client, and mobile.</p>
<h1><a class="anchor" id="autotoc_md141"></a>
License</h1>
<p >This library is licensed under the Apache 2.0 License.</p>
<h1><a class="anchor" id="autotoc_md142"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md143"></a>
Building</h2>
<h3><a class="anchor" id="autotoc_md144"></a>
Building s2n (Linux Only)</h3>
<p >If you are building on Linux, you will need to build s2n before being able to build aws-c-io. For our CRT's, we build s2n at a specific commit, and recommend doing the same when using it with this library. That commit hash can be found <a href="https://github.com/awslabs/aws-crt-cpp/tree/main/crt">here</a>. The commands below will build s2n using OpenSSL 1.1.1. For using other versions of OpenSSL, there is additional information in the <a href="https://github.com/awslabs/s2n/blob/main/docs/USAGE-GUIDE.md">s2n Usage Guide</a>.</p>
<div class="fragment"><div class="line">git clone git@github.com:awslabs/s2n.git</div>
<div class="line">cd s2n</div>
<div class="line">git checkout &lt;s2n-commit-hash-used-by-aws-crt-cpp&gt;</div>
<div class="line"> </div>
<div class="line"># We keep the build artifacts in the -build directory</div>
<div class="line">cd libcrypto-build</div>
<div class="line"> </div>
<div class="line"># Download the latest version of OpenSSL</div>
<div class="line">curl -LO https://www.openssl.org/source/openssl-1.1.1-latest.tar.gz</div>
<div class="line">tar -xzvf openssl-1.1.1-latest.tar.gz</div>
<div class="line"> </div>
<div class="line"># Build openssl libcrypto.  Note that the install path specified here must be absolute.</div>
<div class="line">cd `tar ztf openssl-1.1.1-latest.tar.gz | head -n1 | cut -f1 -d/`</div>
<div class="line">./config -fPIC no-shared              \</div>
<div class="line">         no-md2 no-rc5 no-rfc3779 no-sctp no-ssl-trace no-zlib     \</div>
<div class="line">         no-hw no-mdc2 no-seed no-idea enable-ec_nistp_64_gcc_128 no-camellia\</div>
<div class="line">         no-bf no-ripemd no-dsa no-ssl2 no-ssl3 no-capieng                  \</div>
<div class="line">         -DSSL_FORBID_ENULL -DOPENSSL_NO_DTLS1 -DOPENSSL_NO_HEARTBEATS      \</div>
<div class="line">         --prefix=&lt;absolute-install-path&gt;</div>
<div class="line">make</div>
<div class="line">make install</div>
<div class="line"> </div>
<div class="line"># Build s2n</div>
<div class="line">cd ../../../</div>
<div class="line">cmake -DCMAKE_PREFIX_PATH=&lt;install-path&gt; -DCMAKE_INSTALL_PREFIX=&lt;install-path&gt; -S s2n -B s2n/build</div>
<div class="line">cmake --build s2n/build --target install</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md145"></a>
Building aws-c-io and Remaining Dependencies</h3>
<p >Note that aws-c-io has a dependency on aws-c-common so it must be built first:</p>
<div class="fragment"><div class="line">git clone git@github.com:awslabs/aws-c-common.git</div>
<div class="line">cmake -DCMAKE_PREFIX_PATH=&lt;install-path&gt; -DCMAKE_INSTALL_PREFIX=&lt;install-path&gt; -S aws-c-common -B aws-c-common/build</div>
<div class="line">cmake --build aws-c-common/build --target install</div>
<div class="line"> </div>
<div class="line">git clone git@github.com:awslabs/aws-c-cal.git</div>
<div class="line">cmake -DCMAKE_PREFIX_PATH=&lt;install-path&gt; -DCMAKE_INSTALL_PREFIX=&lt;install-path&gt; -S aws-c-cal -B aws-c-cal/build</div>
<div class="line">cmake --build aws-c-cal/build --target install</div>
<div class="line"> </div>
<div class="line">git clone git@github.com:awslabs/aws-c-io.git</div>
<div class="line">cmake -DCMAKE_PREFIX_PATH=&lt;install-path&gt; -DCMAKE_INSTALL_PREFIX=&lt;install-path&gt; -S aws-c-io -B aws-c-io/build</div>
<div class="line">cmake --build aws-c-io/build --target install</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md146"></a>
Usage Patterns</h2>
<p >This library contains many primitive building blocks that can be configured in a myriad of ways. However, most likely you simply need to use the <code><a class="el" href="structaws__event__loop__group.html">aws_event_loop_group</a></code> and <code>aws_channel_bootstrap</code> APIs.</p>
<p >Typical Client API Usage Pattern: </p><pre class="fragment">    /* setup */
    aws_io_library_init(allocator);

    struct aws_event_loop_group el_group;

    if (aws_event_loop_group_init_default(&amp;el_group, allocator)) {
        goto cleanup;
    }

    struct aws_tls_ctx_options tls_options = { ... };
    struct aws_tls_ctx *tls_ctx = aws_tls_client_ctx_new(allocator, &amp;tls_options);

    struct aws_tls_connection_options tls_client_conn_options = { ... };

    struct aws_client_bootstrap client_bootstrap;

    if (aws_client_bootstrap_init(&amp;client_bootstrap, allocator, &amp;el_group) {
        goto cleanup;
    }

    aws_client_bootstrap_set_tls_ctx(&amp;client_bootstrap, tls_ctx);
    aws_client_bootstrap_set_alpn_callback(&amp;client_bootstrap, your_alpn_callback);

    /* throughout your application's lifetime */
    struct aws_socket_options sock_options = { ... };
    struct aws_socket_endpoint endpoint = { ... };

    if (aws_client_bootstrap_new_tls_socket_channel(&amp;client_bootrap, &amp;endpoint, &amp;sock_options, &amp;tls_options,
            your_channel_setup_callback, your_channel_shutdown_callback, your_context_data) {
        goto cleanup;
    }

    /* shutdown */
    aws_client_bootstrap_clean_up(&amp;client_bootstrap);
    aws_tls_client_ctx_destroy(tls_ctx);
    aws_event_loop_group_clean_up(&amp;el_group);
    aws_io_library_clean_up();
</pre><p> Typical Server API Usage Pattern: </p><pre class="fragment">    /* setup */
    aws_io_library_init(allocator);

    struct aws_event_loop_group el_group;

    if (aws_event_loop_group_init_default(&amp;el_group, allocator)) {
        goto cleanup;
    }

    struct aws_tls_ctx_options tls_options = { ... };
    struct aws_tls_ctx *tls_ctx = aws_tls_server_ctx_new(allocator, &amp;tls_options);

    struct aws_tls_connection_options tls_server_conn_options = { ... };

    struct aws_socket_options sock_options = { ... };
    struct aws_socket_endpoint endpoint = { ... };

    struct aws_server_bootstrap server_bootstrap;

    if (aws_server_bootstrap_init(&amp;server_bootstrap, allocator, &amp;el_group) {
        goto cleanup;
    }

    aws_server_bootstrap_set_tls_ctx(&amp;server_bootstrap, tls_ctx);
    aws_server_bootstrap_set_alpn_callback(&amp;server_bootstrap, your_alpn_callback);

    struct aws_socket *listener = aws_server_bootstrap_add_tls_socket_listener(&amp;server_bootstrap, &amp;endpoint, &amp;sock_options, &amp;tls_options,
                                                  your_incoming_channel_callback, your_channel_shutdown_callback, your_context_data);

    if (!listener) {
        goto cleanup;
    }


    /* shutdown */
    aws_server_bootstrap_remove_socket_listener(listener);
    aws_server_bootstrap_clean_up(&amp;server_bootstrap);
    aws_tls_server_ctx_destroy(tls_ctx);
    awS_event_loop_group_clean_up(&amp;el_group);
    aws_io_library_clean_up();
</pre><p> If you are building a protocol on top of sockets without the use of TLS, you can still use this pattern as your starting point. Simply call the <code>aws_client_bootstrap_new_socket_channel</code> <code>aws_server_bootstrap_add_socket_listener</code> respectively: instead of the TLS variants.</p>
<h1><a class="anchor" id="autotoc_md147"></a>
Concepts</h1>
<h2><a class="anchor" id="autotoc_md148"></a>
Event Loop</h2>
<p >Core to Async-IO is the event-loop. We provide an implementation for most platforms out of the box:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Platform   </th><th class="markdownTableHeadNone">Implementation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone">Edge-Triggered Epoll    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BSD Variants and Apple Devices   </td><td class="markdownTableBodyNone">KQueue    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone">IOCP (IO Completion Ports)   </td></tr>
</table>
<p >Also, you can always implement your own as well.</p>
<p >An Event Loop has a few jobs.</p>
<ol type="1">
<li>Notify subscribers of IO Events</li>
<li>Execute and maintain a task scheduler</li>
<li>Maintain an opaque data store for consumers</li>
</ol>
<p >The threading model for a channel (see below) is pinned to the thread of the event-loop. Each event-loop implementation provides an API to move a cross-thread call into the event-loop thread if necessary.</p>
<h2><a class="anchor" id="autotoc_md149"></a>
Channels and Slots</h2>
<p >A channel is simply a container that drives the slots. It is responsible for providing an interface between slots and the underlying event-loop as well as invoking the slots to pass messages. As a channel runs. It also provides utilities for making sure slots and their handlers run in the correct thread and moving execution to that thread if necessary.</p>
<p ><img src="docs/images/channels_slots.png" alt="Channels and Slots Diagram" class="inline"/></p>
<p >In this diagram, a channel is a collection of slots, and it knows how to make them communicate. It also controls the lifetime of slots.</p>
<p >When a channel is being shutdown, it will issue shutdown_direction messages in the appropriate direction. If it is in the read direction, it will call shutdown_direction on the first slot. Conversely, in the write direction, it will call shutdown_direction on the last slot in the channel. When all slots have successfully shutdown, the channel can be safely cleaned up and de-allocated.</p>
<h2><a class="anchor" id="autotoc_md150"></a>
Slots</h2>
<p ><img src="docs/images/slots.png" alt="Slots Diagram" class="inline"/></p>
<p >Slots maintain their links to adjacent slots in the channel. So as the channel is processed, each slot will read from its left-adjacent slot, send those messages to the handler, and call their right-adjacent slot when it needs to send a message. Conversely, each slot will read from its right-adjacent slot, send those messages to the handler, and send messages to the left-adjacent slot in the channel. Most importantly, slots contain a reference to a handler. Handlers are responsible for doing most of the work (see below). Finally, slots have utilities for manipulating the connections of the slots themselves.</p>
<p >Slots can also be added, removed, or replaced dynamically from a channel.</p>
<h2><a class="anchor" id="autotoc_md151"></a>
Channel Handlers</h2>
<p >The channel handler is the fundamental unit that protocol developers will implement. It contains all of your state machinery, framing, and optionally end-user APIs.</p>
<p ><img src="docs/images/handler.png" alt="Handler Diagram" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md152"></a>
Special, pre-defined handlers</h3>
<p >Out of the box you get a few handlers pre-implemented.</p><ol type="1">
<li>Sockets. We've done the heavy lifting of implementing a consistent sockets interface for each platform. Sockets interact directly with the underlying io and are invoked directly by the event-loop for io events.</li>
<li>Pipes (or something like them depending on platform), these are particularly useful for testing.</li>
<li>TLS. We provide TLS implementations for most platforms.</li>
</ol>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Platform   </th><th class="markdownTableHeadNone">Implementation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone">Signal-to-noise (s2n) see github.com/awslabs/s2n    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BSD Variants   </td><td class="markdownTableBodyNone">s2n    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Apple Devices   </td><td class="markdownTableBodyNone">Security Framework/ Secure Transport. See <a href="https://developer.apple.com/documentation/security/secure_transport">https://developer.apple.com/documentation/security/secure_transport</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone">Secure Channel. See <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380123(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/aa380123(v=vs.85).aspx</a>   </td></tr>
</table>
<p >In addition, you can always write your own handler around your favorite implementation and use that.</p>
<h2><a class="anchor" id="autotoc_md153"></a>
Typical Channel</h2>
<p ><img src="docs/images/typical_channel.png" alt="Typical Channel Diagram" class="inline"/></p>
<p >A typical channel will contain a socket handler, which receives io events from the event-loop. It will read up to 16 kb and pass the data to the next handler. The next handler is typically feeding a TLS implementation (see the above section on pre-defined handlers). The TLS handler will then pass the data to an application protocol. The application protocol could then expose an API to an application. When the application wants to send data, the whole process runs in reverse.</p>
<p >Channels can be much more complex though. For example, there could be nested channels for multiplexing/de-multiplexing, or there could be more handlers to cut down on handler complexity.</p>
<p >Note however, that a channel is always pinned to a single thread. It provides utilities for applications and handlers to move a task into that thread, but it is very important that handlers and application users of your handlers never block.</p>
<h2><a class="anchor" id="autotoc_md154"></a>
Channel IO Operation Fairness</h2>
<p >Since multiple channels run in the same event-loop, we need to make sure channels are not starved by other active channels. To address this, the handlers consuming IO events from the event-loop should determine the appropriate max read and write and context switch before continuing. A context switch is performed, simply by scheduling a task to run at the current timestamp, to continue the IO operation.</p>
<p >A reasonable default is 16kb, but a savvy implementation may want to upgrade a few connections to 256kb if they notice a particularly fast connection (e.g. you notice EAGAIN or EWOULDBLOCK is never returned from write() calls).</p>
<h2><a class="anchor" id="autotoc_md155"></a>
Read Back Pressure</h2>
<p >One of the most challenging aspects of asynchronous io programming, is managing when back-pressure should be applied to the underlying io layer. In the read direction, this is managed via update_window messages. Let's look at the below diagram for an example of how this works.</p>
<p >In this example, we have a channel setup with an event-loop which manages io event notifications. The first slot contains a socket handler. The socket handler will read directly from the socket. The second slot has a TLS handler. Its only job is to encrypt/decrypt the data passed to it and pass it back to the channel. The third and final slot contains the actual application protocol handler (could be Http, SIP, RTP it doesn't really matter).</p>
<p >The application protocol exposes an API to the application. As data is processed, we don't want to endlessly read, allocate, and process data faster than the application can use it. As a result, it has a 20kb window.</p>
<p ><img src="docs/images/read_backpressure.png" alt="Read Back Pressure Diagram" class="inline"/></p>
<ol type="1">
<li><p class="startli">The event-loop notifies the socket handler that it has data available to read. The handler knows it can read up to 20kb so it reads a full 16kb from the socket and passes it to the next slot. Since the socket sees that there is still an open window, it, schedules a task to read again after the other channels have had a chance to process their pending reads.</p>
<p class="startli">Likewise, the TLS handler decrypts the data and passes it to the slot containing the application protocol.</p>
<p class="startli">The application protocol processes the 16 kb and hands it off to the application. At this point, the application hasn't notified the channel it is finished with the data (suppose application queues it), so the new window for the slot is 4 kb.</p>
</li>
<li><p class="startli">The event-loop runs the scheduled read task from (1) after processing the other channels. The socket handler sees it can read 4kb more of data. Even though it can read 16kb at a time, to honor the window, it reads 4kb and passes it on. This time however, the window is 0, so the socket does not schedule another read task.</p>
<p class="startli">The TLS handler decrypts the data and passes it on</p>
<p class="startli">The application protocol reads 4kb, passes it to the application and its window is 0kb.</p>
<p class="startli">The channel now goes idle waiting on the application to finish processing its data.</p>
</li>
<li><p class="startli">The application notifies the channel (via the API on the application protocol handler) it has processed 20kb of data. This causes the protocol handler to issue an update_window message with an update of 20kb.</p>
<p class="startli">Slot 2 passes the message on to the TLS handler. It evaluates the message and simply, sends a 20kb window update message to its slot.</p>
<p class="startli">The socket handler receives the update_window message and schedules a new read task.</p>
</li>
<li>The event-loop runs the scheduled read task from (3). The socket reads on the io-handle, but it returns EAGAIN or EWOULD_BLOCK. The channel now goes back to an idle state waiting on the event-loop to notify it that the socket is readable.</li>
</ol>
<h2><a class="anchor" id="autotoc_md156"></a>
Write Back Pressure</h2>
<p >Write back pressure comes into play when the application can produce data more quickly than it can be sent to the underlying io. To manage this, messages have members to attach a promise fn and context data to. When a handler exposes an API, it has the responsibility to take a fn and data from the user if over write is a possibility. The io-handler will invoke the promise after it has successfully written the last byte to the underlying io.</p>
<h2><a class="anchor" id="autotoc_md157"></a>
Thread Safety</h2>
<p >In general, the plan for addressing thread-safety is to not share memory across threads. This library is designed around single threaded event-loops which process one or more channels. Anywhere a handler or channel exposes a back-channel API, it is responsible for checking which thread it was invoked from. If it is invoked from the event-loop's thread, then it may proceed as planned. If it is not, it is required to queue a task to do the work. When the task is executed, it will be executed in the correct thread.</p>
<p >The functions we specify as thread-safe, we do so because those functions are necessary for abiding by the stated threading model. For example, since scheduling a task is the main function for addressing cross-threaded operations, it has to be thread-safe.</p>
<h1><a class="anchor" id="autotoc_md158"></a>
Terminology</h1>
<p >We use a few terms in the following sections that are not necessarily "C concepts". We assume you know C, but here are some definitions that may be helpful.</p>
<h2><a class="anchor" id="autotoc_md159"></a>
Run-time Polymorphic</h2>
<p >This means that the API is driven by a virtual-table. This is simply a struct of function pointers. They are invoked via a c extern style API, but ultimately those public functions simply invoke the corresponding function in the v-table.</p>
<p >These are reserved for types that: a.) Need to be configurable, changable at runtime b.) Do not have immediate performance concerns caused by an indirect function call.</p>
<h2><a class="anchor" id="autotoc_md160"></a>
Compile-time Polymorphic</h2>
<p >This means that the API is not necessarily driven by a virtual-table. It is exposed as a c extern style API, but the build system makes a decision about which symbols to compile based on factors such as platform and compile-time flags.</p>
<p >These are reserved for types that: a.) Need to be configurable at compile-time based on platform or compile-time options. b.) Have performance concerns caused by an indirect function call.</p>
<p >Note: that runtime configurability may still be something we need to expose here. In that case, a compiler flag will be used to denote that we are using a custom implementation for x feature. Then we will expose an implementation that indirectly invokes from a v-table and provides hooks for the application to plug into at runtime.</p>
<h2><a class="anchor" id="autotoc_md161"></a>
Promise, Promise Context</h2>
<p >There are many phrases for this, callback, baton, event-handler etc... The key idea is that APIs that need to notify a caller when an asynchronous action is completed, should take a callback function and a pointer to an opaque object and invoke it upon completion. This term doesn't refer to the layout of the data. A promise in some instances may be a collection of functions in a structure. It's simply the language we use for the concept.</p>
<h1><a class="anchor" id="autotoc_md162"></a>
API</h1>
<p ><b>Note: unless otherwise stated,</b></p>
<ul>
<li>no functions in this API are allowed to block.</li>
<li>nothing is thread-safe unless explicitly stated.</li>
</ul>
<h2><a class="anchor" id="autotoc_md163"></a>
Event Loop</h2>
<p >Event Loops are run-time polymorphic. We provide some implementations out of the box and a way to get an implementation without having to call a different function per platform. However, you can also create your own implementation and use it on any API that takes an event-loop as a parameter.</p>
<p >From a design perspective, the event-loop is not aware of channels or any of its handlers. It interacts with other entities only via its API.</p>
<h3><a class="anchor" id="autotoc_md164"></a>
Layout</h3>
<p >struct <a class="el" href="structaws__event__loop.html">aws_event_loop</a> { struct <a class="el" href="structaws__event__loop__vtable.html">aws_event_loop_vtable</a> vtable; aws_clock clock; struct aws_allocator *allocator; struct aws_common_hash_table local_storage; void *impl_data; };</p>
<h3><a class="anchor" id="autotoc_md165"></a>
V-Table</h3>
<pre class="fragment">struct aws_event_loop_vtable {
    void (*destroy)(struct aws_event_loop *);
    int (*run) (struct aws_event_loop *);
    int (*stop) (struct aws_event_loop *, void (*on_stopped) (struct aws_event_loop *, void *), void *promise_user_data);
    int (*schedule_task) (struct aws_event_loop *, struct aws_task *task, uint64_t run_at);
    int (*subscribe_to_io_events) (struct aws_event_loop *, struct aws_io_handle *, int events,
        void(*on_event)(struct aws_event_loop *, struct aws_io_handle *, void *), void *user_data);
    int (*unsubscribe_from_io_events) (struct aws_event_loop *, struct aws_io_handle *);
    BOOL (*is_on_callers_thread) (struct aws_event_loop *);
};
</pre><p> Every implementation of <a class="el" href="structaws__event__loop.html">aws_event_loop</a> must implement this table. Let's look at some details for what each entry does. </p><pre class="fragment">void (*destroy)(struct aws_event_loop *);
</pre><p> This function is invoked when the event-loop is finished processing and is ready to be cleaned up and deallocated. </p><pre class="fragment">int (*run) (struct aws_event_loop *);
</pre><p> This function starts the running of the event-loop and then immediately returns. This could kick off a thread, or setup some resources to run and receive events in a back channel API. For example, you could have an epoll loop that runs in a thread, or you could have an event-loop pumped by a system loop such as glib, or libevent etc... and then publish events to your event-loop implementation. </p><pre class="fragment">int (*stop) (struct aws_event_loop *,
 void (*on_stopped) (struct aws_event_loop *, void *), void *promise_user_data);
</pre><p> The stop function signals the event-loop to shutdown. This function should not block but it should remove active io handles from the currently monitored or polled set and should begin notifying current subscribers via the on_event callback that the handle was removed._ Once the event-loop has shutdown to a safe state, it should invoke the on_stopped function. </p><pre class="fragment">int (*schedule_task) (struct aws_event_loop *, struct aws_task *task, uint64_t run_at);
</pre><p> This function schedules a task to run in its task scheduler at the time specified by run_at. Each event-loop is responsible for implementing a task scheduler. This function must not block, and must be thread-safe. How this is implemented will depend on platform. For example, one reasonable implementation is if the call comes from the event-loop's thread, to queue it in the task scheduler directly. Otherwise, write to a pipe that the event-loop is listening for events on. Upon noticing the write to the pipe, it can read the task from the pipe and schedule the task.</p>
<p ><code>task</code> must be copied.</p>
<p ><code>run_at</code> is using the system <code>RAW_MONOTONIC</code> clock (or the closest thing to it for that platform). It is represented as nanos since unix epoch. </p><pre class="fragment">int (*subscribe_to_io_events) (struct aws_event_loop *, struct aws_io_handle *, int events,
        void(*on_event)(struct aws_event_loop *, struct aws_io_handle *, int events, void *), void *user_data);
</pre><p> A subscriber will call this function to register an io_handle for event monitoring. This function is thread-safe.</p>
<p ><code>events</code> is a bit field of the events the subscriber wants to receive. A few events will always be registered (regardless of the value passed here), such as <code>AWS_IO_EVENT_HANDLE_REMOVED</code>. The event-loop will invoke <code>on_event</code> anytime it receives one or more of the registered events.</p>
<p ><b>NOTE: The event-loop is not responsible for manipulating or setting io flags on io_handles. It will never call, read(), write(), connect(), accept(), close() etc... on any io handle it does not explicitly own. It is the subscriber's responsibility to know how to respond to the event.</b></p>
<p ><b>NOTE: The event-loop will not maintain any state other than the io handles it is polling. So, for example, in edge-triggered epoll, it does not maintain a read ready list. It is the subscriber's responsibility to know it has more data to read or write and to schedule its tasks appropriately.</b> </p><pre class="fragment">int (*unsubscribe_from_io_events) (struct aws_event_loop *, struct aws_io_handle *);
</pre><p> A subscriber will call this function to remove its io handle from the monitored events. For example, it would may this immediately before calling close() on a socket or pipe. <code>on_event</code> will still be invoked with <code>AWS_IO_EVENT_HANDLE_REMOVED</code> when this occurs. </p><pre class="fragment">BOOL (*is_on_callers_thread) (struct aws_event_loop *);
</pre><p> Returns <code>TRUE</code> if the caller is on the same thread as the event-loop. Returns <code>FALSE</code> otherwise. This allows users of the event-loop to make a decision about whether it is safe to interact with the loop directly, or if they need to schedule a task to run in the correct thread. This function is thread-safe.</p>
<h3><a class="anchor" id="autotoc_md166"></a>
API</h3>
<pre class="fragment">int aws_event_loop_init_base (struct aws_allocator *, aws_clock clock, ...);
</pre><p> Initializes common data for all event-loops regardless of implementation. All implementations must call this function before returning from their allocation function. </p><pre class="fragment">struct aws_event_loop *aws_event_loop_new_default (struct aws_allocator *, aws_clock clock, ...);
</pre><p> Allocates and initializes the default event-loop implementation for the current platform. Calls <code>aws_event_loop_init_base</code> before returning. </p><pre class="fragment">struct aws_event_loop *aws_event_loop_destroy (struct aws_event_loop *);
</pre><p> Cleans up internal state of the event-loop implementation, and then calls the v-table <code>destroy</code> function. </p><pre class="fragment">int aws_event_loop_fetch_local_object ( struct aws_event_loop *, void *key, void **item);
</pre><p> All event-loops contain local storage for all users of the event-loop to store common data into. This function is for fetching one of those objects by key. The key for this store is of type <code>void *</code>. This function is NOT thread safe, and it expects the caller to be calling from the event-loop's thread. If this is not the case, the caller must first schedule a task on the event-loop to enter the correct thread. </p><pre class="fragment">int aws_event_loop_put_local_object ( struct aws_event_loop *, void *key, void *item);
</pre><p> All event-loops contain local storage for all users of the event-loop to store common data into. This function is for putting one of those objects by key. The key for this store is of type <code>size_t</code>. This function is NOT thread safe, and it expects the caller to be calling from the event-loop's thread. If this is not the case, the caller must first schedule a task on the event-loop to enter the correct thread. </p><pre class="fragment">int aws_event_loop_remove_local_object ( struct aws_event_loop *, void *key, void **item);
</pre><p> All event loops contain local storage for all users of the event loop to store common data into. This function is for removing one of those objects by key. The key for this store is of type <code>void *</code>. This function is NOT thread safe, and it expects the caller to be calling from the event loop's thread. If this is not the case, the caller must first schedule a task on the event loop to enter the correct thread. If found, and item is not NULL, the removed item is moved to <code>item</code>. It is the removers responsibility to free the memory pointed to by item. If it is NULL, the default deallocation strategy for the event loop will be used. </p><pre class="fragment">int aws_event_loop_current_ticks ( struct aws_event_loop *, uint64_t *ticks);
</pre><p> Gets the current tick count/timestamp for the event loop's clock. This function is thread-safe.</p>
<h3><a class="anchor" id="autotoc_md167"></a>
V-Table Shims</h3>
<p >The remaining exported functions on event loop simply invoke the v-table functions and return. See the v-table section for more details.</p>
<h2><a class="anchor" id="autotoc_md168"></a>
Channels and Slots</h2>
<h3><a class="anchor" id="autotoc_md169"></a>
Layout</h3>
<p >struct <a class="el" href="structaws__channel.html">aws_channel</a> { struct aws_allocator *alloc; struct <a class="el" href="structaws__event__loop.html">aws_event_loop</a> *loop; struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *first; };</p>
<p >struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> { struct aws_allocator *alloc; struct <a class="el" href="structaws__channel.html">aws_channel</a> *channel; struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *adj_left; struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *adj_right; struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler; };</p>
<h3><a class="anchor" id="autotoc_md170"></a>
API (Channel/Slot interaction)</h3>
<pre class="fragment">struct aws_channel_slot_ref *aws_channel_slot_new (struct aws_channel *channel);
</pre><p> Creates a new slot using the channel's allocator, if it is the first slot in the channel, it will be added as the first slot in the channel. Otherwise, you'll need to use the insert or replace APIs for slots. </p><pre class="fragment">int aws_channel_slot_set_handler ( struct aws_channel_slot *, struct aws_channel_handler *handler );
</pre><p> Sets the handler on the slot. This should only be called once per slot. </p><pre class="fragment">int aws_channel_slot_remove (struct aws_channel_slot *slot);
</pre><p> Removes a slot from its channel. The slot and its handler will be cleaned up and deallocated. </p><pre class="fragment">int aws_channel_slot_replace (struct aws_channel_slot *remove, struct aws_channel_slot *new);
</pre><p> Replaces <code>remove</code> in the channel with <code>new</code> and cleans up and deallocates <code>remove</code> and its handler. </p><pre class="fragment">int aws_channel_slot_insert_right (struct aws_channel_slot *slot, struct aws_channel_slot_ref *right);
</pre><p> Adds a slot to the right of slot. </p><pre class="fragment">int aws_channel_slot_insert_left (struct aws_channel_slot *slot, struct aws_channel_slot_ref *left);
</pre><p> Adds a slot to the left of slot. </p><pre class="fragment">int aws_channel_slot_send_message (struct aws_channel_slot *slot, struct aws_io_message *message, enum aws_channel_direction dir);
</pre><p> Usually called by a handler, this calls the adjacent slot in the channel based on the <code>dir</code> argument. You may want to return any unneeded messages to the channel pool to avoid unnecessary allocations. </p><pre class="fragment">int aws_channel_slot_increment_read_window (struct aws_channel_slot *slot, size_t window);
</pre><p> Usually called by a handler, this function calls the left-adjacent slot. </p><pre class="fragment">int aws_channel_slot_on_handler_shutdown_complete(struct aws_channel_slot *slot, enum aws_channel_direction dir,
                                                              int err_code, bool abort_immediately);
</pre><p> Usually called by a handler, this function calls the adjacent slot's shutdown based on the <code>dir</code> argument.</p>
<h2><a class="anchor" id="autotoc_md171"></a>
API (Channel specific)</h2>
<pre class="fragment">int aws_channel_init (struct aws_channel *channel, struct aws_allocator *alloc, struct aws_event_loop *el);
</pre><p> Initializes a channel for operation. The event loop will be used for driving the channel. </p><pre class="fragment">int aws_channel_clean_up (struct aws_channel *channel);
</pre><p> Cleans up resources for the channel. </p><pre class="fragment">int aws_channel_shutdown (struct aws_channel *channel,
    void (*on_shutdown_completed)(struct aws_channel *channel, void *user_data), void *user_data);
</pre><p> Starts the shutdown process, invokes on_shutdown_completed once each handler has shutdown. </p><pre class="fragment">int aws_channel_current_clock_time( struct aws_channel *, uint64_t *ticks);
</pre><p> Gets the current ticks from the event loop's clock. </p><pre class="fragment">int aws_channel_fetch_local_object ( struct aws_channel *, void *key, void **item);
</pre><p> Fetches data from the event loop's data store. This data is shared by each channel using that event loop. </p><pre class="fragment">int aws_channel_put_local_object ( struct aws_channel *, void *key, void *item);
</pre><p> Puts data into the event loop's data store. This data is shared by each channel using that event loop. </p><pre class="fragment">int aws_channel_schedule_task (struct aws_channel *, struct aws_task *task, uint64_t run_at);
</pre><p> Schedules a task to run on the event loop. This function is thread-safe. </p><pre class="fragment">BOOL aws_channel_thread_is_callers_thread (struct aws_channel *);
</pre><p> Checks if the caller is on the event loop's thread. This function is thread-safe.</p>
<h2><a class="anchor" id="autotoc_md172"></a>
Channel Handlers</h2>
<p >Channel Handlers are runtime polymorphic. Here's some details on the virtual table (v-table):</p>
<h3><a class="anchor" id="autotoc_md173"></a>
Layout</h3>
<p >struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> { struct <a class="el" href="structaws__channel__handler__vtable.html">aws_channel_handler_vtable</a> *vtable; struct aws_allocator *alloc; void *impl; };</p>
<h3><a class="anchor" id="autotoc_md174"></a>
V-Table</h3>
<p >struct <a class="el" href="structaws__channel__handler__vtable.html">aws_channel_handler_vtable</a> { int (*data_in) ( struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler, struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *slot, struct <a class="el" href="structaws__io__message.html">aws_io_message</a> *message ); int (*data_out) ( struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler, struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *slot, struct <a class="el" href="structaws__io__message.html">aws_io_message</a> *message ); int (*on_window_update) (struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler, struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *slot, size_t size) int (*on_shutdown_notify) (struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler, struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *slot, enum aws_channel_direction dir, int error_code); int (*shutdown_direction) (struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler, struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *slot, enum aws_channel_direction dir); size_t (*initial_window_size) (struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler); void (*destroy)(struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler); };</p>
<p ><code>int data_in ( struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler, struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *slot, struct <a class="el" href="structaws__io__message.html">aws_io_message</a> *message)</code></p>
<p >Data in is invoked by the slot when an application level message is received in the read direction (from the io). The job of the implementer is to process the data in msg and either notify a user or queue a new message on the slot's read queue.</p>
<p ><code>int data_out (struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler, struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *slot, struct <a class="el" href="structaws__io__message.html">aws_io_message</a> *message)</code></p>
<p >Data Out is invoked by the slot when an application level message is received in the write direction (to the io). The job of the implementer is to process the data in msg and either notify a user or queue a new message on the slot's write queue.</p>
<p ><code>int increment_window (struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler, struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *slot, size_t size)</code></p>
<p >Increment Window is invoked by the slot when a framework level message is received from a downstream handler. It only applies in the read direction. This gives the handler a chance to make a programmatic decision about what its read window should be. Upon receiving an update_window message, a handler decides what its window should be and likely issues an increment window message to its slot. Shrinking a window has no effect. If a handler makes its window larger than a downstream window, it is responsible for honoring the downstream window and buffering any data it produces that is greater than that window.</p>
<p ><code>int (*shutdown) (struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler, struct <a class="el" href="structaws__channel__slot.html">aws_channel_slot</a> *slot, enum aws_channel_direction dir, int error_code, bool abort_immediately);</code></p>
<p >Shutdown is invoked by the slot when a framework level message is received from an adjacent handler. This notifies the handler that the previous handler in the chain has shutdown and will no longer be sending or receiving messages. The handler should make a decision about what it wants to do in response, and likely begins its shutdown process (if any). Once the handler has safely reached a safe state, if should call 'aws_channel_slot_on_handler_shutdown_complete'</p>
<p ><code>size_t initial_window_size (struct <a class="el" href="structaws__channel__handler.html">aws_channel_handler</a> *handler)</code></p>
<p >When a handler is added to a slot, the slot will call this function to determine the initial window size and will propagate a window_update message down the channel.</p>
<p ><code>void destroy(struct aws_channel_handler *handler)</code></p>
<p >Clean up any memory or resources owned by this handler, and then deallocate the handler itself.</p>
<h3><a class="anchor" id="autotoc_md175"></a>
API</h3>
<p >All exported functions, simply shim into the v-table and return.</p>
<h2><a class="anchor" id="autotoc_md176"></a>
Sockets</h2>
<p >We include a cross-platform API for sockets. We support TCP and UDP using IPv4 and IPv6, and Unix Domain sockets. On Windows, we use Named Pipes to support the functionality of Unix Domain sockets. On Windows, this is implemented with winsock2, and on all unix platforms we use the posix API.</p>
<p >Upon a connection being established, the new socket (either as the result of a <code>connect()</code> or <code>start_accept()</code> call) will not be attached to any event loops. It is your responsibility to register it with an event loop to begin receiving notifications.</p>
<h3><a class="anchor" id="autotoc_md177"></a>
API</h3>
<p >typedef enum aws_socket_domain { AWS_SOCKET_IPV4, AWS_SOCKET_IPV6, AWS_SOCKET_LOCAL, AWS_SOCKET_VSOCK, } aws_socket_domain;</p>
<p ><code>AWS_SOCKET_IPV4</code> means an IPv4 address will be used.</p>
<p ><code>AWS_SOCKET_IPV6</code> means an IPv6 address will be used.</p>
<p ><code>AWS_SOCKET_LOCAL</code> means a socket path will be used for either a Unix Domain Socket or a Named Pipe on Windows. </p><pre class="fragment">typedef enum aws_socket_type {
    AWS_SOCKET_STREAM,
    AWS_SOCKET_DGRAM
} aws_socket_type;
</pre><p> <code>AWS_SOCKET_VSOCK</code> means a CID address will be used. Note: VSOCK is currently only available on Linux with an appropriate VSOCK kernel driver installed. <code>-DUSE_VSOCK</code> needs to be passed during compilation to enable VSOCK support.</p>
<p ><code>AWS_SOCKET_STREAM</code> is TCP or a connection oriented socket.</p>
<p ><code>AWS_SOCKET_DGRAM</code> is UDP </p><pre class="fragment">struct aws_socket_creation_args {
    void(*on_incoming_connection)(struct aws_socket *socket, struct aws_socket *new_socket, void *user_data);
    void(*on_connection_established)(struct aws_socket *socket, void *user_data);
    void(*on_error)(struct aws_socket *socket, int err_code, void *user_data);
    void *user_data;
};
</pre><p> <code>on_incoming_connection()</code> will be invoked on a listening socket when new connections arrive. <code>socket</code> is the listening socket. <code>new_socket</code> is the newly created socket. It is the connection to the remote endpoint.</p>
<p >NOTE: You are responsible for calling <code><a class="el" href="socket_8h.html#ac68f282d5ab2ae4a70f0673d572c4b39">aws_socket_clean_up()</a></code> and <code>aws_mem_release()</code> on <code>new_socket</code> when you are finished with it.</p>
<p ><code>on_connection_established()</code> will be invoked after a connect call, upon a successful connection to the remote endpoint.</p>
<p ><code>on_error()</code> will be invoked on both listening and connecting sockets to indicate any error conditions. </p><pre class="fragment">struct aws_socket_endpoint {
    char address[48];
    char socket_name[108];
    char port[10];
};
</pre><p> <code>address</code> can be either an IPv4, IPv6 or VSOCK CID address. This can be used for UDP or TCP. <code>socket_name</code> is only used in LOCAL mode. <code>port</code> can be used for TCP or UDP. </p><pre class="fragment">int aws_socket_init(struct aws_socket *socket, struct aws_allocator *alloc,
                                    struct aws_socket_options *options,
                                    struct aws_event_loop *connection_loop,
                                    struct aws_socket_creation_args *creation_args);
</pre><p> Initializes a socket object with socket options, an event loop to use for non-blocking operations, and callbacks to invoke upon completion of asynchronous operations. If you are using UDP or LOCAL, <code>connection_loop</code> may be <code>NULL</code>. </p><pre class="fragment">void aws_socket_clean_up(struct aws_socket *socket);
</pre><p> Shuts down any pending operations on the socket, and cleans up state. The socket object can be re initialized after this operation. </p><pre class="fragment">int aws_socket_connect(struct aws_socket *socket, struct aws_socket_endpoint *remote_endpoint);
</pre><p> Connects to a remote endpoint. In UDP, this simply binds the socket to a remote address for use with <code><a class="el" href="socket_8h.html#af6dc1df5c6676afc9339d3d3f1f61ecb">aws_socket_write()</a></code>, and if the operation is successful, the socket can immediately be used for write operations.</p>
<p >In TCP, this will function will not block. If the return value is successful, then you must wait on the <code>on_connection_established()</code> callback to be invoked before using the socket.</p>
<p >For LOCAL (Unix Domain Sockets or Named Pipes), the socket will be immediately ready for use upon a successful return. </p><pre class="fragment">int aws_socket_bind(struct aws_socket *socket, struct aws_socket_endpoint *local_endpoint);
</pre><p> Binds the socket to a local address. In UDP mode, the socket is ready for <code><a class="el" href="socket_8h.html#a96805e90039531f8c2d36dcc04f21404">aws_socket_read()</a></code> operations. In connection oriented modes, you still must call <code><a class="el" href="socket_8h.html#a52c612d76a40580b72d627ca4e62fb64">aws_socket_listen()</a></code> and <code><a class="el" href="socket_8h.html#a796b04c08548fc2654136365cf3642b6">aws_socket_start_accept()</a></code> before using the socket. </p><pre class="fragment">int aws_socket_listen(struct aws_socket *socket, int backlog_size);
</pre><p> TCP and LOCAL only. Sets up the socket to listen on the address bound to in <code><a class="el" href="socket_8h.html#a24930918606789bae1d07115ec644701">aws_socket_bind()</a></code>. </p><pre class="fragment">int aws_socket_start_accept(struct aws_socket *socket);
</pre><p> TCP and LOCAL only. The socket will begin accepting new connections. This is an asynchronous operation. New connections will arrive via the <code>on_incoming_connection()</code> callback. </p><pre class="fragment">int aws_socket_stop_accept(struct aws_socket *socket);
</pre><p> TCP and LOCAL only. The socket will shutdown the listener. It is safe to call <code><a class="el" href="socket_8h.html#a796b04c08548fc2654136365cf3642b6">aws_socket_start_accept()</a></code> again after this operation. </p><pre class="fragment">int aws_socket_close(struct aws_socket *socket);
</pre><p> Calls <code>close()</code> on the socket and unregisters all io operations from the event loop. </p><pre class="fragment">struct aws_io_handle *aws_socket_get_io_handle(struct aws_socket *socket);
</pre><p> Fetches the underlying io handle for use in event loop registrations and channel handlers. </p><pre class="fragment">int aws_socket_set_options(struct aws_socket *socket, struct aws_socket_options *options);
</pre><p> Sets new socket options on the underlying socket. This is mainly useful in context of accepting a new connection via: <code>on_incoming_connection()</code>. </p><pre class="fragment">int aws_socket_read(struct aws_socket *socket, struct aws_byte_buf *buffer, size_t *amount_read);
</pre><p> Reads from the socket. This call is non-blocking and will return <code>AWS_IO_SOCKET_READ_WOULD_BLOCK</code> if no data is available. <code>amount_read</code> is the amount of data read into <code>buffer</code>. </p><pre class="fragment">int aws_socket_write(struct aws_socket *socket, const struct aws_byte_buf *buffer, size_t *written);
</pre><p> Writes to the socket. This call is non-blocking and will return <code>AWS_IO_SOCKET_WRITE_WOULD_BLOCK</code> if no data could be written. <code>written</code> is the amount of data read from <code>buffer</code> and successfully written to <code>socket</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
