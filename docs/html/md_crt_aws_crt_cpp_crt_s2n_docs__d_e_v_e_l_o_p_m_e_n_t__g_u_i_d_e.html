<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AWS IoT Device SDK C++ v2: Development guide for s2n</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AWS IoT Device SDK C++ v2<span id="projectnumber">&#160;1.14.0</span>
   </div>
   <div id="projectbrief">AWS IoT Device SDK C++ v2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Development guide for s2n </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >If you are curious about the internals of s2n, or interested in contributing to s2n, this document is for you. If instead you are interested in using s2n in an application that you are developing, please see the accompanying <a href="https://github.com/awslabs/s2n/blob/main/docs/USAGE-GUIDE.md">Usage Guide</a>.</p>
<h1><a class="anchor" id="autotoc_md321"></a>
s2n's development principles</h1>
<p >Before getting into the detail of how s2n works internally, it's worth covering s2n's development principles. These principles guide and inform many of the design decisions we'll go through. We're always open to new principles, if you can think of better ones and make a case for them.</p>
<h3><a class="anchor" id="autotoc_md322"></a>
Development principles</h3>
<ul>
<li><b>Maintain an excellent TLS/SSL implementation</b><br  />
Although it's hidden "*under the hood*", TLS/SSL is the direct interface with customers and end-users. Good performance and security are critical to a positive experience.</li>
<li><b>Protect user data and keys</b><br  />
Above all else, s2n must ensure that user data and private keys are being handled correctly and carefully. Security is often a matter of trade-offs and costs; we should always strive to increase the costs for attackers whenever the tradeoffs are acceptable to users.</li>
<li><b>Stay simple</b><br  />
Write as little code as necessary, omit rarely used optional features and support as few modes of operation as possible. We will also promote and encourage changes that reduce the size of our code base.</li>
<li><b>Write clear readable code with a light cognitive load</b><br  />
s2n's code must be concise, easy to follow and legible to a proficient C programmer. Our code should be organized in a way that divides the implementation up into small units of work, with the entire context necessary at hand. We should also minimize the number of branches in our code, the depth of our call stacks, and the number of members in our structures.</li>
<li><b>Defend in depth and systematically</b><br  />
Great care and attention to detail is required to write good code, but we also use automation and mechanistic processes to protect against human error.</li>
<li><b>Be easy to use and maintain sane defaults</b><br  />
It should be low effort, even for a novice developer, to use s2n in a safe way. We also shouldn't "*pass the buck*" and place the burden of subtle or complicated TLS-specific decision making upon application authors and system administrators.</li>
<li><b>Provide great performance and responsiveness</b><br  />
TLS/SSL is rapidly becoming ubiquitous. Even small inefficiencies and overhead can become significant when multiplied by billions of users and quintillions of sessions.</li>
<li><b>Stay paranoid</b><br  />
s2n operates in a security critical space. Even with the most precautionary development methods it is impossible to guarantee the absence of defects. A subtle one-byte error on a single line may still cause problems.</li>
<li><b>Make data-driven decisions</b><br  />
Opinions can differ on security best practices, sometimes in contradictory ways. Where possible, we are guided by facts and measurable data.</li>
</ul>
<h3><a class="anchor" id="autotoc_md323"></a>
Priorities</h3>
<p >When weighing up difficult implementation trade-offs our ordered set of priorities are:</p>
<ol type="1">
<li>Security</li>
<li>Readability</li>
<li>Ease of use</li>
<li>Performance.</li>
</ol>
<h3><a class="anchor" id="autotoc_md324"></a>
Commit and code-review policy</h3>
<p >s2n is review-then-commit for code changes, and commit-then-review for documentation changes. Code additions are made by pull requests, no author may merge their own pull request on code. Changes to documentation, including code comments, may be made more freely.</p>
<h1><a class="anchor" id="autotoc_md325"></a>
Coding style and conventions</h1>
<p >Per our development principles, an important goal is to reduce the cognitive load required to read, review and extend s2n. Although s2n is written in C, s2n adopts several patterns more common to functional programming. Though they are used in a way that is idiomatic and shouldn't feel completely alien in C.</p>
<h2><a class="anchor" id="autotoc_md326"></a>
High level function design</h2>
<p >The first convention is that's s2n's functions are generally quite small, no more than a page or two at most and commonly just a few lines. Functions have a clear input and output and are in that sense "pure" functions; for example handling a particular TLS handshake message type takes the message as input, and the output is connection state.</p>
<div class="fragment"><div class="line"><span class="comment">/* An idiomatic s2n function generally has:</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  An s2n_result return value. This is used to signal success or error.</span></div>
<div class="line"><span class="comment"> *  An input, often a struct.</span></div>
<div class="line"><span class="comment"> *  An output, often a struct.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">S2N_RESULT s2n_do_something(<span class="keyword">struct</span> *some_input, <span class="keyword">struct</span> *some_output);</div>
</div><!-- fragment --><p >s2n functions also operate in a message passing style. For example, a simplified version of the flow when handling a TLS client finished message might looks like this:</p>
<p ><img src="images/s2n_lambda.png" alt="s2n message passing" title="s2n message passing" class="inline"/></p>
<p >each function handles a clear, well-defined piece of work, before passing on responsibility to the next function.</p>
<p >The second convention of s2n's functions is that functions are split into two kinds: those that handle control flow and coordinate other functions, and those that parse messages. For example, in the above diagram, it might appear that the functions are calling each other directly but we try to avoid that. Instead there is a coordinating outer function responsible for the flow control.</p>
<p >A simplified version of the coordinating function would resemble:</p>
<div class="fragment"><div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8c.html#a49bb9749c055c6fb6f713cebeaa14cb5">s2n_stuffer_read</a>(connection, input_stuffer));</div>
<div class="line">GUARD(s2n_cbc_aes_decrypt(input_stuffer, output_stuffer));</div>
<div class="line">GUARD(s2n_cbc_verify(output_stuffer));</div>
<div class="ttc" id="as2n__stuffer_8c_html_a49bb9749c055c6fb6f713cebeaa14cb5"><div class="ttname"><a href="s2n__stuffer_8c.html#a49bb9749c055c6fb6f713cebeaa14cb5">s2n_stuffer_read</a></div><div class="ttdeci">int s2n_stuffer_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer.c:228</div></div>
</div><!-- fragment --><p >Splitting things up this way leads to a shallower call stack, but the main benefit is that functions can read quite declaratively. In the case of message parsers, the function contents can read almost like schemas of the message being parsed.</p>
<p >A good example file for message parsing to look at is <a href="https://github.com/awslabs/s2n/blob/main/tls/s2n_server_finished.c">tls/s2n_server_finished.c</a>. From reading the file it should be reasonably clear that a server finished message consists just of S2N_TLS_FINISHED_LEN number of bytes, what the next state is and so on.</p>
<p >As you may also see in that file, the functions for reading and writing a particular message type are in the same file. That way all of context and logic needed to handle that message type can be reviewed and thought about in one place.</p>
<h2><a class="anchor" id="autotoc_md327"></a>
Error handling and Macros</h2>
<p >As may also be clear from the above examples, s2n has some conventions for how errors are handled. Firstly, s2n functions should always return <code>S2N_RESULT_ERROR</code> or <code>NULL</code> on error, and <code>S2N_RESULT_OK</code> or a valid pointer on success. s2n also includes a thread local variable: s2n_errno, for indicating the cause of the error. This follows the convention set by libc (with errno), getaddrinfo (gai_errno), net-snmp (snmp_errno), and countless other libraries.</p>
<p >In s2n, we <b>always</b> check return values. Because of that, the coding pattern:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (s2n_result_is_error(s2n_do_something(with_something_else))) {</div>
<div class="line">    <span class="keywordflow">return</span> S2N_RESULT_ERROR;</div>
<div class="line">}</div>
</div><!-- fragment --><p >is so common that <a href="https://github.com/awslabs/s2n/blob/main/utils/s2n_safety.h">utils/s2n_safety.h</a> provides several macros for working with fallible functions. Notable macros include;</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#define GUARD( x ) ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define GUARD_PTR( x ) ...</span></div>
</div><!-- fragment --><p >These macros should be used when calling functions you expect to succeed. Primarily these macros help save two lines that repeatedly clutter files, and secondarily they are very useful when developing and debugging code as it is easy to redefine the macro to implement a simple backtrace (even a simple printf will suffice, but a breakpoint is more usual).</p>
<p >If a function does fail, it should use the <code>BAIL(errno)</code> macro provided for surfacing the error to an application. New error translations, and their human-readable translations can be defined in <a href="https://github.com/awslabs/s2n/blob/main/error/s2n_errno.h">error/s2n_errno.h</a> and <a href="https://github.com/awslabs/s2n/blob/main/error/s2n_errno.c">error/s2n_errno.c</a>. When called, e.g.:</p>
<div class="fragment"><div class="line">BAIL(<a class="code hl_enumvalue" href="s2n__errno_8h.html#a64ed9ec59a957387654c5e5865325374ad61ca0bcc8f9f8bf3e065de30ad547fb">S2N_ERR_BAD_MESSAGE</a>);</div>
<div class="ttc" id="as2n__errno_8h_html_a64ed9ec59a957387654c5e5865325374ad61ca0bcc8f9f8bf3e065de30ad547fb"><div class="ttname"><a href="s2n__errno_8h.html#a64ed9ec59a957387654c5e5865325374ad61ca0bcc8f9f8bf3e065de30ad547fb">S2N_ERR_BAD_MESSAGE</a></div><div class="ttdeci">@ S2N_ERR_BAD_MESSAGE</div><div class="ttdef"><b>Definition:</b> s2n_errno.h:68</div></div>
</div><!-- fragment --><p >the macro will set s2n_errno correctly, as well as some useful debug strings, and return <code>S2N_RESULT_ERROR</code>.</p>
<h2><a class="anchor" id="autotoc_md328"></a>
Safety checking</h2>
<p ><a href="https://github.com/awslabs/s2n/blob/main/utils/s2n_safety.h">utils/s2n_safety.h</a> provides several more convenience macros intended to make safety and bounds checking easier. There are checked versions of memcpy (<code>CHECKED_MEMCPY</code>) and memset (<code>CHECKED_MEMSET</code>), as well as predicate testers like <code>ENSURE</code>, <code>ENSURE_GTE</code>, <code>ENSURE_INCLUSIVE_RANGE</code>, <code>ENSURE_EXCLUSIVE_RANGE</code> for performing simple comparisons in a systematic, error-handled, way.</p>
<p ><em>Note</em>: In general, C preprocessor Macros with embedded control flow are a bad idea, but <code>GUARD</code>, <code>ENSURE</code>, and <code>BAIL</code> are so thoroughly used throughout s2n that it should be a clear and idiomatic pattern, almost forming a small domain specific language.</p>
<h2><a class="anchor" id="autotoc_md329"></a>
Cleanup on Error</h2>
<p >As discussed below, s2n rarely allocates resources, and so has nothing to clean up on error. For cases where functions do allocate resources which must be cleaned up, s2n offers two macros:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#define GUARD_GOTO( x , label ) ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define DEFER_CLEANUP(_thealloc, _thecleanup) ...</span></div>
</div><!-- fragment --><p ><code>GUARD_GOTO( x , label )</code> does traditional "goto" style cleanup: if the function <code>x</code> returns an error, control is transfered to label <code>label</code>. It is the responsibility of the code at <code>label</code> to cleanup any resources, and then return <code>S2N_RESULT_ERROR</code>.</p>
<p ><code>DEFER_CLEANUP(_thealloc, _thecleanup)</code> is a more failsafe way of ensuring that resources are cleaned up, using the <code>__attribute__((cleanup())</code> destructor mechanism available in modern C compilers. When the variable declared in <code>_thealloc</code> goes out of scope, the cleanup function <code>_thecleanup</code> is automatically called. This guarantees that resources will be cleaned up, no matter how the function exits.</p>
<h2><a class="anchor" id="autotoc_md330"></a>
Control flow and the state machine</h2>
<p >Branches can be a source of cognitive load, as they ask the reader to follow a path of thinking, while also remembering that there is another path to be explored. When branches are nested, they can often lead to impossible to grasp combinatorial explosions. s2n tries to systematically reduce the number of branches used in the code in several ways.</p>
<p >Firstly, there are almost no ifdef calls in s2n. Ifdefs can be a particularly penalizing source of cognitive load. In addition to being a branch, they also ask the reader to mix state from two different languages (C, and the C preprocessor) and they tend to be associated with ugly rendering in IDEs and code formatters. In the few places where ifdef's are necessary, we use them in a careful way without compromising the integrity of the function. <a href="https://github.com/awslabs/s2n/blob/main/tls/s2n_config.c">tls/s2n_config.c</a> is a good example. Rather than mixing the Apple and non-Apple implementations and cluttering one function with several ifdefs, there is a complete implementation of the timer functionality for each platform. Within the POSIX implementation, an ifdef and define are used to use the most precise clock type, but in a way that does not compromise readability.</p>
<p >Secondly, s2n generally branches in the case of failure, rather than success. So instead of creating a nest of if's:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (s2n_foo() == 0) {</div>
<div class="line">    <span class="keywordflow">if</span> (s2n_bar() == 0) {</div>
<div class="line">         <span class="keywordflow">if</span> (s2n_baz() == 0) {</div>
</div><!-- fragment --><p >we do:</p>
<div class="fragment"><div class="line">GUARD(s2n_foo());</div>
<div class="line">GUARD(s2n_bar());</div>
<div class="line">GUARD(s2n_baz());</div>
</div><!-- fragment --><p >This pattern leads to a linear control flow, where the main body of a function describes everything that happens in a regular, "*happy*" case. Any deviation is usually a fatal error and we exit the function. This is safe because s2n rarely allocates resources, and so has nothing to clean up on error.</p>
<p >This pattern also leads to extremely few "else" clauses in the s2n code base. Within s2n, else clauses should be treated with suspicion and examined for potential eradication. Where an else clause is necessary, we try to ensure that the first if block is the most likely case. This aids readability, and also results in a more efficient compiled instruction pipeline (although good CPU branch prediction will rapidly correct any mis-ordering).</p>
<p >For branches on small enumerated types, s2n generally favors switch statements: though switch statements taking up more than about 25 lines of code are discouraged, and a "default:" block is mandatory.</p>
<p >Another technique for complexity avoidance is that the core TLS state machine within s2n does not use branches and instead uses a table of function pointers (another technique borrowed from functional programming) to dispatch data to the correct handler. This is covered in more detail later in this document.</p>
<p >Lastly, s2n studiously avoids locks. s2n is designed to be thread-safe, but does so by using atomic data types in the small number of well-isolated variables that may be accessed by multiple threads.</p>
<h2><a class="anchor" id="autotoc_md331"></a>
Code formatting and commenting</h2>
<p >s2n is written in C99. The code formatting and indentation should be relatively clear from reading some s2n source files, but there is also an automated "make indent" target that will indent the s2n sources.</p>
<p >There should be no need for comments to explain <em>what</em> s2n code is doing; variables and functions should be given clear and human-readable names that make their purpose and intent intuitive. Comments explaining <em>why</em> we are doing something are encouraged. Often some context setting is necessary; a reference to an RFC, or a reminder of some critical state that is hard to work directly into the immediate code in a natural way. All comments should be written using C syntax <code>/* */</code> and <b>avoid</b> C++ comments <code>//</code> even though C99 compilers allow <code>//</code>.</p>
<p >Every source code file must include a copy of the Apache Software License 2.0, as well as a correct copyright notification. The year of copyright should be the year in which the file was first created.</p>
<p >There is also a brief set of other coding conventions:</p>
<ul>
<li>s2n uses explicitly sized primitives where possible. E.g. uint8_t, uint32_t.</li>
<li>In general, s2n uses unsigned ints for sizes, as TLS/SSL do the same.</li>
<li>Any structures exposed to application authors must be opaque: s2n manages the memory allocation and de-allocation.</li>
<li>Variables are declared closest to their first point of use, to maximize context around the typing.</li>
<li>Duplication of logic is discouraged</li>
<li>4 spaces, no tabs</li>
<li>Assuming a terminal that is 120 characters wide is ok</li>
</ul>
<h1><a class="anchor" id="autotoc_md332"></a>
Tests</h1>
<p >s2n is written in C99, a language which lacks a "standard" testing framework. Although there are some more well used C++ testing frameworks, s2n also targets some embedded platforms on which a C++ compiler is unavailable.</p>
<p >Since testing and test-cases are absolutely mandatory for all s2n functionality, s2n includes its own small testing framework, defined in <a href="https://github.com/awslabs/s2n/blob/main/tests/s2n_test.h">tests/s2n_test.h</a>. The framework consists of 15 macros that allow you to start a test suite, which is a normal C application with a <a class="el" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a> function, and to validate various expectations.</p>
<p >Unit tests are added as .c files in <a href="https://github.com/awslabs/s2n/blob/main/tests/unit/">tests/unit/</a>. A simple example to look at is <a href="https://github.com/awslabs/s2n/blob/main/tests/unit/s2n_stuffer_base64_test.c">tests/unit/s2n_stuffer_base64_test.c</a>. The tests are started with BEGIN_TEST(), and expectations are tested with EXPECT_SUCCESS and EXPECT_EQUAL before exiting with an END_TEST call.</p>
<p >The test framework will take care of compiling and executing the tests and indicates success or failure with green or red text in the console.</p>
<p >In addition to fully covering functionality in the correct cases, s2n tests are also expected to include adversarial or "negative" test cases. For example, the tests performed on record encryption validate that s2n is tamper resistant by attempting to actually tamper with records. Similarly, we validate that our memory handling routines cannot be over-filled by attempting to over-fill them.</p>
<p >To avoid adding unneeded code to the production build of s2n, there is also a small test library defined at <a href="https://github.com/awslabs/s2n/blob/main/tests/testlib/">tests/testlib/</a> which includes routines useful for test cases. For example, there is a hex parser and emitter, which is useful for defining network data in test cases, but not needed in production.</p>
<p >Unit tests are run automatically with <code>make</code>. To run a subset of the unit tests, set the <code>UNIT_TESTS</code> environment variable with the unit test name(s). For example: </p><div class="fragment"><div class="line">UNIT_TESTS=s2n_hash_test make</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md333"></a>
A tour of s2n memory handling: blobs and stuffers</h1>
<p >C has a history of issues around memory and buffer handling. To avoid problems in this area, s2n does not use C string functions or standard buffer manipulation patterns. Instead memory regions are tracked explicitly, with <code>s2n_blob</code> structures, and buffers are re-oriented as streams with <code><a class="el" href="structs2n__stuffer.html">s2n_stuffer</a></code> structures.</p>
<h2><a class="anchor" id="autotoc_md334"></a>
s2n_blob: keeping track of memory ranges</h2>
<p ><code>s2n_blob</code> is a very simple data structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>s2n_blob {</div>
<div class="line">    uint8_t *data;</div>
<div class="line">    uint32_t size;</div>
<div class="line">};</div>
</div><!-- fragment --><p >Functions that handle memory ranges are expected to at least use blobs (stuffers are better though, as we'll see). A blob can be initialized with an existing memory buffer using <b>s2n_blob_init</b>, but <a href="https://github.com/awslabs/s2n/blob/main/utils/s2n_mem.h">utils/s2n_mem.h</a> also defines routines for dynamically allocated blobs. For handling user data, we prefer the latter, as s2n prevents the memory regions from being swapped to disk and from showing up in core files (where supported).</p>
<h2><a class="anchor" id="autotoc_md335"></a>
s2n_stuffer: a streaming buffer</h2>
<p >The stuffer data structure included in s2n is intended to handle all protocol level input and output to memory buffers and is the real work-horse of s2n. At its core a stuffer is a blob and two cursors:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> {</div>
<div class="line">    <span class="keyword">struct </span>s2n_blob <a class="code hl_variable" href="structs2n__stuffer.html#ae2b2cf5412753a87948fc76397194787">blob</a>;</div>
<div class="line">    uint32_t <a class="code hl_variable" href="structs2n__stuffer.html#a6e567dc7b55d140923805f6210906f17">read_cursor</a>;</div>
<div class="line">    uint32_t <a class="code hl_variable" href="structs2n__stuffer.html#ac06359a7a34ae1554bda854aa1e08af0">write_cursor</a>;</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="ttc" id="astructs2n__stuffer_html"><div class="ttname"><a href="structs2n__stuffer.html">s2n_stuffer</a></div><div class="ttdef"><b>Definition:</b> s2n_stuffer.h:37</div></div>
<div class="ttc" id="astructs2n__stuffer_html_a6e567dc7b55d140923805f6210906f17"><div class="ttname"><a href="structs2n__stuffer.html#a6e567dc7b55d140923805f6210906f17">s2n_stuffer::read_cursor</a></div><div class="ttdeci">uint32_t read_cursor</div><div class="ttdef"><b>Definition:</b> s2n_stuffer.h:42</div></div>
<div class="ttc" id="astructs2n__stuffer_html_ac06359a7a34ae1554bda854aa1e08af0"><div class="ttname"><a href="structs2n__stuffer.html#ac06359a7a34ae1554bda854aa1e08af0">s2n_stuffer::write_cursor</a></div><div class="ttdeci">uint32_t write_cursor</div><div class="ttdef"><b>Definition:</b> s2n_stuffer.h:43</div></div>
<div class="ttc" id="astructs2n__stuffer_html_ae2b2cf5412753a87948fc76397194787"><div class="ttname"><a href="structs2n__stuffer.html#ae2b2cf5412753a87948fc76397194787">s2n_stuffer::blob</a></div><div class="ttdeci">struct s2n_blob blob</div><div class="ttdef"><b>Definition:</b> s2n_stuffer.h:39</div></div>
</div><!-- fragment --><p >This layout that makes it possible to implement a stream:</p>
<p ><img src="images/s2n_stuffer_layout.png" alt="Stuffer layout" title="s2n stuffer internal layout" class="inline"/></p>
<p >All access to/from the stuffer goes "through" s2n_stuffer_ functions. For example, we can write with <b><a class="el" href="s2n__stuffer_8c.html#ad77ea23089bbeb19b897a73bf6ca3fde">s2n_stuffer_write()</a></b>, and when we do the write cursor is incremented to the new position. We can read with <b><a class="el" href="s2n__stuffer_8c.html#a49bb9749c055c6fb6f713cebeaa14cb5">s2n_stuffer_read()</a></b>, and of course we can only read data as far as the write cursor (which is always at or ahead of the read cursor). To protect user data, when we read data out of the stuffer, we wipe the copy of the data within the local stuffer memory. We also ensure that it's only possible to read as much data as is in the stuffer.</p>
<p >A stuffer can be initialized directly from a blob, which makes it fixed in size, or it can be allocated dynamically. In the latter case, we can also choose to make the stuffer growable (by using <b>s2n_stuffer_growable_alloc</b> instead of <b>s2n_stuffer_alloc</b>). If a stuffer is growable then attempting to write past the end of the current blob will result in the blob being extended (by at least 1K at a time) to fit the data.</p>
<p >To further encourage stream-oriented programming, the stuffer is also the place where all marshaling and de-marshaling happens. For example, you can read and write ints directly to a stuffer:</p>
<div class="fragment"><div class="line"><span class="comment">/* Read and write integers in network order */</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#a1178687b6091eb483d135c149e87fb0b">s2n_stuffer_read_uint8</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint8_t *u);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#a788c22abe22da96107393257193632c5">s2n_stuffer_read_uint16</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint16_t *u);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#a71787bb6eeba3413137cde42d32a0f6c">s2n_stuffer_read_uint24</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint32_t *u);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#a7cf35b0d626c422e4fa414bda44f51bb">s2n_stuffer_read_uint32</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint32_t *u);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#ae1122959189bd03c92af5fd134016977">s2n_stuffer_read_uint64</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint64_t *u);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#aaca63d5bb519a92734bd0287199a7f5a">s2n_stuffer_write_uint8</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint8_t u);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#a9d9c55b0847a8ae81b6379971a13f27f">s2n_stuffer_write_uint16</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint16_t u);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#aa78701a9bb01def1efcbfa30ba0bdfc9">s2n_stuffer_write_uint24</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint32_t u);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#a958a82fb4dfe3517bcfd95f46807f715">s2n_stuffer_write_uint32</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint32_t u);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="s2n__stuffer_8h.html#af5be81568462bd6626c1d00a939ff30d">s2n_stuffer_write_uint64</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint64_t u);</div>
<div class="ttc" id="as2n__stuffer_8h_html_a1178687b6091eb483d135c149e87fb0b"><div class="ttname"><a href="s2n__stuffer_8h.html#a1178687b6091eb483d135c149e87fb0b">s2n_stuffer_read_uint8</a></div><div class="ttdeci">int s2n_stuffer_read_uint8(struct s2n_stuffer *stuffer, uint8_t *u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:52</div></div>
<div class="ttc" id="as2n__stuffer_8h_html_a71787bb6eeba3413137cde42d32a0f6c"><div class="ttname"><a href="s2n__stuffer_8h.html#a71787bb6eeba3413137cde42d32a0f6c">s2n_stuffer_read_uint24</a></div><div class="ttdeci">int s2n_stuffer_read_uint24(struct s2n_stuffer *stuffer, uint32_t *u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:89</div></div>
<div class="ttc" id="as2n__stuffer_8h_html_a788c22abe22da96107393257193632c5"><div class="ttname"><a href="s2n__stuffer_8h.html#a788c22abe22da96107393257193632c5">s2n_stuffer_read_uint16</a></div><div class="ttdeci">int s2n_stuffer_read_uint16(struct s2n_stuffer *stuffer, uint16_t *u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:66</div></div>
<div class="ttc" id="as2n__stuffer_8h_html_a7cf35b0d626c422e4fa414bda44f51bb"><div class="ttname"><a href="s2n__stuffer_8h.html#a7cf35b0d626c422e4fa414bda44f51bb">s2n_stuffer_read_uint32</a></div><div class="ttdeci">int s2n_stuffer_read_uint32(struct s2n_stuffer *stuffer, uint32_t *u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:113</div></div>
<div class="ttc" id="as2n__stuffer_8h_html_a958a82fb4dfe3517bcfd95f46807f715"><div class="ttname"><a href="s2n__stuffer_8h.html#a958a82fb4dfe3517bcfd95f46807f715">s2n_stuffer_write_uint32</a></div><div class="ttdeci">int s2n_stuffer_write_uint32(struct s2n_stuffer *stuffer, const uint32_t u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:128</div></div>
<div class="ttc" id="as2n__stuffer_8h_html_a9d9c55b0847a8ae81b6379971a13f27f"><div class="ttname"><a href="s2n__stuffer_8h.html#a9d9c55b0847a8ae81b6379971a13f27f">s2n_stuffer_write_uint16</a></div><div class="ttdeci">int s2n_stuffer_write_uint16(struct s2n_stuffer *stuffer, const uint16_t u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:79</div></div>
<div class="ttc" id="as2n__stuffer_8h_html_aa78701a9bb01def1efcbfa30ba0bdfc9"><div class="ttname"><a href="s2n__stuffer_8h.html#aa78701a9bb01def1efcbfa30ba0bdfc9">s2n_stuffer_write_uint24</a></div><div class="ttdeci">int s2n_stuffer_write_uint24(struct s2n_stuffer *stuffer, const uint32_t u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:103</div></div>
<div class="ttc" id="as2n__stuffer_8h_html_aaca63d5bb519a92734bd0287199a7f5a"><div class="ttname"><a href="s2n__stuffer_8h.html#aaca63d5bb519a92734bd0287199a7f5a">s2n_stuffer_write_uint8</a></div><div class="ttdeci">int s2n_stuffer_write_uint8(struct s2n_stuffer *stuffer, const uint8_t u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:59</div></div>
<div class="ttc" id="as2n__stuffer_8h_html_ae1122959189bd03c92af5fd134016977"><div class="ttname"><a href="s2n__stuffer_8h.html#ae1122959189bd03c92af5fd134016977">s2n_stuffer_read_uint64</a></div><div class="ttdeci">int s2n_stuffer_read_uint64(struct s2n_stuffer *stuffer, uint64_t *u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:133</div></div>
<div class="ttc" id="as2n__stuffer_8h_html_af5be81568462bd6626c1d00a939ff30d"><div class="ttname"><a href="s2n__stuffer_8h.html#af5be81568462bd6626c1d00a939ff30d">s2n_stuffer_write_uint64</a></div><div class="ttdeci">int s2n_stuffer_write_uint64(struct s2n_stuffer *stuffer, const uint64_t u)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer_network_order.c:152</div></div>
</div><!-- fragment --><p >and there are other utility functions for handling base64 encoding to and from a stuffer, or text manipulation - like tokenization. The idea is to implement basic serializing just once, rather than spread out and duplicated across the message parsers, and to maximize the declarative nature of the I/O. For example, this code parses a TLS record header:</p>
<div class="fragment"><div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8h.html#a1178687b6091eb483d135c149e87fb0b">s2n_stuffer_read_uint8</a>(in, &amp;message_type));</div>
<div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8h.html#a1178687b6091eb483d135c149e87fb0b">s2n_stuffer_read_uint8</a>(in, &amp;protocol_major_version));</div>
<div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8h.html#a1178687b6091eb483d135c149e87fb0b">s2n_stuffer_read_uint8</a>(in, &amp;protocol_minor_version));</div>
<div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8h.html#a788c22abe22da96107393257193632c5">s2n_stuffer_read_uint16</a>(in, &amp;record_size));</div>
</div><!-- fragment --><p >This pattern should make it very clear what the message format is, where the contents are being stored, and that we're handling things in a safe way.</p>
<p >There are times when we must interact with C functions from other libraries; for example, when handling encryption and decryption. In these cases, it is usually necessary to provide access to "raw" pointers into stuffers. s2n provides two functions for this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *<a class="code hl_function" href="s2n__stuffer_8c.html#afdc941db81df32f38b7800210f3f2d11">s2n_stuffer_raw_write</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint32_t data_len);</div>
<div class="line"><span class="keywordtype">void</span> *<a class="code hl_function" href="s2n__stuffer_8c.html#a5148294f6ed0bf894afc83a31ee4f8a5">s2n_stuffer_raw_read</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> *stuffer, uint32_t data_len);</div>
<div class="ttc" id="as2n__stuffer_8c_html_a5148294f6ed0bf894afc83a31ee4f8a5"><div class="ttname"><a href="s2n__stuffer_8c.html#a5148294f6ed0bf894afc83a31ee4f8a5">s2n_stuffer_raw_read</a></div><div class="ttdeci">void * s2n_stuffer_raw_read(struct s2n_stuffer *stuffer, uint32_t data_len)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer.c:219</div></div>
<div class="ttc" id="as2n__stuffer_8c_html_afdc941db81df32f38b7800210f3f2d11"><div class="ttname"><a href="s2n__stuffer_8c.html#afdc941db81df32f38b7800210f3f2d11">s2n_stuffer_raw_write</a></div><div class="ttdeci">void * s2n_stuffer_raw_write(struct s2n_stuffer *stuffer, const uint32_t data_len)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer.c:283</div></div>
</div><!-- fragment --><p >the first function returns a pointer to the existing location of the write cursor, and then increments the write cursor by <code>data_len</code>, so an external function is free to write to the pointer, as long as it only writes <code>data_len</code> bytes. The second function does the same thing, except that it increments the read cursor. Use of these functions is discouraged and should only be done when necessary for compatibility.</p>
<p >One problem with returning raw pointers is that a pointer can become stale if the stuffer is later resized. Growable stuffers are resized using realloc(), which is free to copy and re-address memory. This could leave the original pointer location dangling, potentially leading to an invalid access. To prevent this, stuffers have a life-cycle and can be tainted, which prevents them from being resized within their present life-cycle.</p>
<p >Internally stuffers track 4 pieces of state:</p>
<div class="fragment"><div class="line">uint32_t     high_water_mark;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> alloced:1;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> growable:1;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tainted:1;</div>
</div><!-- fragment --><p >The <code>high_water_mark</code> tracks the furthermost byte which has been written but not yet wiped. Note that this may be past the <code>write_cursor</code> if <code><a class="el" href="s2n__stuffer_8c.html#ae1b97eb16ae517a82ec90a0e2b8c48e7">s2n_stuffer_rewrite()</a></code> has been called. Explicitly tracking the <code>high_water_mark</code> allows us to track the bytes which need to be wiped, and helps avoids needless zeroing of memory. The next two bits of state track whether a stuffer was dynamically allocated (and so should be free'd later) and whether or not it is growable. <code>tainted</code> is set to 1 whenever the raw access functions are called. If a stuffer is currently tainted then it can not be resized and it becomes ungrowable. This is reset when a stuffer is explicitly wiped, which begins the life-cycle anew. So any pointers returned by the raw access functions are legal only until <code><a class="el" href="s2n__stuffer_8c.html#a2b6b54f7856d92f06f823bc26d10f4ba">s2n_stuffer_wipe()</a></code> is called. The end result is that this kind of pattern is legal:</p>
<div class="fragment"><div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8c.html#aba979c37cd169d15368bcdf473360073">s2n_stuffer_growable_alloc</a>(&amp;in, 1500));</div>
<div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8c.html#ad77ea23089bbeb19b897a73bf6ca3fde">s2n_stuffer_write</a>(&amp;in, &amp;fifteen_hundred_bytes_blob));</div>
<div class="line">uint8_t * ptr = <a class="code hl_function" href="s2n__stuffer_8c.html#a5148294f6ed0bf894afc83a31ee4f8a5">s2n_stuffer_raw_read</a>(&amp;in, 1500);</div>
<div class="ttc" id="as2n__stuffer_8c_html_aba979c37cd169d15368bcdf473360073"><div class="ttname"><a href="s2n__stuffer_8c.html#aba979c37cd169d15368bcdf473360073">s2n_stuffer_growable_alloc</a></div><div class="ttdeci">int s2n_stuffer_growable_alloc(struct s2n_stuffer *stuffer, const uint32_t size)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer.c:92</div></div>
<div class="ttc" id="as2n__stuffer_8c_html_ad77ea23089bbeb19b897a73bf6ca3fde"><div class="ttname"><a href="s2n__stuffer_8c.html#ad77ea23089bbeb19b897a73bf6ca3fde">s2n_stuffer_write</a></div><div class="ttdeci">int s2n_stuffer_write(struct s2n_stuffer *stuffer, const struct s2n_blob *in)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer.c:292</div></div>
</div><!-- fragment --><p >but attempting to write more data would not be legal:</p>
<div class="fragment"><div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8c.html#aba979c37cd169d15368bcdf473360073">s2n_stuffer_growable_alloc</a>(&amp;in, 1500));</div>
<div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8c.html#ad77ea23089bbeb19b897a73bf6ca3fde">s2n_stuffer_write</a>(&amp;in, &amp;fifteen_hundred_bytes_blob));</div>
<div class="line">uint8_t * ptr = <a class="code hl_function" href="s2n__stuffer_8c.html#a5148294f6ed0bf894afc83a31ee4f8a5">s2n_stuffer_raw_read</a>(&amp;in, 1500);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* This write will fail, the stuffer is no longer growable, as a raw</span></div>
<div class="line"><span class="comment"> * pointer was taken */</span></div>
<div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8c.html#ad77ea23089bbeb19b897a73bf6ca3fde">s2n_stuffer_write</a>(&amp;in, &amp;some_more_data_blob);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Stuffer life cycle is now complete, reset everything and wipe */</span></div>
<div class="line">GUARD(<a class="code hl_function" href="s2n__stuffer_8c.html#a2b6b54f7856d92f06f823bc26d10f4ba">s2n_stuffer_wipe</a>(&amp;in));</div>
<div class="ttc" id="as2n__stuffer_8c_html_a2b6b54f7856d92f06f823bc26d10f4ba"><div class="ttname"><a href="s2n__stuffer_8c.html#a2b6b54f7856d92f06f823bc26d10f4ba">s2n_stuffer_wipe</a></div><div class="ttdeci">int s2n_stuffer_wipe(struct s2n_stuffer *stuffer)</div><div class="ttdef"><b>Definition:</b> s2n_stuffer.c:197</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md336"></a>
s2n_connection and the TLS state machine</h1>
<p >Every connection is associated with an <a class="el" href="structs2n__connection.html">s2n_connection</a> structure. The details of this structure are opaque to applications, but internally it is where all of the TLS state is managed. To make sense of what is going on, it is necessary to understand how the TLS protocol works at the record and handshake layers.</p>
<p >When a TLS connection is being started, the first communication consists of handshake messages. The client sends the first message (a client hello), and then the server replies (with a server hello), and so on. Because a server must wait for a client and vice versa, this phase of a TLS connection is not full-duplex. To save on memory, s2n uses a single stuffer for both incoming and outgoing handshake messages and it is located as s2n_connection-&gt;handshake.io (which is a growable stuffer).</p>
<p >Borrowing another trick from functional programming, the state machine for handling handshake messages is implemented using a table of function pointers, located in <a href="https://github.com/awslabs/s2n/blob/main/tls/s2n_handshake_io.c">tls/s2n_handshake_io.c</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span><a class="code hl_struct" href="structs2n__handshake__action.html">s2n_handshake_action</a> <a class="code hl_variable" href="s2n__handshake__io_8c.html#aa3007da0b854c6f21cff9cc25b44ec7d">state_machine</a>[] = {</div>
<div class="line">    <span class="comment">/*Message type  Handshake type       Writer S2N_SERVER                S2N_CLIENT                   handshake.state              */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, <a class="code hl_define" href="s2n__handshake_8h.html#a97bbcc3a3f636384bc16b898d90879ea">TLS_CLIENT_HELLO</a>,      <span class="charliteral">&#39;C&#39;</span>, {<a class="code hl_function" href="s2n__client__hello_8c.html#abfb7d01ea645110aea3c808de4d86f1d">s2n_client_hello_recv</a>,    <a class="code hl_function" href="s2n__client__hello_8c.html#a4b86117a2a4f018991a01ff788272441">s2n_client_hello_send</a>}},    <span class="comment">/* CLIENT_HELLO              */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, <a class="code hl_define" href="s2n__handshake_8h.html#a048b49dbe4e0abcdaa5f50b2ecd91fc4">TLS_SERVER_HELLO</a>,      <span class="charliteral">&#39;S&#39;</span>, {<a class="code hl_function" href="s2n__server__hello_8c.html#a8e32b708f98ecbfa1148c5393f8b9dba">s2n_server_hello_send</a>,    <a class="code hl_function" href="s2n__server__hello_8c.html#a2139f810755eb8cf27ebea179e81ac81">s2n_server_hello_recv</a>}},    <span class="comment">/* SERVER_HELLO              */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, TLS_SERVER_CERT,       <span class="charliteral">&#39;S&#39;</span>, {<a class="code hl_function" href="s2n__server__cert_8c.html#ab1bb9b2e08cb682e4bb9b156b49a0afa">s2n_server_cert_send</a>,     <a class="code hl_function" href="s2n__server__cert_8c.html#aea75ffb292cac5d71183fee7c14b7496">s2n_server_cert_recv</a>}},     <span class="comment">/* SERVER_CERT               */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, <a class="code hl_define" href="s2n__handshake_8h.html#a9d3fa686a8b630798a5b93e4267937f2">TLS_SERVER_KEY</a>,        <span class="charliteral">&#39;S&#39;</span>, {<a class="code hl_function" href="s2n__server__key__exchange_8c.html#a940aed548236e016710e5ef69dc98df8">s2n_server_key_send</a>,      <a class="code hl_function" href="s2n__server__key__exchange_8c.html#a933dc8cdaebb70f8a7364e390d9deeaf">s2n_server_key_recv</a>}},      <span class="comment">/* SERVER_KEY                */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, TLS_SERVER_CERT_REQ,   <span class="charliteral">&#39;S&#39;</span>, {<a class="code hl_variable" href="namespace_aws.html#a41b67e809416e9bd96026fa1f414925d">NULL</a>,                     <a class="code hl_variable" href="namespace_aws.html#a41b67e809416e9bd96026fa1f414925d">NULL</a>}},                     <span class="comment">/* SERVER_CERT_REQ           */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, <a class="code hl_define" href="s2n__handshake_8h.html#ad4a7ea7191525f41bbdf0775c35eff6e">TLS_SERVER_HELLO_DONE</a>, <span class="charliteral">&#39;S&#39;</span>, {<a class="code hl_function" href="s2n__server__done_8c.html#a944852f699b2815f6a37b602113e26f7">s2n_server_done_send</a>,     <a class="code hl_function" href="s2n__server__done_8c.html#a55414ad2a6f07ebbae51cbd0bf6f5974">s2n_server_done_recv</a>}},     <span class="comment">/* SERVER_HELLO_DONE         */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, TLS_CLIENT_CERT,       <span class="charliteral">&#39;C&#39;</span>, {<a class="code hl_variable" href="namespace_aws.html#a41b67e809416e9bd96026fa1f414925d">NULL</a>,                     <a class="code hl_variable" href="namespace_aws.html#a41b67e809416e9bd96026fa1f414925d">NULL</a>}},                     <span class="comment">/* CLIENT_CERT               */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, <a class="code hl_define" href="s2n__handshake_8h.html#a32b656089b312b746625119dce8119b3">TLS_CLIENT_KEY</a>,        <span class="charliteral">&#39;C&#39;</span>, {<a class="code hl_function" href="s2n__client__key__exchange_8c.html#a5d0b0b0a8964b40aff5e3562bf65a9e1">s2n_client_key_recv</a>,      <a class="code hl_function" href="s2n__client__key__exchange_8c.html#a59294a875b6596b8dd5ad02a58e77c94">s2n_client_key_send</a>}},      <span class="comment">/* CLIENT_KEY                */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, TLS_CLIENT_CERT_VERIFY,<span class="charliteral">&#39;C&#39;</span>, {<a class="code hl_variable" href="namespace_aws.html#a41b67e809416e9bd96026fa1f414925d">NULL</a>,                     <a class="code hl_variable" href="namespace_aws.html#a41b67e809416e9bd96026fa1f414925d">NULL</a>}},                     <span class="comment">/* CLIENT_CERT_VERIFY        */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a5788d973268381c45d0909ebc14a16fd">TLS_CHANGE_CIPHER_SPEC</a>, 0,            <span class="charliteral">&#39;C&#39;</span>, {<a class="code hl_function" href="s2n__change__cipher__spec_8c.html#aab9d53a394720e55e7648730f94bb176">s2n_client_ccs_recv</a>,      s2n_client_ccs_send}},      <span class="comment">/* CLIENT_CHANGE_CIPHER_SPEC */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, TLS_CLIENT_FINISHED,   <span class="charliteral">&#39;C&#39;</span>, {<a class="code hl_function" href="s2n__client__finished_8c.html#a1e5af2e3c7ad308eb7a32333210875f5">s2n_client_finished_recv</a>, <a class="code hl_function" href="s2n__client__finished_8c.html#ac384b39fb82314ba9d3d4aebbae8f0e3">s2n_client_finished_send</a>}}, <span class="comment">/* CLIENT_FINISHED           */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a5788d973268381c45d0909ebc14a16fd">TLS_CHANGE_CIPHER_SPEC</a>, 0,            <span class="charliteral">&#39;S&#39;</span>, {s2n_server_ccs_send,      <a class="code hl_function" href="s2n__change__cipher__spec_8c.html#ae06266c2514a2576c570f3f01d9f9ecf">s2n_server_ccs_recv</a>}},      <span class="comment">/* SERVER_CHANGE_CIPHER_SPEC */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a>, TLS_SERVER_FINISHED,   <span class="charliteral">&#39;S&#39;</span>, {<a class="code hl_function" href="s2n__server__finished_8c.html#a1faebdea4c42a7b27ce347885b9bd9ee">s2n_server_finished_send</a>, <a class="code hl_function" href="s2n__server__finished_8c.html#adae4d52456ffeb3a606ed1fb545539e4">s2n_server_finished_recv</a>}}, <span class="comment">/* SERVER_FINISHED           */</span></div>
<div class="line">    {<a class="code hl_define" href="s2n__tls__parameters_8h.html#a5104f80ba38ebfd2266b1ec313f0aeb2">TLS_APPLICATION_DATA</a>, 0,              <span class="charliteral">&#39;B&#39;</span>, {<a class="code hl_variable" href="namespace_aws.html#a41b67e809416e9bd96026fa1f414925d">NULL</a>, <a class="code hl_variable" href="namespace_aws.html#a41b67e809416e9bd96026fa1f414925d">NULL</a>}}    <span class="comment">/* HANDSHAKE_OVER            */</span></div>
<div class="line">};</div>
<div class="ttc" id="anamespace_aws_html_a41b67e809416e9bd96026fa1f414925d"><div class="ttname"><a href="namespace_aws.html#a41b67e809416e9bd96026fa1f414925d">Aws::NULL</a></div><div class="ttdeci">return NULL</div><div class="ttdef"><b>Definition:</b> cJSON.cpp:951</div></div>
<div class="ttc" id="as2n__change__cipher__spec_8c_html_aab9d53a394720e55e7648730f94bb176"><div class="ttname"><a href="s2n__change__cipher__spec_8c.html#aab9d53a394720e55e7648730f94bb176">s2n_client_ccs_recv</a></div><div class="ttdeci">int s2n_client_ccs_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_change_cipher_spec.c:41</div></div>
<div class="ttc" id="as2n__change__cipher__spec_8c_html_ae06266c2514a2576c570f3f01d9f9ecf"><div class="ttname"><a href="s2n__change__cipher__spec_8c.html#ae06266c2514a2576c570f3f01d9f9ecf">s2n_server_ccs_recv</a></div><div class="ttdeci">int s2n_server_ccs_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_change_cipher_spec.c:63</div></div>
<div class="ttc" id="as2n__client__finished_8c_html_a1e5af2e3c7ad308eb7a32333210875f5"><div class="ttname"><a href="s2n__client__finished_8c.html#a1e5af2e3c7ad308eb7a32333210875f5">s2n_client_finished_recv</a></div><div class="ttdeci">int s2n_client_finished_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_client_finished.c:28</div></div>
<div class="ttc" id="as2n__client__finished_8c_html_ac384b39fb82314ba9d3d4aebbae8f0e3"><div class="ttname"><a href="s2n__client__finished_8c.html#ac384b39fb82314ba9d3d4aebbae8f0e3">s2n_client_finished_send</a></div><div class="ttdeci">int s2n_client_finished_send(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_client_finished.c:40</div></div>
<div class="ttc" id="as2n__client__hello_8c_html_a4b86117a2a4f018991a01ff788272441"><div class="ttname"><a href="s2n__client__hello_8c.html#a4b86117a2a4f018991a01ff788272441">s2n_client_hello_send</a></div><div class="ttdeci">int s2n_client_hello_send(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_client_hello.c:321</div></div>
<div class="ttc" id="as2n__client__hello_8c_html_abfb7d01ea645110aea3c808de4d86f1d"><div class="ttname"><a href="s2n__client__hello_8c.html#abfb7d01ea645110aea3c808de4d86f1d">s2n_client_hello_recv</a></div><div class="ttdeci">int s2n_client_hello_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_client_hello.c:290</div></div>
<div class="ttc" id="as2n__client__key__exchange_8c_html_a59294a875b6596b8dd5ad02a58e77c94"><div class="ttname"><a href="s2n__client__key__exchange_8c.html#a59294a875b6596b8dd5ad02a58e77c94">s2n_client_key_send</a></div><div class="ttdeci">int s2n_client_key_send(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_client_key_exchange.c:309</div></div>
<div class="ttc" id="as2n__client__key__exchange_8c_html_a5d0b0b0a8964b40aff5e3562bf65a9e1"><div class="ttname"><a href="s2n__client__key__exchange_8c.html#a5d0b0b0a8964b40aff5e3562bf65a9e1">s2n_client_key_recv</a></div><div class="ttdeci">int s2n_client_key_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_client_key_exchange.c:214</div></div>
<div class="ttc" id="as2n__handshake_8h_html_a048b49dbe4e0abcdaa5f50b2ecd91fc4"><div class="ttname"><a href="s2n__handshake_8h.html#a048b49dbe4e0abcdaa5f50b2ecd91fc4">TLS_SERVER_HELLO</a></div><div class="ttdeci">#define TLS_SERVER_HELLO</div><div class="ttdef"><b>Definition:</b> s2n_handshake.h:33</div></div>
<div class="ttc" id="as2n__handshake_8h_html_a32b656089b312b746625119dce8119b3"><div class="ttname"><a href="s2n__handshake_8h.html#a32b656089b312b746625119dce8119b3">TLS_CLIENT_KEY</a></div><div class="ttdeci">#define TLS_CLIENT_KEY</div><div class="ttdef"><b>Definition:</b> s2n_handshake.h:41</div></div>
<div class="ttc" id="as2n__handshake_8h_html_a97bbcc3a3f636384bc16b898d90879ea"><div class="ttname"><a href="s2n__handshake_8h.html#a97bbcc3a3f636384bc16b898d90879ea">TLS_CLIENT_HELLO</a></div><div class="ttdeci">#define TLS_CLIENT_HELLO</div><div class="ttdef"><b>Definition:</b> s2n_handshake.h:32</div></div>
<div class="ttc" id="as2n__handshake_8h_html_a9d3fa686a8b630798a5b93e4267937f2"><div class="ttname"><a href="s2n__handshake_8h.html#a9d3fa686a8b630798a5b93e4267937f2">TLS_SERVER_KEY</a></div><div class="ttdeci">#define TLS_SERVER_KEY</div><div class="ttdef"><b>Definition:</b> s2n_handshake.h:37</div></div>
<div class="ttc" id="as2n__handshake_8h_html_ad4a7ea7191525f41bbdf0775c35eff6e"><div class="ttname"><a href="s2n__handshake_8h.html#ad4a7ea7191525f41bbdf0775c35eff6e">TLS_SERVER_HELLO_DONE</a></div><div class="ttdeci">#define TLS_SERVER_HELLO_DONE</div><div class="ttdef"><b>Definition:</b> s2n_handshake.h:39</div></div>
<div class="ttc" id="as2n__handshake__io_8c_html_aa3007da0b854c6f21cff9cc25b44ec7d"><div class="ttname"><a href="s2n__handshake__io_8c.html#aa3007da0b854c6f21cff9cc25b44ec7d">state_machine</a></div><div class="ttdeci">static struct s2n_handshake_action state_machine[]</div><div class="ttdef"><b>Definition:</b> s2n_handshake_io.c:66</div></div>
<div class="ttc" id="as2n__server__cert_8c_html_ab1bb9b2e08cb682e4bb9b156b49a0afa"><div class="ttname"><a href="s2n__server__cert_8c.html#ab1bb9b2e08cb682e4bb9b156b49a0afa">s2n_server_cert_send</a></div><div class="ttdeci">int s2n_server_cert_send(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_cert.c:58</div></div>
<div class="ttc" id="as2n__server__cert_8c_html_aea75ffb292cac5d71183fee7c14b7496"><div class="ttname"><a href="s2n__server__cert_8c.html#aea75ffb292cac5d71183fee7c14b7496">s2n_server_cert_recv</a></div><div class="ttdeci">int s2n_server_cert_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_cert.c:26</div></div>
<div class="ttc" id="as2n__server__done_8c_html_a55414ad2a6f07ebbae51cbd0bf6f5974"><div class="ttname"><a href="s2n__server__done_8c.html#a55414ad2a6f07ebbae51cbd0bf6f5974">s2n_server_done_recv</a></div><div class="ttdeci">int s2n_server_done_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_done.c:25</div></div>
<div class="ttc" id="as2n__server__done_8c_html_a944852f699b2815f6a37b602113e26f7"><div class="ttname"><a href="s2n__server__done_8c.html#a944852f699b2815f6a37b602113e26f7">s2n_server_done_send</a></div><div class="ttdeci">int s2n_server_done_send(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_done.c:32</div></div>
<div class="ttc" id="as2n__server__finished_8c_html_a1faebdea4c42a7b27ce347885b9bd9ee"><div class="ttname"><a href="s2n__server__finished_8c.html#a1faebdea4c42a7b27ce347885b9bd9ee">s2n_server_finished_send</a></div><div class="ttdeci">int s2n_server_finished_send(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_finished.c:47</div></div>
<div class="ttc" id="as2n__server__finished_8c_html_adae4d52456ffeb3a606ed1fb545539e4"><div class="ttname"><a href="s2n__server__finished_8c.html#adae4d52456ffeb3a606ed1fb545539e4">s2n_server_finished_recv</a></div><div class="ttdeci">int s2n_server_finished_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_finished.c:29</div></div>
<div class="ttc" id="as2n__server__hello_8c_html_a2139f810755eb8cf27ebea179e81ac81"><div class="ttname"><a href="s2n__server__hello_8c.html#a2139f810755eb8cf27ebea179e81ac81">s2n_server_hello_recv</a></div><div class="ttdeci">int s2n_server_hello_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_hello.c:172</div></div>
<div class="ttc" id="as2n__server__hello_8c_html_a8e32b708f98ecbfa1148c5393f8b9dba"><div class="ttname"><a href="s2n__server__hello_8c.html#a8e32b708f98ecbfa1148c5393f8b9dba">s2n_server_hello_send</a></div><div class="ttdeci">int s2n_server_hello_send(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_hello.c:225</div></div>
<div class="ttc" id="as2n__server__key__exchange_8c_html_a933dc8cdaebb70f8a7364e390d9deeaf"><div class="ttname"><a href="s2n__server__key__exchange_8c.html#a933dc8cdaebb70f8a7364e390d9deeaf">s2n_server_key_recv</a></div><div class="ttdeci">int s2n_server_key_recv(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_key_exchange.c:39</div></div>
<div class="ttc" id="as2n__server__key__exchange_8c_html_a940aed548236e016710e5ef69dc98df8"><div class="ttname"><a href="s2n__server__key__exchange_8c.html#a940aed548236e016710e5ef69dc98df8">s2n_server_key_send</a></div><div class="ttdeci">int s2n_server_key_send(struct s2n_connection *conn)</div><div class="ttdef"><b>Definition:</b> s2n_server_key_exchange.c:234</div></div>
<div class="ttc" id="as2n__tls__parameters_8h_html_a04fd920fd9f28238887e4c6417b4d4cc"><div class="ttname"><a href="s2n__tls__parameters_8h.html#a04fd920fd9f28238887e4c6417b4d4cc">TLS_HANDSHAKE</a></div><div class="ttdeci">#define TLS_HANDSHAKE</div><div class="ttdef"><b>Definition:</b> s2n_tls_parameters.h:178</div></div>
<div class="ttc" id="as2n__tls__parameters_8h_html_a5104f80ba38ebfd2266b1ec313f0aeb2"><div class="ttname"><a href="s2n__tls__parameters_8h.html#a5104f80ba38ebfd2266b1ec313f0aeb2">TLS_APPLICATION_DATA</a></div><div class="ttdeci">#define TLS_APPLICATION_DATA</div><div class="ttdef"><b>Definition:</b> s2n_tls_parameters.h:179</div></div>
<div class="ttc" id="as2n__tls__parameters_8h_html_a5788d973268381c45d0909ebc14a16fd"><div class="ttname"><a href="s2n__tls__parameters_8h.html#a5788d973268381c45d0909ebc14a16fd">TLS_CHANGE_CIPHER_SPEC</a></div><div class="ttdeci">#define TLS_CHANGE_CIPHER_SPEC</div><div class="ttdef"><b>Definition:</b> s2n_tls_parameters.h:176</div></div>
<div class="ttc" id="astructs2n__handshake__action_html"><div class="ttname"><a href="structs2n__handshake__action.html">s2n_handshake_action</a></div><div class="ttdef"><b>Definition:</b> s2n_handshake_io.c:44</div></div>
</div><!-- fragment --><p >The 'writer' field indicates whether we expect a Client or a Server to write a particular message type (or 'B' for both in the case of an application data message, but we haven't gotten to that yet). If s2n is acting as a server, then it attempts to read client messages, if it's acting as a client it will try to write it. To perform either operation it calls the relevant function pointer. This way the state machine can be very short and simple: write a handshake message out when we have one pending, and in the other direction read in data until we have a fully-buffered handshake message before then calling the relevant message parsing function.</p>
<p >One detail we've skipped over so far is that handshake messages are encapsulated by an additional record layer within the TLS protocol. As we've already seen, TLS records are fairly simple: just a 5-byte header indicating the message type (Handshake, application data, and alerts), protocol version, and record size. The remainder of the record is data and may or may not be encrypted. What isn't so simple is that TLS allows 'inner' messages, like Handshake message, to be fragmented across several records, and for a single record to contain multiple messages.</p>
<p ><img src="images/s2n_tls_layers.png" alt="TLS layers" title="s2n TLS layers" class="inline"/></p>
<p >In the outbound direction, s2n never coalesces multiple messages into a single record, so writing a handshake message is a simple matter of fragmenting the handshake message if necessary and writing the records. In the inbound direction, the small state machine in <a class="el" href="s2n__handshake__io_8c.html">s2n_handshake_io.c</a> takes care of any fragmentation and coalescing. See <a href="https://github.com/awslabs/s2n/blob/main/tests/unit/s2n_fragmentation_coalescing_test.c">tests/unit/s2n_fragmentation_coalescing_test.c</a> for our test cases covering the logic too.</p>
<p >To perform all of this, the <a class="el" href="structs2n__connection.html">s2n_connection</a> structure has a few more internal stuffers:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> header_in;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> in;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> out;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> alert_in;</div>
</div><!-- fragment --><p >'header_in' is a small 5-byte stuffer, which is used to read in a record header. Once that stuffer is full, and the size of the next record is determined (from that header), inward data is directed to the 'in' stuffer. The 'out' stuffer is for data that we are writing out; like an encrypted TLS record. 'alert_in' is for any TLS alert message that s2n receives from its peer. s2n treats all alerts as fatal, but we buffer the full alert message so that reason can be logged.</p>
<p >When past the handshake phase, s2n supports full-duplex I/O. Separate threads or event handlers are free to call s2n_send and s2n_recv on the same connection. Because either a read or a write may cause a connection to be closed, there are two additional stuffers for storing outbound alert messages:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> reader_alert_out;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structs2n__stuffer.html">s2n_stuffer</a> writer_alert_out;</div>
</div><!-- fragment --><p >this pattern means that both the reader thread and writer thread can create pending alert messages without needing any locks. If either the reader or writer generates an alert, it also sets the 'closing' state to 1.</p>
<div class="fragment"><div class="line">sig_atomic_t closing;</div>
<div class="line">sig_atomic_t closed;</div>
</div><!-- fragment --><p >'closing' is an atomic, but even if it were not it can only be changed from 0 to 1, so an over-write is harmless. Every time a TLS record is fully-written, <a class="el" href="s2n_8h.html#a9afeb514731fa9d74edf6b9e1348c067">s2n_send()</a> checks to see if closing is set to 1. If it is then the reader or writer alert message will be sent (writer takes priority, if both are present) and the connection will be closed. Once the closed is 1, no more I/O may be sent or received on the connection.</p>
<h1><a class="anchor" id="autotoc_md337"></a>
s2n and entropy</h1>
<p >s2n provides two deterministic random number generators to every thread. <b>s2n_get_public_random_data()</b> should be used to generate any data that is exposed in a public context including nonces, initialization vectors, and randomized timing values. <b>s2n_get_private_random_data()</b> should be used for data which must be kept secret. Additionally s2n over-rides libcrypto's entropy generation with <b>s2n_get_private_random_data()</b>.</p>
<h1><a class="anchor" id="autotoc_md338"></a>
Contributing to s2n</h1>
<p >We are happy to accept contributions to s2n. We suggest the following general procedure:</p>
<ul>
<li>Please read all of the documentation available in the s2n "docs/" directory. This development guide along with the usage guide should give a good flavor for what the goals of s2n are and whether they line up with your idea for a contribution</li>
<li>If you have an idea for a significant contribution, it is worth first cutting an issue and discussing the change. Get feedback on the API design, or what the feature might require, before writing code.</li>
<li>If you discover a security critical bug, please report it via <a href="http://aws.amazon.com/security/vulnerability-reporting/">http://aws.amazon.com/security/vulnerability-reporting/</a> and <b>do not</b> create a public issue.</li>
<li>Create a git fork of the s2n repository and prepare your changes locally within your fork.</li>
<li>When you're ready, and when all tests are passing, create a pull request to the master awslabs s2n repository.</li>
<li>All changes to s2n go through code review and legal review. All submissions and contributions are made under the terms of the Apache Software License 2.0. For larger contributions, we may ask you to sign a contributor license agreement.</li>
<li>s2n undergoes periodic government and commercial security analyses, including code audits and penetration tests. To participate in these analyses, we may ask you to sign a Non-Disclosure Agreement. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
